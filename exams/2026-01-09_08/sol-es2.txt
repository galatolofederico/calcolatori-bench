******************************************
* sistema/sistema.cpp
******************************************

// ( SOLUZIONE 2026-01-09
	while (des_proc* lavoro = rimozione_lista(s->pointer)) {
		s->counter++;
		des_proc *orig = lavoro;
		if (lavoro->shadow) {
			orig = proc_table[lavoro->id];
			delete lavoro;
		}
		if (!mw_missing(orig)) {
			for (natl i = 0; i < orig->mw_num; i++) {
				des_sem *s = &array_dess[orig->mw_sems[i]];
				s->counter--;
			}
			inspronti();
			inserimento_lista(pronti, orig);
			schedulatore();
			break;
		}
	}
//   SOLUZIONE 2026-01-09 )
// ( SOLUZIONE 2026-01-09
	if (n > MAX_MULTIWAIT) {
		flog(LOG_WARN, "sem_multiwait: numero di semafori non valido: %u", n);
		c_abort_p();
		return;
	}
	
	if (!c_access(int_cast<vaddr>(sems), n * sizeof(natl), false, false)) {
		flog(LOG_WARN, "sem_multiwait: array di semafori non valido");
		c_abort_p();
		return;
	}

	memcpy(esecuzione->mw_sems, sems, n * sizeof(natl));

	for (natl i = 0; i < n; i++) {
		if (!sem_valido(esecuzione->mw_sems[i])) {
			flog(LOG_WARN, "sem_multiwait: semaforo %u non valido",
					esecuzione->mw_sems[i]);
			c_abort_p();
			return;
		}
	}
	esecuzione->mw_num = n;
//   SOLUZIONE 2026-01-09 )


