{
  "generated_at": "2026-02-14T14:23:23.214137Z",
  "total_models": 2,
  "total_exams": 3,
  "models": [
    "glm-4.7",
    "minimax-m2.5-openrouter"
  ],
  "exams": [
    "2023-01-11_08",
    "2023-06-07_08",
    "2023-09-13_08"
  ],
  "model_stats": {
    "glm-4.7": {
      "passed": 1,
      "total": 3,
      "percentage": 33.3
    },
    "minimax-m2.5-openrouter": {
      "passed": 0,
      "total": 3,
      "percentage": 0.0
    }
  },
  "exam_results": {
    "2023-01-11_08": {
      "glm-4.7": {
        "passed": true,
        "error": null
      },
      "minimax-m2.5-openrouter": {
        "passed": false,
        "error": null
      }
    },
    "2023-06-07_08": {
      "glm-4.7": {
        "passed": false,
        "error": null
      },
      "minimax-m2.5-openrouter": {
        "passed": false,
        "error": null
      }
    },
    "2023-09-13_08": {
      "glm-4.7": {
        "passed": false,
        "error": null
      },
      "minimax-m2.5-openrouter": {
        "passed": false,
        "error": null
      }
    }
  },
  "detailed_results": {
    "glm-4.7": {
      "2023-01-11_08": {
        "passed": true,
        "error": null,
        "diff": "diff --git a/io/io.cpp b/io/io.cpp\nindex 50ed8f0..290b82e 100644\n--- a/io/io.cpp\n+++ b/io/io.cpp\n@@ -416,6 +416,21 @@ extern \"C\" int c_bufcache_status(natl *blocks, natl *io_count)\n //   ESAME 2023-01-11 )\n \n // ( SOLUZIONE 2023-01-11\n+/**\n+ * @brief Cerca un blocco nella buffer cache\n+ * @param block numero del blocco da cercare\n+ * @return puntatore al buffer se trovato, nullptr altrimenti\n+ */\n+buf_des* bufcache_find(natl block)\n+{\n+\tdes_ata *d = &hard_disk;\n+\tfor (int i = 0; i < MAX_BUF_DES; i++) {\n+\t\tbuf_des *b = &d->bufcache[i];\n+\t\tif (b->full && b->block == block)\n+\t\t\treturn b;\n+\t}\n+\treturn nullptr;\n+}\n //   SOLUZIONE 2023-01-11 )\n /// Piedino dell'APIC per le richieste di interruzione dell'hard disk\n const natb HD_IRQ = 14;\n@@ -495,6 +510,43 @@ extern \"C\" void c_readhd_n(natb vetti[], natl primo, natb quanti)\n \n /// @todo Gestire l'operazione tenendo conto della buffer cache.\n // ( SOLUZIONE 2023-01-11\n+\tsem_wait(d->mutex);\n+\tfor (natb i = 0; i < quanti; i++) {\n+\t\tnatl block = primo + i;\n+\t\tnatb* dest = vetti + i * DIM_BLOCK;\n+\t\t\n+\t\tbuf_des *b = bufcache_find(block);\n+\t\t\n+\t\tif (b) {\n+\t\t\tmemcpy(dest, b->buf, DIM_BLOCK);\n+\t\t\tbufcache_promote(b);\n+\t\t} else {\n+\t\t\tbuf_des *buf = nullptr;\n+\t\t\tint buf_idx;\n+\t\t\t\n+\t\t\tfor (buf_idx = 0; buf_idx < MAX_BUF_DES; buf_idx++) {\n+\t\t\t\tif (!d->bufcache[buf_idx].full) {\n+\t\t\t\t\tbuf = &d->bufcache[buf_idx];\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tif (!buf) {\n+\t\t\t\tbuf_idx = d->lru;\n+\t\t\t\tbuf = &d->bufcache[buf_idx];\n+\t\t\t}\n+\t\t\t\n+\t\t\tstarthd_in(d, buf->buf, block, 1);\n+\t\t\tsem_wait(d->sincr);\n+\t\t\t\n+\t\t\tbuf->full = true;\n+\t\t\tbuf->block = block;\n+\t\t\tmemcpy(dest, buf->buf, DIM_BLOCK);\n+\t\t\t\n+\t\t\tbufcache_promote(buf);\n+\t\t}\n+\t}\n+\tsem_signal(d->mutex);\n //   SOLUZIONE 2023-01-11 )\n //   ESAME 2023-01-11 ]\n }\n@@ -543,6 +595,21 @@ extern \"C\" void c_writehd_n(natb vetto[], natl primo, natb quanti)\n \t//sem_signal(d->mutex);\n /// @todo Gestire l'operazione tenendo conto della buffer cache.\n // ( SOLUZIONE 2023-01-11\n+\tsem_wait(d->mutex);\n+\tfor (natb i = 0; i < quanti; i++) {\n+\t\tnatl block = primo + i;\n+\t\tnatb* src = vetto + i * DIM_BLOCK;\n+\t\t\n+\t\tstarthd_out(d, src, block, 1);\n+\t\tsem_wait(d->sincr);\n+\t\t\n+\t\tbuf_des *b = bufcache_find(block);\n+\t\tif (b) {\n+\t\t\tmemcpy(b->buf, src, DIM_BLOCK);\n+\t\t\tbufcache_promote(b);\n+\t\t}\n+\t}\n+\tsem_signal(d->mutex);\n //   SOLUZIONE 2023-01-11 )\n //   ESAME 2023-01-11 ]\n }\n@@ -735,6 +802,14 @@ bool hd_init()\n \thd::enable_intr();\n \n // ( SOLUZIONE 2023-01-11\n+\tfor (int i = 0; i < MAX_BUF_DES; i++) {\n+\t\td->bufcache[i].full = false;\n+\t\td->bufcache[i].next = -1;\n+\t\td->bufcache[i].prev = -1;\n+\t}\n+\td->lru = -1;\n+\td->mru = -1;\n+\td->io_count = 0;\n //   SOLUZIONE 2023-01-11 )\n \n \treturn true;\ndiff --git a/io/io.cpp b/io/io.cpp\nindex 50ed8f0..290b82e 100644\n--- a/io/io.cpp\n+++ b/io/io.cpp\n@@ -416,6 +416,21 @@ extern \"C\" int c_bufcache_status(natl *blocks, natl *io_count)\n //   ESAME 2023-01-11 )\n \n // ( SOLUZIONE 2023-01-11\n+/**\n+ * @brief Cerca un blocco nella buffer cache\n+ * @param block numero del blocco da cercare\n+ * @return puntatore al buffer se trovato, nullptr altrimenti\n+ */\n+buf_des* bufcache_find(natl block)\n+{\n+\tdes_ata *d = &hard_disk;\n+\tfor (int i = 0; i < MAX_BUF_DES; i++) {\n+\t\tbuf_des *b = &d->bufcache[i];\n+\t\tif (b->full && b->block == block)\n+\t\t\treturn b;\n+\t}\n+\treturn nullptr;\n+}\n //   SOLUZIONE 2023-01-11 )\n /// Piedino dell'APIC per le richieste di interruzione dell'hard disk\n const natb HD_IRQ = 14;\n@@ -495,6 +510,43 @@ extern \"C\" void c_readhd_n(natb vetti[], natl primo, natb quanti)\n \n /// @todo Gestire l'operazione tenendo conto della buffer cache.\n // ( SOLUZIONE 2023-01-11\n+\tsem_wait(d->mutex);\n+\tfor (natb i = 0; i < quanti; i++) {\n+\t\tnatl block = primo + i;\n+\t\tnatb* dest = vetti + i * DIM_BLOCK;\n+\t\t\n+\t\tbuf_des *b = bufcache_find(block);\n+\t\t\n+\t\tif (b) {\n+\t\t\tmemcpy(dest, b->buf, DIM_BLOCK);\n+\t\t\tbufcache_promote(b);\n+\t\t} else {\n+\t\t\tbuf_des *buf = nullptr;\n+\t\t\tint buf_idx;\n+\t\t\t\n+\t\t\tfor (buf_idx = 0; buf_idx < MAX_BUF_DES; buf_idx++) {\n+\t\t\t\tif (!d->bufcache[buf_idx].full) {\n+\t\t\t\t\tbuf = &d->bufcache[buf_idx];\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t\n+\t\t\tif (!buf) {\n+\t\t\t\tbuf_idx = d->lru;\n+\t\t\t\tbuf = &d->bufcache[buf_idx];\n+\t\t\t}\n+\t\t\t\n+\t\t\tstarthd_in(d, buf->buf, block, 1);\n+\t\t\tsem_wait(d->sincr);\n+\t\t\t\n+\t\t\tbuf->full = true;\n+\t\t\tbuf->block = block;\n+\t\t\tmemcpy(dest, buf->buf, DIM_BLOCK);\n+\t\t\t\n+\t\t\tbufcache_promote(buf);\n+\t\t}\n+\t}\n+\tsem_signal(d->mutex);\n //   SOLUZIONE 2023-01-11 )\n //   ESAME 2023-01-11 ]\n }\n@@ -543,6 +595,21 @@ extern \"C\" void c_writehd_n(natb vetto[], natl primo, natb quanti)\n \t//sem_signal(d->mutex);\n /// @todo Gestire l'operazione tenendo conto della buffer cache.\n // ( SOLUZIONE 2023-01-11\n+\tsem_wait(d->mutex);\n+\tfor (natb i = 0; i < quanti; i++) {\n+\t\tnatl block = primo + i;\n+\t\tnatb* src = vetto + i * DIM_BLOCK;\n+\t\t\n+\t\tstarthd_out(d, src, block, 1);\n+\t\tsem_wait(d->sincr);\n+\t\t\n+\t\tbuf_des *b = bufcache_find(block);\n+\t\tif (b) {\n+\t\t\tmemcpy(b->buf, src, DIM_BLOCK);\n+\t\t\tbufcache_promote(b);\n+\t\t}\n+\t}\n+\tsem_signal(d->mutex);\n //   SOLUZIONE 2023-01-11 )\n //   ESAME 2023-01-11 ]\n }\n@@ -735,6 +802,14 @@ bool hd_init()\n \thd::enable_intr();\n \n // ( SOLUZIONE 2023-01-11\n+\tfor (int i = 0; i < MAX_BUF_DES; i++) {\n+\t\td->bufcache[i].full = false;\n+\t\td->bufcache[i].next = -1;\n+\t\td->bufcache[i].prev = -1;\n+\t}\n+\td->lru = -1;\n+\td->mru = -1;\n+\td->io_count = 0;\n //   SOLUZIONE 2023-01-11 )\n \n \treturn true;\n",
        "output": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 5: OK",
          "TEST 3 PROC 5: OK",
          "TEST 4 PROC 5: OK",
          "TEST 5 PROC 5: OK",
          "TEST 6 PROC 5: OK",
          "TEST 7 PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "expected": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 5: OK",
          "TEST 3 PROC 5: OK",
          "TEST 4 PROC 5: OK",
          "TEST 5 PROC 5: OK",
          "TEST 6 PROC 5: OK",
          "TEST 7 PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=116b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   67a2 memsize   67a2\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   2ef4 memsize   2ef4\nINF\t-\t  . seg[3]: off   a000 vaddr           20a000 size    180 memsize  17404\nINF\t-\t- mod[1]: start=117000 end=11d578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3fd4 memsize   3fd4\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   1a54 memsize   1a54\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    a60\nINF\t-\t- mod[2]: start=11e000 end=122580 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   279c memsize   279c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    ecc memsize    ecc\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    190 memsize   2890\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   67a2 byte da   10c000 a   200000\nINF\t-\t- copiati   2ef4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   116000 a   20a000\nINF\t-\t- azzerati ulteriori 17284 byte\nINF\t-\t- entry point 2055c7\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 546 (M1) 7646 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000007000)\nINF\t0\t - heap:                                 [ffff800000007000, ffff800000107000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:728](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000006890, 0xffff800000106890)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:299](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: funzionalita' minima\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:49](1) prio=600 liv=3\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: lettura\nINF\t5\tproc=7 entry=t02p0b(unsigned long) [utente.cpp:76](2) prio=599 liv=3\nINF\t6\tProcesso 6 terminato\nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: lettura da cache\nINF\t5\tproc=8 entry=t03p0b(unsigned long) [utente.cpp:104](3) prio=598 liv=3\nINF\t7\tProcesso 7 terminato\nUSR\t5\tTEST 3 PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: lettura da cache\nINF\t5\tproc=9 entry=t04p0b(unsigned long) [utente.cpp:138](4) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nUSR\t5\tTEST 4 PROC 5: OK\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: riempimento cache\nINF\t5\tproc=10 entry=t05p0b(unsigned long) [utente.cpp:187](5) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nUSR\t5\tTEST 5 PROC 5: OK\nDBG\t5\tTEST 5: === FINE ===\nDBG\t5\tTEST 6: >>>INIZIO<<<: rimpiazzamento\nINF\t5\tproc=11 entry=t06p0b(unsigned long) [utente.cpp:222](6) prio=595 liv=3\nINF\t10\tProcesso 10 terminato\nUSR\t5\tTEST 6 PROC 5: OK\nDBG\t5\tTEST 6: === FINE ===\nDBG\t5\tTEST 7: >>>INIZIO<<<: rimpiazzamento dopo scrittura\nINF\t5\tproc=12 entry=t07p0b(unsigned long) [utente.cpp:258](7) prio=594 liv=3\nINF\t11\tProcesso 11 terminato\nUSR\t5\tTEST 7 PROC 5: OK\nDBG\t5\tTEST 7: === FINE ===\nUSR\t5\tPremere un tasto per continuare\nINF\t5\tProcesso 5 terminato\nINF\t12\tProcesso 12 terminato\nINF\t0\tShutdown\n",
        "agent_output": "",
        "duration_seconds": null
      },
      "2023-06-07_08": {
        "passed": false,
        "error": null,
        "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 59d0e91..b1d3a1a 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -827,9 +827,28 @@ paddr cow_root;\n  */\n bool crea_cow_condivisa()\n {\n-/// @todo creare la prima copia della zona cow\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tcow_root = alloca_tab();\n+\tif (cow_root == 0)\n+\t\treturn false;\n+\t\n+\tvaddr v = map(cow_root, ini_utn_w, ini_utn_w + DIM_USR_COW, BIT_US,\n+\t\t[](vaddr) { \n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f) {\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\t}\n+\t\t\treturn f;\n+\t\t});\n+\t\n+\tif (v != ini_utn_w + DIM_USR_COW) {\n+\t\tunmap(cow_root, ini_utn_w, v, \n+\t\t\t[](vaddr, paddr p, int) { \n+\t\t\t\tif (p) rilascia_frame(p); \n+\t\t\t});\n+\t\trilascia_tab(cow_root);\n+\t\treturn false;\n+\t}\n+\treturn true;\n }\n \n /**\n@@ -848,8 +867,34 @@ void copia_cow_condivisa(paddr dest)\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tif (v < ini_utn_w || v >= fin_utn_w)\n+\t\treturn false;\n+\t\n+\tvaddr page = v & ~(DIM_PAGINA - 1);\n+\tpaddr old_frame = trasforma(esecuzione->cr3, page);\n+\tif (old_frame == 0)\n+\t\treturn false;\n+\t\n+\tpaddr new_frame = alloca_frame();\n+\tif (new_frame == 0)\n+\t\treturn false;\n+\t\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\t\n+\ttab_iter it(esecuzione->cr3, page, DIM_PAGINA);\n+\tfor (it.post(); it; it.next_post()) {\n+\t\ttab_entry& e = it.get_e();\n+\t\tint liv = it.get_l();\n+\t\tif (liv == 1) {\n+\t\t\te = new_frame | BIT_P | BIT_US | BIT_RW;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\t\n+\tasm volatile(\"sfence\" ::: \"memory\");\n+\tasm volatile(\"invlpg (%0)\" : : \"r\"(page) : \"memory\");\n+\t\n+\treturn true;\n }\n \n /**\ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 59d0e91..b1d3a1a 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -827,9 +827,28 @@ paddr cow_root;\n  */\n bool crea_cow_condivisa()\n {\n-/// @todo creare la prima copia della zona cow\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tcow_root = alloca_tab();\n+\tif (cow_root == 0)\n+\t\treturn false;\n+\t\n+\tvaddr v = map(cow_root, ini_utn_w, ini_utn_w + DIM_USR_COW, BIT_US,\n+\t\t[](vaddr) { \n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f) {\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\t}\n+\t\t\treturn f;\n+\t\t});\n+\t\n+\tif (v != ini_utn_w + DIM_USR_COW) {\n+\t\tunmap(cow_root, ini_utn_w, v, \n+\t\t\t[](vaddr, paddr p, int) { \n+\t\t\t\tif (p) rilascia_frame(p); \n+\t\t\t});\n+\t\trilascia_tab(cow_root);\n+\t\treturn false;\n+\t}\n+\treturn true;\n }\n \n /**\n@@ -848,8 +867,34 @@ void copia_cow_condivisa(paddr dest)\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tif (v < ini_utn_w || v >= fin_utn_w)\n+\t\treturn false;\n+\t\n+\tvaddr page = v & ~(DIM_PAGINA - 1);\n+\tpaddr old_frame = trasforma(esecuzione->cr3, page);\n+\tif (old_frame == 0)\n+\t\treturn false;\n+\t\n+\tpaddr new_frame = alloca_frame();\n+\tif (new_frame == 0)\n+\t\treturn false;\n+\t\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\t\n+\ttab_iter it(esecuzione->cr3, page, DIM_PAGINA);\n+\tfor (it.post(); it; it.next_post()) {\n+\t\ttab_entry& e = it.get_e();\n+\t\tint liv = it.get_l();\n+\t\tif (liv == 1) {\n+\t\t\te = new_frame | BIT_P | BIT_US | BIT_RW;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\t\n+\tasm volatile(\"sfence\" ::: \"memory\");\n+\tasm volatile(\"invlpg (%0)\" : : \"r\"(page) : \"memory\");\n+\t\n+\treturn true;\n }\n \n /**\n",
        "output": [
          "TEST 1: PROC 5: OK"
        ],
        "expected": [
          "TEST 1: PROC 5: OK",
          "TEST 2: PROC 5: OK",
          "TEST 3: PROC 5: OK",
          "TEST 4: PROC 5: OK",
          "TEST 5: PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6fa6 memsize   6fa6\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   30ec memsize   30ec\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6fa6 byte da   10c000 a   200000\nINF\t-\t- copiati   30ec byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 205dcb\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 7095 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000010000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1: PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nERR\t9\tPANIC: PAGE FAULT NON RISOLTO\nERR\t9\t  processi: 2\nERR\t9\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t9\tcorpo t02p0b(unsigned long) [utente.cpp:99](2), livello UTENTE, precedenza 597\nERR\t9\t  RIP=panic [sistema.cpp:1907] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=6 [-- -- -- -- -- -- -- -- PF --, IOPL=SISTEMA]\nERR\t9\t  RAX=               a RBX=               7 RCX=               0 RDX=      ffffff03f8\nERR\t9\t  RDI=               3 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nERR\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nERR\t9\t  R12=               e R13=ffff80000000034a R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > gestore_eccezioni [sistema.cpp:460]\nERR\t9\t  > exc_page_fault [sistema.s:812]\nERR\t9\t  > t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\nERR\t9\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t9\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1577](0), livello SISTEMA, precedenza 0\nERR\t9\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=          202bef RBX=            13a0 RCX=               0 RDX=          2203f8\nERR\t9\t  RDI=            13a0 RSI=          222230 RBP=          222300 RSP=          222220\nERR\t9\t  R8 =              30 R9 =          22205f R10=               0 R11=               0\nERR\t9\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > main [sistema.cpp:1710]\nERR\t9\t  > _start [start64.s:33]\nERR\t9\tproc 2: corpo estern_kbd(unsigned long) [io.cpp:197](0), livello SISTEMA, precedenza 1104\nERR\t9\t  RIP=estern_kbd(unsigned long) [io.cpp:197] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t9\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t9\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\tproc 3: corpo estern_hd(unsigned long) [io.cpp:557](0), livello SISTEMA, precedenza 1120\nERR\t9\t  RIP=estern_hd(unsigned long) [io.cpp:557] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t9\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t9\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\tproc 5: corpo main_body(unsigned long) [utente.cpp:170](0), livello UTENTE, precedenza 900\nERR\t9\t  RIP=sem_wait [utente.s:49] CPL=LIV_UTENTE\nERR\t9\t  RFLAGS=202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=ffff800000004188 RBX=ffff800000004180 RCX=               3 RDX=ffff800000004160\nERR\t9\t  RDI=               1 RSI=               2 RBP=fffffffffffffff0 RSP=ffffffffffffffc8\nERR\t9\t  R8 =              65 R9 =fffffffffffffe92 R10=               0 R11=               0\nERR\t9\t  R12=            1b95 R13=ffff800000004188 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > main_body(unsigned long) [utente.cpp:196]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\n",
        "agent_output": "",
        "duration_seconds": null
      },
      "2023-09-13_08": {
        "passed": false,
        "error": null,
        "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex b7626da..dc04361 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -837,12 +837,13 @@ bool crea_cow(paddr dest)\n \t\t\t[](vaddr v) {\n \t\t\t\tpaddr f = alloca_frame();\n \t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n-\t\t\t\t// nshared \u00e8 inizialmente zero per tutti i frame\n+\t\t\t\tvdf[f / DIM_PAGINA].nshared = 1;\n \t\t\t\treturn f;\n \t\t\t});\n \tif (v != ini_utn_w + DIM_USR_COW) {\n \t\tunmap(dest, ini_utn_w, v,\n \t\t\t[](vaddr, paddr p, int) {\n+\t\t\t\tvdf[p / DIM_PAGINA].nshared = 0;\n \t\t\t\trilascia_frame(p);\n \t\t\t});\n \t\treturn false;\n@@ -863,9 +864,17 @@ bool crea_cow(paddr dest)\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-/// @todo Realizzare la copia.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\ttab_entry* tab_src = ptr_cast<tab_entry>(src);\n+\ttab_entry* tab_dest = ptr_cast<tab_entry>(dest);\n+\tfor (natq i = 0; i < N_UTN_W; i++) {\n+\t\ttab_entry e = tab_src[I_UTN_W + i];\n+\t\tif (e & BIT_P) {\n+\t\t\tpaddr l3 = extr_IND_FISICO(e);\n+\t\t\tvdf[l3 / DIM_PAGINA].nshared++;\n+\t\t\ttab_dest[I_UTN_W + i] = e & ~BIT_RW;\n+\t\t\tinc_ref(dest);\n+\t\t}\n+\t}\n }\n \n // ( SOLUZIONE 2023-09-13\n@@ -890,6 +899,10 @@ bool aggiorna_cow(vaddr v)\n \t\t\tif (!new_frame)\n \t\t\t\treturn false;\n \t\t\tcopy_des(old_frame, new_frame, 0, 512);\n+\t\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\tset_IND_FISICO(e, new_frame);\n+\t\t\te |= BIT_RW;\n \t\t} else {\n \t\t\tnew_frame = alloca_frame();\n \t\t\tif (!new_frame)\n@@ -897,12 +910,11 @@ bool aggiorna_cow(vaddr v)\n \t\t\tmemcpy(voidptr_cast(new_frame),\n \t\t\t       voidptr_cast(old_frame), DIM_PAGINA);\n \t\t\tinvalida_entrata_TLB(it.get_v());\n+\t\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\tset_IND_FISICO(e, new_frame);\n+\t\t\te |= BIT_RW;\n \t\t}\n-\t\tset_IND_FISICO(e, new_frame);\n-\t\te |= BIT_RW;\n-/// @todo Completare l'aggiornamento dello stato.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n \t}\n \treturn true;\n }\n@@ -912,9 +924,26 @@ bool aggiorna_cow(vaddr v)\n  */\n void distruggi_cow()\n {\n-//// @todo Realizzare la funzione.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\ttab_entry* root = ptr_cast<tab_entry>(esecuzione->cr3);\n+\tfor (natq i = 0; i < N_UTN_W; i++) {\n+\t\ttab_entry e = root[I_UTN_W + i];\n+\t\tif (!(e & BIT_P))\n+\t\t\tcontinue;\n+\t\tpaddr l3 = extr_IND_FISICO(e);\n+\t\troot[I_UTN_W + i] = 0;\n+\t\tdec_ref(esecuzione->cr3);\n+\t\tif (--vdf[l3 / DIM_PAGINA].nshared == 0) {\n+\t\t\tset_des(l3, 0, 512, 0);\n+\t\t\tunmap(l3, 0, dim_region(MAX_LIV - 1),\n+\t\t\t\t[](vaddr, paddr f, int liv) {\n+\t\t\t\t\tif (liv == 0)\n+\t\t\t\t\t\trilascia_frame(f);\n+\t\t\t\t\telse\n+\t\t\t\t\t\trilascia_tab(f);\n+\t\t\t\t});\n+\t\t\trilascia_tab(l3);\n+\t\t}\n+\t}\n }\n //   ESAME 2023-09-13 )\n \ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex b7626da..dc04361 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -837,12 +837,13 @@ bool crea_cow(paddr dest)\n \t\t\t[](vaddr v) {\n \t\t\t\tpaddr f = alloca_frame();\n \t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n-\t\t\t\t// nshared \u00e8 inizialmente zero per tutti i frame\n+\t\t\t\tvdf[f / DIM_PAGINA].nshared = 1;\n \t\t\t\treturn f;\n \t\t\t});\n \tif (v != ini_utn_w + DIM_USR_COW) {\n \t\tunmap(dest, ini_utn_w, v,\n \t\t\t[](vaddr, paddr p, int) {\n+\t\t\t\tvdf[p / DIM_PAGINA].nshared = 0;\n \t\t\t\trilascia_frame(p);\n \t\t\t});\n \t\treturn false;\n@@ -863,9 +864,17 @@ bool crea_cow(paddr dest)\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-/// @todo Realizzare la copia.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\ttab_entry* tab_src = ptr_cast<tab_entry>(src);\n+\ttab_entry* tab_dest = ptr_cast<tab_entry>(dest);\n+\tfor (natq i = 0; i < N_UTN_W; i++) {\n+\t\ttab_entry e = tab_src[I_UTN_W + i];\n+\t\tif (e & BIT_P) {\n+\t\t\tpaddr l3 = extr_IND_FISICO(e);\n+\t\t\tvdf[l3 / DIM_PAGINA].nshared++;\n+\t\t\ttab_dest[I_UTN_W + i] = e & ~BIT_RW;\n+\t\t\tinc_ref(dest);\n+\t\t}\n+\t}\n }\n \n // ( SOLUZIONE 2023-09-13\n@@ -890,6 +899,10 @@ bool aggiorna_cow(vaddr v)\n \t\t\tif (!new_frame)\n \t\t\t\treturn false;\n \t\t\tcopy_des(old_frame, new_frame, 0, 512);\n+\t\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\tset_IND_FISICO(e, new_frame);\n+\t\t\te |= BIT_RW;\n \t\t} else {\n \t\t\tnew_frame = alloca_frame();\n \t\t\tif (!new_frame)\n@@ -897,12 +910,11 @@ bool aggiorna_cow(vaddr v)\n \t\t\tmemcpy(voidptr_cast(new_frame),\n \t\t\t       voidptr_cast(old_frame), DIM_PAGINA);\n \t\t\tinvalida_entrata_TLB(it.get_v());\n+\t\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\tset_IND_FISICO(e, new_frame);\n+\t\t\te |= BIT_RW;\n \t\t}\n-\t\tset_IND_FISICO(e, new_frame);\n-\t\te |= BIT_RW;\n-/// @todo Completare l'aggiornamento dello stato.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n \t}\n \treturn true;\n }\n@@ -912,9 +924,26 @@ bool aggiorna_cow(vaddr v)\n  */\n void distruggi_cow()\n {\n-//// @todo Realizzare la funzione.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\ttab_entry* root = ptr_cast<tab_entry>(esecuzione->cr3);\n+\tfor (natq i = 0; i < N_UTN_W; i++) {\n+\t\ttab_entry e = root[I_UTN_W + i];\n+\t\tif (!(e & BIT_P))\n+\t\t\tcontinue;\n+\t\tpaddr l3 = extr_IND_FISICO(e);\n+\t\troot[I_UTN_W + i] = 0;\n+\t\tdec_ref(esecuzione->cr3);\n+\t\tif (--vdf[l3 / DIM_PAGINA].nshared == 0) {\n+\t\t\tset_des(l3, 0, 512, 0);\n+\t\t\tunmap(l3, 0, dim_region(MAX_LIV - 1),\n+\t\t\t\t[](vaddr, paddr f, int liv) {\n+\t\t\t\t\tif (liv == 0)\n+\t\t\t\t\t\trilascia_frame(f);\n+\t\t\t\t\telse\n+\t\t\t\t\t\trilascia_tab(f);\n+\t\t\t\t});\n+\t\t\trilascia_tab(l3);\n+\t\t}\n+\t}\n }\n //   ESAME 2023-09-13 )\n \n",
        "output": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 5: OK",
          "TEST 3 PROC 5: OK",
          "TEST 4 PROC 5: OK",
          "TEST 5 PROC 14: ERRORE: generati 0 page fault invece di 1",
          "TEST 5 PROC 15: ERRORE: letto 79 invece di 78",
          "TEST 6 PROC 16: ERRORE: generati 0 page fault invece di 1",
          "TEST 6 PROC 17: ERRORE: letto 59 invece di 58"
        ],
        "expected": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 5: OK",
          "TEST 3 PROC 5: OK",
          "TEST 4 PROC 5: OK",
          "TEST 5 PROC 5: OK",
          "TEST 6 PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   7286 memsize   7286\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   31dc memsize   31dc\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=124590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   7286 byte da   10c000 a   200000\nINF\t-\t- copiati   31dc byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 2060ab\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 541 (M1) 995 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 460 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004248, 0xffff800000104248)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:246](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000003000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000002000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000001000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: lettura di un byte ereditato\nINF\t5\tproc=10 entry=t03p0b(unsigned long) [utente.cpp:126](3) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nWRN\t10\tEccezione 14 (page fault), errore 7, RIP t03p0b(unsigned long) [utente.cpp:128 (discriminator 1)]\nWRN\t10\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t10\t  dettagli: protezione, scrittura, da utente, \nINF\t10\tproc=11 entry=t03p1b(unsigned long) [utente.cpp:118](3) prio=300 liv=3\nINF\t10\tProcesso 10 terminato\nUSR\t5\tTEST 3 PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: scrittura dopo la copia\nINF\t5\tproc=12 entry=t04p0b(unsigned long) [utente.cpp:155](4) prio=595 liv=3\nINF\t12\tproc=13 entry=t04p1b(unsigned long) [utente.cpp:146](4) prio=299 liv=3\nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t04p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nINF\t11\tProcesso 11 terminato\nWRN\t13\tEccezione 14 (page fault), errore 7, RIP t04p1b(unsigned long) [utente.cpp:148 (discriminator 1)]\nWRN\t13\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t13\t  dettagli: protezione, scrittura, da utente, \nINF\t12\tProcesso 12 terminato\nUSR\t5\tTEST 4 PROC 5: OK\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: scrittura prima e dopo la copia\nINF\t5\tproc=14 entry=t05p0b(unsigned long) [utente.cpp:184](5) prio=594 liv=3\nWRN\t14\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:186 (discriminator 1)]\nWRN\t14\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t14\t  dettagli: protezione, scrittura, da utente, \nINF\t14\tproc=15 entry=t05p1b(unsigned long) [utente.cpp:175](5) prio=298 liv=3\nUSR\t14\tTEST 5 PROC 14: ERRORE: generati 0 page fault invece di 1\nINF\t14\tProcesso 14 terminato\nINF\t13\tProcesso 13 terminato\nUSR\t15\tTEST 5 PROC 15: ERRORE: letto 79 invece di 78\nDBG\t5\tTEST 5: === FINE ===\nDBG\t5\tTEST 6: >>>INIZIO<<<: copia della copia\nINF\t5\tproc=16 entry=t06p0b(unsigned long) [utente.cpp:229](6) prio=593 liv=3\nWRN\t16\tEccezione 14 (page fault), errore 7, RIP t06p0b(unsigned long) [utente.cpp:231 (discriminator 1)]\nWRN\t16\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t16\t  dettagli: protezione, scrittura, da utente, \nINF\t16\tproc=17 entry=t06p1b(unsigned long) [utente.cpp:216](6) prio=297 liv=3\nUSR\t16\tTEST 6 PROC 16: ERRORE: generati 0 page fault invece di 1\nINF\t16\tProcesso 16 terminato\nINF\t15\tProcesso 15 terminato\nUSR\t17\tTEST 6 PROC 17: ERRORE: letto 59 invece di 58\nINF\t17\tProcesso 17 terminato\nqemu-system-x86_64: terminating on signal 15 from pid 4891 (timeout)\n",
        "agent_output": "",
        "duration_seconds": null
      }
    },
    "minimax-m2.5-openrouter": {
      "2023-01-11_08": {
        "passed": false,
        "error": null,
        "diff": "",
        "output": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 7: ERRORE: blocco 53, byte 0: letto  invece di D",
          "TEST 3 PROC 8: ERRORE: blocco 53, byte 0: letto  invece di D",
          "TEST 4 PROC 9: ERRORE: la bufcache contiene 0 blocchi invece di 1",
          "TEST 5 PROC 10: ERRORE: la bufcache contiene 0 blocchi invece di 4",
          "TEST 6 PROC 11: ERRORE: la bufcache contiene 0 blocchi invece di 4",
          "TEST 7 PROC 12: ERRORE: la bufcache contiene 0 blocchi invece di 4",
          "Premere un tasto per continuare"
        ],
        "expected": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 5: OK",
          "TEST 3 PROC 5: OK",
          "TEST 4 PROC 5: OK",
          "TEST 5 PROC 5: OK",
          "TEST 6 PROC 5: OK",
          "TEST 7 PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=116b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   67a2 memsize   67a2\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   2ef4 memsize   2ef4\nINF\t-\t  . seg[3]: off   a000 vaddr           20a000 size    180 memsize  17404\nINF\t-\t- mod[1]: start=117000 end=11d578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3cf1 memsize   3cf1\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   1a2c memsize   1a2c\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    a60\nINF\t-\t- mod[2]: start=11e000 end=122580 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   279c memsize   279c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    ecc memsize    ecc\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    190 memsize   2890\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   67a2 byte da   10c000 a   200000\nINF\t-\t- copiati   2ef4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   116000 a   20a000\nINF\t-\t- azzerati ulteriori 17284 byte\nINF\t-\t- entry point 2055c7\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 546 (M1) 7646 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000007000)\nINF\t0\t - heap:                                 [ffff800000007000, ffff800000107000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:661](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000006890, 0xffff800000106890)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:299](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: funzionalita' minima\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:49](1) prio=600 liv=3\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: lettura\nINF\t5\tproc=7 entry=t02p0b(unsigned long) [utente.cpp:76](2) prio=599 liv=3\nINF\t6\tProcesso 6 terminato\nUSR\t7\tTEST 2 PROC 7: ERRORE: blocco 53, byte 0: letto  invece di D\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: lettura da cache\nINF\t5\tproc=8 entry=t03p0b(unsigned long) [utente.cpp:104](3) prio=598 liv=3\nINF\t7\tProcesso 7 terminato\nUSR\t8\tTEST 3 PROC 8: ERRORE: blocco 53, byte 0: letto  invece di D\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: lettura da cache\nINF\t5\tproc=9 entry=t04p0b(unsigned long) [utente.cpp:138](4) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nUSR\t9\tTEST 4 PROC 9: ERRORE: la bufcache contiene 0 blocchi invece di 1\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: riempimento cache\nINF\t5\tproc=10 entry=t05p0b(unsigned long) [utente.cpp:187](5) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nUSR\t10\tTEST 5 PROC 10: ERRORE: la bufcache contiene 0 blocchi invece di 4\nDBG\t5\tTEST 5: === FINE ===\nDBG\t5\tTEST 6: >>>INIZIO<<<: rimpiazzamento\nINF\t5\tproc=11 entry=t06p0b(unsigned long) [utente.cpp:222](6) prio=595 liv=3\nINF\t10\tProcesso 10 terminato\nUSR\t11\tTEST 6 PROC 11: ERRORE: la bufcache contiene 0 blocchi invece di 4\nDBG\t5\tTEST 6: === FINE ===\nDBG\t5\tTEST 7: >>>INIZIO<<<: rimpiazzamento dopo scrittura\nINF\t5\tproc=12 entry=t07p0b(unsigned long) [utente.cpp:258](7) prio=594 liv=3\nINF\t11\tProcesso 11 terminato\nUSR\t12\tTEST 7 PROC 12: ERRORE: la bufcache contiene 0 blocchi invece di 4\nDBG\t5\tTEST 7: === FINE ===\nUSR\t5\tPremere un tasto per continuare\nINF\t5\tProcesso 5 terminato\nINF\t12\tProcesso 12 terminato\nINF\t0\tShutdown\n",
        "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 95 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"ESAME|SOLUZIONE\"\u001b[90m 34 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/io.h\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\n\u001b[0m\u2731 \u001b[0mGrep \"DIM_BLOCK\"\u001b[90m 39 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#define DIM_BLOCK\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"DIM_BLOCK\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"DIM_BLOCK\"\u001b[90m 39 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/lib.h\n\u001b[0m\u2192 \u001b[0mRead utente/all.h\n\u001b[0m\u2731 \u001b[0mGrep \"#define.*DIM_BLOCK\"\u001b[90m 0 matches\u001b[0m\n",
        "duration_seconds": 381.79
      },
      "2023-06-07_08": {
        "passed": false,
        "error": null,
        "diff": "",
        "output": [],
        "expected": [
          "TEST 1: PROC 5: OK",
          "TEST 2: PROC 5: OK",
          "TEST 3: PROC 5: OK",
          "TEST 4: PROC 5: OK",
          "TEST 5: PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=116b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   678e memsize   678e\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   2ddc memsize   2ddc\nINF\t-\t  . seg[3]: off   a000 vaddr           20a000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=117000 end=11d578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11e000 end=122520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   678e byte da   10c000 a   200000\nINF\t-\t- copiati   2ddc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   116000 a   20a000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 2055b3\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 546 (M1) 7646 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nWRN\t0\tEccezione 6 (codice operativo non valido), errore 0, RIP crea_cow_condivisa() [sistema.cpp:829]\nERR\t0\tPANIC: ERRORE DI SISTEMA\nERR\t0\t  processi: 0\nERR\t0\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t0\tcorpo main [sistema.cpp:1538](0), livello SISTEMA, precedenza 0\nERR\t0\t  RIP=panic [sistema.cpp:1862] CPL=LIV_SISTEMA\nERR\t0\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t0\t  RAX=               a RBX=               0 RCX=               0 RDX=          2203f8\nERR\t0\t  RDI=               3 RSI=             3f8 RBP=          2211b8 RSP=          2211b0\nERR\t0\t  R8 =              30 R9 =          220fd7 R10=               0 R11=               0\nERR\t0\t  R12=               6 R13=          200838 R14=               0 R15=               0\nERR\t0\t  backtrace:\nERR\t0\t  > gestore_eccezioni [sistema.cpp:474]\nERR\t0\t  > exc_inv_opcode [sistema.s:651]\nERR\t0\t  > crea_cow_condivisa() [sistema.cpp:829]\nERR\t0\t  > main [sistema.cpp:1610]\nERR\t0\t  > _start [start64.s:33]\nERR\t0\t---------------------------------- ALTRI PROCESSI -----------------------------------\n",
        "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 93 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"SOLUZIONE\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=820]\u001b[0m\nLet me also check the beginning of the file and the constants to understand the data structures:\n\u001b[0m\u2731 \u001b[0mGrep \"cow_root|ini_utn_w|fin_utn_w|DIM_USR_COW|I_UTN_W|N_UTN_W\"\u001b[90m 33 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=655]\u001b[0m\nLet me look for the functions used for memory allocation and page table manipulation:\n\u001b[0m\u2731 \u001b[0mGrep \"void set_des|void map|alloca_frame|rilascia_frame|copy_des\"\u001b[90m 15 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"void copy_des|tab_iter|BIT_RW|BIT_P\"\u001b[90m 12 matches\u001b[0m\nLet me search for more information about the page table manipulation and the page fault handler:\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\\(\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=1]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=100]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"^void copy_des|^static void copy_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/lib*.h\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"void copy_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/boot.cpp\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"boot*\"\u001b[90m 0 matches\u001b[0m\nLet me search more specifically:\n\u001b[0m\u2731 \u001b[0mGrep \"paddr cow_root\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=775]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=100, offset=1]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/sys.h\u001b[90m [limit=200]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"aggiorna_cow_privata\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=450]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"class tab_iter|tab_iter::\"\u001b[90m 1 match\u001b[0m\nLet me look at how similar areas are created:\n\u001b[0m\u2731 \u001b[0mGrep \"crea_.*_condivisa\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=80, offset=1600]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"carica_modulo\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=1775]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"bool map\\(|paddr map\"\u001b[90m 0 matches\u001b[0m\nLet me look at the constants to understand the available bits:\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=150]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=100, offset=150]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.h\"\u001b[90m 6 matches\u001b[0m\nLet me check the sistema.s file:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.s\u001b[90m [limit=50]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1 | head -50\n[compile] ==> Compilo  sistema/sistema.cpp\nsistema/sistema.cpp: In function 'bool crea_cow_condivisa()':\nsistema/sistema.cpp:833:1: warning: no return statement in function returning non-void [-Wreturn-type]\n  833 | }\n      | ^\nsistema/sistema.cpp: In function 'bool aggiorna_cow_privata(vaddr)':\nsistema/sistema.cpp:853:1: warning: no return statement in function returning non-void [-Wreturn-type]\n  853 | }\n      | ^\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s ./boot 2>&1 | tail -30\ntimeout: failed to run command './boot': Permission denied\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead Makefile\u001b[90m [limit=50]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"^boot:\"\u001b[90m 0 matches\u001b[0m\nLet me look at the README:\n\u001b[0m\u2192 \u001b[0mRead README.md\n\u001b[0m\u2731 \u001b[0mGlob \"boot*\"\u001b[90m 0 matches\u001b[0m\nLet me check if there's a boot script:\nLet me look at conf files:\n\u001b[0m\u2731 \u001b[0mGlob \"conf/*\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead conf/conf.sh\n\u001b[0m\u2192 \u001b[0mRead conf/nucleo.py\nResolving dependencies\nResolved, downloaded and extracted [6]\nSaved lockfile\n\u001b[0m\u2731 \u001b[0mGrep \"run|qemu\"\u001b[90m 3 matches\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /work/es2/nucleo/boot/\ntotal 92\ndrwxr-xr-x. 1 vscode vscode    42 Feb 14 14:11 .\ndrwxr-xr-x. 1 vscode vscode   228 Feb 14 14:07 ..\n-rwxr-xr-x. 1 vscode vscode 43840 Feb 14 14:10 0-sistema\n-rwxr-xr-x. 1 vscode vscode 25976 Feb 14 14:10 1-io\n-rwxr-xr-x. 1 vscode vscode 17696 Feb 14 14:11 2-utente\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead Makefile\u001b[90m [limit=100, offset=100]\u001b[0m\nLet me check the full Makefile:\n\u001b[0m\u2192 \u001b[0mRead NOTE\n\u001b[0m\n\u001b[0m$ \u001b[0mwhich boot || (cd /work/es2/nucleo && ls -la) | head -20\n/home/vscode/CE/bin/boot\n\u001b[0m\n\u001b[93m\u001b[1m! \u001b[0mpermission requested: external_directory (/home/vscode/CE/bin/*); auto-rejecting\n",
        "duration_seconds": 283.15
      },
      "2023-09-13_08": {
        "passed": false,
        "error": null,
        "diff": "",
        "output": [],
        "expected": [
          "TEST 1 PROC 5: OK",
          "TEST 2 PROC 5: OK",
          "TEST 3 PROC 5: OK",
          "TEST 4 PROC 5: OK",
          "TEST 5 PROC 5: OK",
          "TEST 6 PROC 5: OK",
          "Premere un tasto per continuare"
        ],
        "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6ebe memsize   6ebe\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   3124 memsize   3124\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6ebe byte da   10c000 a   200000\nINF\t-\t- copiati   3124 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205ce3\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 540 (M1) 996 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 461 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004248, 0xffff800000104248)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:246](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000003000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000002000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nWRN\t8\tEccezione 14 (page fault), errore 4, RIP t01p0b(unsigned long) [utente.cpp:86 (discriminator 1)]\nWRN\t8\t  indirizzo virtuale: ffffc00000001000 \nWRN\t8\t  dettagli: pag o tab assente, lettura, da utente, \nERR\t8\tPANIC: indirizzo cow ffffc00000001000 non mappato\nERR\t8\t  processi: 2\nERR\t8\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t8\tcorpo t01p0b(unsigned long) [utente.cpp:85](1), livello UTENTE, precedenza 598\nERR\t8\t  RIP=panic [sistema.cpp:1885] CPL=LIV_SISTEMA\nERR\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t8\t  RAX=               a RBX=      fffffffa90 RCX=               0 RDX=      ffffff03f8\nERR\t8\t  RDI=               3 RSI=             3f8 RBP=      fffffffa78 RSP=      fffffffa70\nERR\t8\t  R8 =              38 R9 =      fffffff897 R10=               0 R11=               0\nERR\t8\t  R12=               e R13=ffffc00000001000 R14=               0 R15=               0\nERR\t8\t  backtrace:\nERR\t8\t  > fpanic(char const*, ...) [fpanic.cpp:13]\nERR\t8\t  > aggiorna_cow(unsigned long) [sistema.cpp:883]\nERR\t8\t  > gestore_eccezioni [sistema.cpp:472]\nERR\t8\t  > exc_page_fault [sistema.s:812]\nERR\t8\t  > t01p0b(unsigned long) [utente.cpp:86 (discriminator 1)]\nERR\t8\t  > 0xaaaaaaaaaaaaaaa9\nERR\t8\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t8\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1552](0), livello SISTEMA, precedenza 0\nERR\t8\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t8\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t8\t  RAX=          202b04 RBX=            13a0 RCX=               0 RDX=          2103f8\nERR\t8\t  RDI=            13a0 RSI=          21ba30 RBP=          21bb00 RSP=          21ba20\nERR\t8\t  R8 =              30 R9 =          21b85f R10=               0 R11=               0\nERR\t8\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t8\t  backtrace:\n",
        "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 93 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"SOLUZIONE|ESAME\"\u001b[90m 42 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=150, offset=860]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=385]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=150, offset=550]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=810]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/sys.h\u001b[90m [limit=100, offset=90]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=150, offset=20]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"des_frame|nshared\"\u001b[90m 5 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=490]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des|inc_ref|dec_ref|set_des\"\u001b[90m 9 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=720]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"void copy_des|void set_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"include/**/*.h\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/vm.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=1]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead Makefile\u001b[90m [limit=100]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /work/es2/nucleo/\ntotal 156\ndrwxr-xr-x. 1 vscode vscode    228 Feb 14 14:12 .\ndrwxr-xr-x. 1 vscode vscode     12 Feb 23  2025 ..\ndrwxr-xr-x. 1 vscode vscode    144 Feb 14 14:12 .git\n-rw-r--r--. 1 vscode vscode    161 Feb 14 14:12 .gitignore\ndrwxr-xr-x. 1 vscode vscode     42 Feb 23  2025 .vscode\n-rw-r--r--. 1 vscode vscode 119401 Mar 24  2025 Doxyfile\n-rw-r--r--. 1 vscode vscode  10354 Mar 24  2025 Makefile\n-rw-r--r--. 1 vscode vscode     73 Mar 24  2025 NOTE\n-rw-r--r--. 1 vscode vscode     66 Mar 24  2025 README.md\ndrwxr-xr-x. 1 vscode vscode      0 Feb 23  2025 boot\ndrwxr-xr-x. 1 vscode vscode     66 Feb 23  2025 conf\ndrwxr-xr-x. 1 vscode vscode     42 Feb 23  2025 debug\ndrwxr-xr-x. 1 vscode vscode     52 Feb 23  2025 include\ndrwxr-xr-x. 1 vscode vscode     20 Feb 23  2025 io\n-rw-r--r--. 1 vscode vscode    158 Feb 14 14:12 opencode.json\n-rw-r--r--. 1 vscode vscode   4829 Mar 24  2025 question.dox\ndrwxr-xr-x. 1 vscode vscode     40 Feb 23  2025 sistema\ndrwxr-xr-x. 1 vscode vscode     86 Feb 23  2025 utente\ndrwxr-xr-x. 1 vscode vscode    140 Mar 24  2025 util\n\u001b[0m\n\u001b[0m$ \u001b[0mwhich compile 2>/dev/null || echo \"compile not in PATH\"\n/home/vscode/CE/bin/compile\n\u001b[0m\n\u001b[93m\u001b[1m! \u001b[0mpermission requested: external_directory (/home/vscode/CE/etc/*); auto-rejecting\n",
        "duration_seconds": 135.76
      }
    }
  }
}