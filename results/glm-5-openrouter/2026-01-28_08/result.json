{
  "passed": true,
  "output": [
    "TEST 1 PROC 5: OK",
    "TEST 2 PROC 5: OK",
    "TEST 3 PROC 5: OK",
    "Premere un tasto per continuare"
  ],
  "expected": [
    "TEST 1 PROC 5: OK",
    "TEST 2 PROC 5: OK",
    "TEST 3 PROC 5: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f46 memsize   6f46\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  183c4\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123570 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2a4c memsize   2a4c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    e54 memsize    e54\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    180 memsize    200\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f46 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 18244 byte\nINF\t-\t- entry point 205d6b\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004200, 0xffff800000104200)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:306](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: writer prima dei lettori nuovi\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:79](1) prio=600 liv=3\nINF\t5\tproc=7 entry=t01p1b(unsigned long) [utente.cpp:95](1) prio=599 liv=3\nINF\t5\tproc=8 entry=t01p2b(unsigned long) [utente.cpp:113](1) prio=598 liv=3\nINF\t5\tproc=9 entry=t01p3b(unsigned long) [utente.cpp:129](1) prio=597 liv=3\nDBG\t6\tTEST 1: R0 dentro\nDBG\t7\tTEST 1: W1 prova WRITE (attesa)\nDBG\t8\tTEST 1: R1 prova READ (attesa)\nDBG\t9\tTEST 1: R2 prova READ (attesa)\nDBG\t6\tTEST 1: R0 esce\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 1: W1 dentro\nDBG\t7\tTEST 1: W1 esce\nINF\t7\tProcesso 7 terminato\nDBG\t8\tTEST 1: R1 dentro/esce\nINF\t8\tProcesso 8 terminato\nDBG\t9\tTEST 1: R2 dentro/esce\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: alternanza W1->batch lettori->W2\nINF\t5\tproc=10 entry=t02p0b(unsigned long) [utente.cpp:163](2) prio=596 liv=3\nINF\t5\tproc=11 entry=t02p1b(unsigned long) [utente.cpp:180](2) prio=595 liv=3\nINF\t5\tproc=12 entry=t02p2b(unsigned long) [utente.cpp:195](2) prio=594 liv=3\nINF\t5\tproc=13 entry=t02p3b(unsigned long) [utente.cpp:211](2) prio=593 liv=3\nINF\t9\tProcesso 9 terminato\nDBG\t10\tTEST 2: W1 prova WRITE\nDBG\t10\tTEST 2: W1 dentro\nDBG\t11\tTEST 2: R1 prova READ (attesa)\nDBG\t12\tTEST 2: R2 prova READ (attesa)\nDBG\t13\tTEST 2: W2 prova WRITE (attesa)\nDBG\t10\tTEST 2: W1 esce\nINF\t10\tProcesso 10 terminato\nDBG\t11\tTEST 2: R1 dentro\nDBG\t12\tTEST 2: R2 dentro\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nDBG\t13\tTEST 2: W2 dentro/esce\nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: i lettori devono aspettare se si raggiunge MAX_RW_READERS\nINF\t5\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:249](3) prio=592 liv=3\nINF\t5\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:275](3) prio=591 liv=3\nINF\t5\tproc=16 entry=t03p2b(unsigned long) [utente.cpp:276](3) prio=590 liv=3\nINF\t5\tproc=17 entry=t03p3b(unsigned long) [utente.cpp:277](3) prio=589 liv=3\nINF\t5\tproc=18 entry=t03p4b(unsigned long) [utente.cpp:279](3) prio=588 liv=3\nINF\t13\tProcesso 13 terminato\nDBG\t14\tTEST 3: R0 dentro\nDBG\t15\tTEST 3: R1 dentro\nDBG\t16\tTEST 3: R2 dentro\nDBG\t17\tTEST 3: R3 dentro\nDBG\t18\tTEST 3: R4 inizio\nDBG\t14\tTEST 3: R0 esce\nINF\t14\tProcesso 14 terminato\nDBG\t18\tTEST 3: R4 dentro\nINF\t18\tProcesso 18 terminato\nINF\t15\tProcesso 15 terminato\nINF\t16\tProcesso 16 terminato\nUSR\t5\tTEST 3 PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nUSR\t5\tPremere un tasto per continuare\nINF\t5\tProcesso 5 terminato\nINF\t17\tProcesso 17 terminato\nINF\t0\tShutdown\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 z-ai/glm-5:nitro\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.cpp\"\u001b[90m 10 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.h\"\u001b[90m 6 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.S\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"ESAME\"\u001b[90m 14 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"SOLUZIONE\"\u001b[90m 10 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=200, offset=1830]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.s\u001b[90m [limit=250, offset=240]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.s\u001b[90m [limit=100, offset=140]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=50, offset=25]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/sys.h\u001b[90m [limit=80, offset=120]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"c_sem_wait|c_sem_signal\"\u001b[90m 2 matches\u001b[0m\nLet me look at the costanti.h file and check how similar primitives like semaphores are implemented:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=235]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inserimento_lista|rimozione_lista|inspronti\"\u001b[90m 13 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=65]\u001b[0m\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[ ] Implement rw_acq_write in sistema.cpp\n[ ] Implement rw_acq_read in sistema.cpp\n[ ] Implement rw_rel_write in sistema.cpp\n[ ] Implement rw_rel_read in sistema.cpp\n[ ] Build and test with timeout 10s boot\n\u001b[0m\nNow I understand the problem. Let me implement the RW primitives. I'll create a todo list to track progress:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=1935]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -1940,8 +1940,14 @@\n \t\treturn;\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tif (p->writer != 0 || p->nreaders > 0) {\n+\t\tinserimento_lista(p->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\tp->writer = esecuzione->id;\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n \n /// Parte C++ della primitiva rw_acq_read()\n\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement rw_acq_write in sistema.cpp\n[ ] Implement rw_acq_read in sistema.cpp\n[ ] Implement rw_rel_write in sistema.cpp\n[ ] Implement rw_rel_read in sistema.cpp\n[ ] Build and test with timeout 10s boot\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=1955]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -1968,8 +1968,16 @@\n \t\treturn;\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tif (p->writer != 0 || p->nreaders >= MAX_RW_READERS || p->w_writers != nullptr) {\n+\t\tinserimento_lista(p->w_readers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\tnatl pos = rw_find_reader(p, 0);\n+\t\tp->readers[pos] = esecuzione->id;\n+\t\tp->nreaders++;\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n \n // ( SOLUZIONE 2026-01-28\n\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement rw_acq_write in sistema.cpp\n[x] Implement rw_acq_read in sistema.cpp\n[ ] Implement rw_rel_write in sistema.cpp\n[ ] Implement rw_rel_read in sistema.cpp\n[ ] Build and test with timeout 10s boot\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=1977]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2001,8 +2001,24 @@\n \t\treturn;\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tp->writer = 0;\n+\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\tnatl pos = rw_find_reader(p, 0);\n+\t\tp->readers[pos] = proc->id;\n+\t\tp->nreaders++;\n+\t\tinspronti();\n+\t\tinserimento_lista(pronti, proc);\n+\t}\n+\tif (p->nreaders == 0 && p->w_writers != nullptr) {\n+\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\tp->writer = proc->id;\n+\t\tinspronti();\n+\t\tinserimento_lista(pronti, proc);\n+\t}\n+\tschedulatore();\n //   SOLUZIONE 2026-01-28 )\n }\n \n /// Parte C++ della primitiva rw_rel_read()\n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=2015]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2039,8 +2039,28 @@\n \t\treturn;\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tp->readers[pos] = 0;\n+\tp->nreaders--;\n+\tif (p->nreaders == 0) {\n+\t\tif (p->w_writers != nullptr) {\n+\t\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\t\tp->writer = proc->id;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, proc);\n+\t\t} else {\n+\t\t\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\t\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\t\t\tnatl free_pos = rw_find_reader(p, 0);\n+\t\t\t\tp->readers[free_pos] = proc->id;\n+\t\t\t\tp->nreaders++;\n+\t\t\t\tinspronti();\n+\t\t\t\tinserimento_lista(pronti, proc);\n+\t\t\t}\n+\t\t}\n+\t\tschedulatore();\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n // ESAME 2026-01-28 )\n \n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=15, offset=1980]\u001b[0m\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement rw_acq_write in sistema.cpp\n[x] Implement rw_acq_read in sistema.cpp\n[x] Implement rw_rel_write in sistema.cpp\n[x] Implement rw_rel_read in sistema.cpp\n[ ] Build and test with timeout 10s boot\n\u001b[0m\n\u001b[0m$ \u001b[0mmake 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m$ \u001b[0mtimeout 10s boot 2>&1 | tee boot_output.log\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f30 memsize   6f30\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  183c4\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123570 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2a4c memsize   2a4c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    e54 memsize    e54\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    180 memsize    200\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f30 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 18244 byte\nINF\t-\t- entry point 205d55\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004200, 0xffff800000104200)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:306](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: writer prima dei lettori nuovi\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:79](1) prio=600 liv=3\nINF\t5\tproc=7 entry=t01p1b(unsigned long) [utente.cpp:95](1) prio=599 liv=3\nINF\t5\tproc=8 entry=t01p2b(unsigned long) [utente.cpp:113](1) prio=598 liv=3\nINF\t5\tproc=9 entry=t01p3b(unsigned long) [utente.cpp:129](1) prio=597 liv=3\nDBG\t6\tTEST 1: R0 dentro\nDBG\t7\tTEST 1: W1 prova WRITE (attesa)\nDBG\t8\tTEST 1: R1 prova READ (attesa)\nDBG\t9\tTEST 1: R2 prova READ (attesa)\nDBG\t6\tTEST 1: R0 esce\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 1: W1 dentro\nDBG\t7\tTEST 1: W1 esce\nqemu-system-x86_64: terminating on signal 15 from pid 569 (timeout)\n\u001b[0m\nThe test seems to be working. Let me check if there's an issue with the empty SOLUZIONE block and see the full test:\n\u001b[0m$ \u001b[0mtimeout 30s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f30 memsize   6f30\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  183c4\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123570 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2a4c memsize   2a4c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    e54 memsize    e54\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    180 memsize    200\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f30 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 18244 byte\nINF\t-\t- entry point 205d55\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004200, 0xffff800000104200)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:306](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: writer prima dei lettori nuovi\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:79](1) prio=600 liv=3\nINF\t5\tproc=7 entry=t01p1b(unsigned long) [utente.cpp:95](1) prio=599 liv=3\nINF\t5\tproc=8 entry=t01p2b(unsigned long) [utente.cpp:113](1) prio=598 liv=3\nINF\t5\tproc=9 entry=t01p3b(unsigned long) [utente.cpp:129](1) prio=597 liv=3\nDBG\t6\tTEST 1: R0 dentro\nDBG\t7\tTEST 1: W1 prova WRITE (attesa)\nDBG\t8\tTEST 1: R1 prova READ (attesa)\nDBG\t9\tTEST 1: R2 prova READ (attesa)\nDBG\t6\tTEST 1: R0 esce\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 1: W1 dentro\nDBG\t7\tTEST 1: W1 esce\nqemu-system-x86_64: terminating on signal 15 from pid 635 (timeout)\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=100, offset=75]\u001b[0m\nLet me check the test code to understand what's expected:\n\u001b[0m\u2731 \u001b[0mGrep \"end_test|testok\"\u001b[90m 40 matches\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mtimeout 60s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f30 memsize   6f30\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  183c4\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123570 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2a4c memsize   2a4c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    e54 memsize    e54\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    180 memsize    200\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f30 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 18244 byte\nINF\t-\t- entry point 205d55\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004200, 0xffff800000104200)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:306](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: writer prima dei lettori nuovi\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:79](1) prio=600 liv=3\nINF\t5\tproc=7 entry=t01p1b(unsigned long) [utente.cpp:95](1) prio=599 liv=3\nINF\t5\tproc=8 entry=t01p2b(unsigned long) [utente.cpp:113](1) prio=598 liv=3\nINF\t5\tproc=9 entry=t01p3b(unsigned long) [utente.cpp:129](1) prio=597 liv=3\nDBG\t6\tTEST 1: R0 dentro\nDBG\t7\tTEST 1: W1 prova WRITE (attesa)\nDBG\t8\tTEST 1: R1 prova READ (attesa)\nDBG\t9\tTEST 1: R2 prova READ (attesa)\nDBG\t6\tTEST 1: R0 esce\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 1: W1 dentro\nDBG\t7\tTEST 1: W1 esce\nqemu-system-x86_64: terminating on signal 15 from pid 752 (timeout)\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=118]\u001b[0m\nI found the bug! Calling `inspronti()` multiple times in a loop creates a cycle in the ready list. I need to call it only once before the loop:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=2000]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2002,20 +2002,19 @@\n \t}\n \n // ( SOLUZIONE 2026-01-28\n \tp->writer = 0;\n+\tinspronti();\n \twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n \t\tdes_proc* proc = rimozione_lista(p->w_readers);\n \t\tnatl pos = rw_find_reader(p, 0);\n \t\tp->readers[pos] = proc->id;\n \t\tp->nreaders++;\n-\t\tinspronti();\n \t\tinserimento_lista(pronti, proc);\n \t}\n \tif (p->nreaders == 0 && p->w_writers != nullptr) {\n \t\tdes_proc* proc = rimozione_lista(p->w_writers);\n \t\tp->writer = proc->id;\n-\t\tinspronti();\n \t\tinserimento_lista(pronti, proc);\n \t}\n \tschedulatore();\n //   SOLUZIONE 2026-01-28 )\n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=2038]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2041,20 +2041,19 @@\n // ( SOLUZIONE 2026-01-28\n \tp->readers[pos] = 0;\n \tp->nreaders--;\n \tif (p->nreaders == 0) {\n+\t\tinspronti();\n \t\tif (p->w_writers != nullptr) {\n \t\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n \t\t\tp->writer = proc->id;\n-\t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, proc);\n \t\t} else {\n \t\t\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n \t\t\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n \t\t\t\tnatl free_pos = rw_find_reader(p, 0);\n \t\t\t\tp->readers[free_pos] = proc->id;\n \t\t\t\tp->nreaders++;\n-\t\t\t\tinspronti();\n \t\t\t\tinserimento_lista(pronti, proc);\n \t\t\t}\n \t\t}\n \t\tschedulatore();\n\n\u001b[0m\n\u001b[0m$ \u001b[0mmake 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mtimeout 60s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f12 memsize   6f12\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  183c4\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123570 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2a4c memsize   2a4c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    e54 memsize    e54\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    180 memsize    200\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f12 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 18244 byte\nINF\t-\t- entry point 205d37\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004200, 0xffff800000104200)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:306](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: writer prima dei lettori nuovi\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:79](1) prio=600 liv=3\nINF\t5\tproc=7 entry=t01p1b(unsigned long) [utente.cpp:95](1) prio=599 liv=3\nINF\t5\tproc=8 entry=t01p2b(unsigned long) [utente.cpp:113](1) prio=598 liv=3\nINF\t5\tproc=9 entry=t01p3b(unsigned long) [utente.cpp:129](1) prio=597 liv=3\nDBG\t6\tTEST 1: R0 dentro\nDBG\t7\tTEST 1: W1 prova WRITE (attesa)\nDBG\t8\tTEST 1: R1 prova READ (attesa)\nDBG\t9\tTEST 1: R2 prova READ (attesa)\nDBG\t6\tTEST 1: R0 esce\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 1: W1 dentro\nDBG\t7\tTEST 1: W1 esce\nINF\t7\tProcesso 7 terminato\nDBG\t8\tTEST 1: R1 dentro/esce\nINF\t8\tProcesso 8 terminato\nDBG\t9\tTEST 1: R2 dentro/esce\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: alternanza W1->batch lettori->W2\nINF\t5\tproc=10 entry=t02p0b(unsigned long) [utente.cpp:163](2) prio=596 liv=3\nINF\t5\tproc=11 entry=t02p1b(unsigned long) [utente.cpp:180](2) prio=595 liv=3\nINF\t5\tproc=12 entry=t02p2b(unsigned long) [utente.cpp:195](2) prio=594 liv=3\nINF\t5\tproc=13 entry=t02p3b(unsigned long) [utente.cpp:211](2) prio=593 liv=3\nINF\t9\tProcesso 9 terminato\nDBG\t10\tTEST 2: W1 prova WRITE\nDBG\t10\tTEST 2: W1 dentro\nDBG\t11\tTEST 2: R1 prova READ (attesa)\nDBG\t12\tTEST 2: R2 prova READ (attesa)\nDBG\t13\tTEST 2: W2 prova WRITE (attesa)\nDBG\t10\tTEST 2: W1 esce\nINF\t10\tProcesso 10 terminato\nDBG\t11\tTEST 2: R1 dentro\nDBG\t12\tTEST 2: R2 dentro\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nDBG\t13\tTEST 2: W2 dentro/esce\nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: i lettori devono aspettare se si raggiunge MAX_RW_READERS\nINF\t5\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:249](3) prio=592 liv=3\nINF\t5\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:275](3) prio=591 liv=3\nINF\t5\tproc=16 entry=t03p2b(unsigned long) [utente.cpp:276](3) prio=590 liv=3\nINF\t5\tproc=17 entry=t03p3b(unsigned long) [utente.cpp:277](3) prio=589 liv=3\nINF\t5\tproc=18 entry=t03p4b(unsigned long) [utente.cpp:279](3) prio=588 liv=3\nINF\t13\tProcesso 13 terminato\nDBG\t14\tTEST 3: R0 dentro\nDBG\t15\tTEST 3: R1 dentro\nDBG\t16\tTEST 3: R2 dentro\nDBG\t17\tTEST 3: R3 dentro\nDBG\t18\tTEST 3: R4 inizio\nDBG\t14\tTEST 3: R0 esce\nINF\t14\tProcesso 14 terminato\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nDBG\t15\tTEST 3: waitphase: 6 != 7\nDBG\t16\tTEST 3: waitphase: 6 != 7\nDBG\t17\tTEST 3: waitphase: 6 != 7\nqemu-system-x86_64: terminating on signal 15 from pid 923 (timeout)\n\u001b[0m\nTest 1 and 2 passed! Let me check Test 3 to understand the failure:\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=60, offset=245]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=2038]\u001b[0m\nI see the issue! In Test 3, when R0 exits, nreaders goes from 4 to 3, but R4 is waiting because there's a free slot now. I need to wake waiting readers even when nreaders > 0:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2040,22 +2040,22 @@\n \n // ( SOLUZIONE 2026-01-28\n \tp->readers[pos] = 0;\n \tp->nreaders--;\n-\tif (p->nreaders == 0) {\n+\tif (p->nreaders == 0 && p->w_writers != nullptr) {\n \t\tinspronti();\n-\t\tif (p->w_writers != nullptr) {\n-\t\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n-\t\t\tp->writer = proc->id;\n+\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\tp->writer = proc->id;\n+\t\tinserimento_lista(pronti, proc);\n+\t\tschedulatore();\n+\t} else if (p->w_readers != nullptr) {\n+\t\tinspronti();\n+\t\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\t\tnatl free_pos = rw_find_reader(p, 0);\n+\t\t\tp->readers[free_pos] = proc->id;\n+\t\t\tp->nreaders++;\n \t\t\tinserimento_lista(pronti, proc);\n-\t\t} else {\n-\t\t\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n-\t\t\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n-\t\t\t\tnatl free_pos = rw_find_reader(p, 0);\n-\t\t\t\tp->readers[free_pos] = proc->id;\n-\t\t\t\tp->nreaders++;\n-\t\t\t\tinserimento_lista(pronti, proc);\n-\t\t\t}\n \t\t}\n \t\tschedulatore();\n \t}\n //   SOLUZIONE 2026-01-28 )\n\n\u001b[0m\n\u001b[0m$ \u001b[0mmake 2>&1 && timeout 60s boot 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f46 memsize   6f46\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  183c4\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123570 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2a4c memsize   2a4c\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    e54 memsize    e54\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    180 memsize    200\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f46 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 18244 byte\nINF\t-\t- entry point 205d6b\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7114 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004200, 0xffff800000104200)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:306](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 1: >>>INIZIO<<<: writer prima dei lettori nuovi\nINF\t5\tproc=6 entry=t01p0b(unsigned long) [utente.cpp:79](1) prio=600 liv=3\nINF\t5\tproc=7 entry=t01p1b(unsigned long) [utente.cpp:95](1) prio=599 liv=3\nINF\t5\tproc=8 entry=t01p2b(unsigned long) [utente.cpp:113](1) prio=598 liv=3\nINF\t5\tproc=9 entry=t01p3b(unsigned long) [utente.cpp:129](1) prio=597 liv=3\nDBG\t6\tTEST 1: R0 dentro\nDBG\t7\tTEST 1: W1 prova WRITE (attesa)\nDBG\t8\tTEST 1: R1 prova READ (attesa)\nDBG\t9\tTEST 1: R2 prova READ (attesa)\nDBG\t6\tTEST 1: R0 esce\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 1: W1 dentro\nDBG\t7\tTEST 1: W1 esce\nINF\t7\tProcesso 7 terminato\nDBG\t8\tTEST 1: R1 dentro/esce\nINF\t8\tProcesso 8 terminato\nDBG\t9\tTEST 1: R2 dentro/esce\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: alternanza W1->batch lettori->W2\nINF\t5\tproc=10 entry=t02p0b(unsigned long) [utente.cpp:163](2) prio=596 liv=3\nINF\t5\tproc=11 entry=t02p1b(unsigned long) [utente.cpp:180](2) prio=595 liv=3\nINF\t5\tproc=12 entry=t02p2b(unsigned long) [utente.cpp:195](2) prio=594 liv=3\nINF\t5\tproc=13 entry=t02p3b(unsigned long) [utente.cpp:211](2) prio=593 liv=3\nINF\t9\tProcesso 9 terminato\nDBG\t10\tTEST 2: W1 prova WRITE\nDBG\t10\tTEST 2: W1 dentro\nDBG\t11\tTEST 2: R1 prova READ (attesa)\nDBG\t12\tTEST 2: R2 prova READ (attesa)\nDBG\t13\tTEST 2: W2 prova WRITE (attesa)\nDBG\t10\tTEST 2: W1 esce\nINF\t10\tProcesso 10 terminato\nDBG\t11\tTEST 2: R1 dentro\nDBG\t12\tTEST 2: R2 dentro\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nDBG\t13\tTEST 2: W2 dentro/esce\nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: i lettori devono aspettare se si raggiunge MAX_RW_READERS\nINF\t5\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:249](3) prio=592 liv=3\nINF\t5\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:275](3) prio=591 liv=3\nINF\t5\tproc=16 entry=t03p2b(unsigned long) [utente.cpp:276](3) prio=590 liv=3\nINF\t5\tproc=17 entry=t03p3b(unsigned long) [utente.cpp:277](3) prio=589 liv=3\nINF\t5\tproc=18 entry=t03p4b(unsigned long) [utente.cpp:279](3) prio=588 liv=3\nINF\t13\tProcesso 13 terminato\nDBG\t14\tTEST 3: R0 dentro\nDBG\t15\tTEST 3: R1 dentro\nDBG\t16\tTEST 3: R2 dentro\nDBG\t17\tTEST 3: R3 dentro\nDBG\t18\tTEST 3: R4 inizio\nDBG\t14\tTEST 3: R0 esce\nINF\t14\tProcesso 14 terminato\nDBG\t18\tTEST 3: R4 dentro\nINF\t18\tProcesso 18 terminato\nINF\t15\tProcesso 15 terminato\nINF\t16\tProcesso 16 terminato\nUSR\t5\tTEST 3 PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nUSR\t5\tPremere un tasto per continuare\nINF\t5\tProcesso 5 terminato\nINF\t17\tProcesso 17 terminato\nINF\t0\tShutdown\n\u001b[0m\n\u001b[91m\u001b[1mError: \u001b[0mThis request requires more credits, or fewer max_tokens. You requested up to 32000 tokens, but can only afford 14159. To increase, visit https://openrouter.ai/settings/keys and create a key with a higher total limit\n",
  "duration_seconds": 487.14,
  "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 4e27b9e..94c5018 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -1941,6 +1941,12 @@ extern \"C\" void c_rw_acq_write(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tif (p->writer != 0 || p->nreaders > 0) {\n+\t\tinserimento_lista(p->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\tp->writer = esecuzione->id;\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n \n@@ -1963,6 +1969,14 @@ extern \"C\" void c_rw_acq_read(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tif (p->writer != 0 || p->nreaders >= MAX_RW_READERS || p->w_writers != nullptr) {\n+\t\tinserimento_lista(p->w_readers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\tnatl pos = rw_find_reader(p, 0);\n+\t\tp->readers[pos] = esecuzione->id;\n+\t\tp->nreaders++;\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n \n@@ -1988,6 +2002,21 @@ extern \"C\" void c_rw_rel_write(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tp->writer = 0;\n+\tinspronti();\n+\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\tnatl pos = rw_find_reader(p, 0);\n+\t\tp->readers[pos] = proc->id;\n+\t\tp->nreaders++;\n+\t\tinserimento_lista(pronti, proc);\n+\t}\n+\tif (p->nreaders == 0 && p->w_writers != nullptr) {\n+\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\tp->writer = proc->id;\n+\t\tinserimento_lista(pronti, proc);\n+\t}\n+\tschedulatore();\n //   SOLUZIONE 2026-01-28 )\n }\n \n@@ -2010,6 +2039,25 @@ extern \"C\" void c_rw_rel_read(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tp->readers[pos] = 0;\n+\tp->nreaders--;\n+\tif (p->nreaders == 0 && p->w_writers != nullptr) {\n+\t\tinspronti();\n+\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\tp->writer = proc->id;\n+\t\tinserimento_lista(pronti, proc);\n+\t\tschedulatore();\n+\t} else if (p->w_readers != nullptr) {\n+\t\tinspronti();\n+\t\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\t\tnatl free_pos = rw_find_reader(p, 0);\n+\t\t\tp->readers[free_pos] = proc->id;\n+\t\t\tp->nreaders++;\n+\t\t\tinserimento_lista(pronti, proc);\n+\t\t}\n+\t\tschedulatore();\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n // ESAME 2026-01-28 )\ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 4e27b9e..94c5018 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -1941,6 +1941,12 @@ extern \"C\" void c_rw_acq_write(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tif (p->writer != 0 || p->nreaders > 0) {\n+\t\tinserimento_lista(p->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\tp->writer = esecuzione->id;\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n \n@@ -1963,6 +1969,14 @@ extern \"C\" void c_rw_acq_read(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tif (p->writer != 0 || p->nreaders >= MAX_RW_READERS || p->w_writers != nullptr) {\n+\t\tinserimento_lista(p->w_readers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\tnatl pos = rw_find_reader(p, 0);\n+\t\tp->readers[pos] = esecuzione->id;\n+\t\tp->nreaders++;\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n \n@@ -1988,6 +2002,21 @@ extern \"C\" void c_rw_rel_write(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tp->writer = 0;\n+\tinspronti();\n+\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\tnatl pos = rw_find_reader(p, 0);\n+\t\tp->readers[pos] = proc->id;\n+\t\tp->nreaders++;\n+\t\tinserimento_lista(pronti, proc);\n+\t}\n+\tif (p->nreaders == 0 && p->w_writers != nullptr) {\n+\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\tp->writer = proc->id;\n+\t\tinserimento_lista(pronti, proc);\n+\t}\n+\tschedulatore();\n //   SOLUZIONE 2026-01-28 )\n }\n \n@@ -2010,6 +2039,25 @@ extern \"C\" void c_rw_rel_read(natl rw)\n \t}\n \n // ( SOLUZIONE 2026-01-28\n+\tp->readers[pos] = 0;\n+\tp->nreaders--;\n+\tif (p->nreaders == 0 && p->w_writers != nullptr) {\n+\t\tinspronti();\n+\t\tdes_proc* proc = rimozione_lista(p->w_writers);\n+\t\tp->writer = proc->id;\n+\t\tinserimento_lista(pronti, proc);\n+\t\tschedulatore();\n+\t} else if (p->w_readers != nullptr) {\n+\t\tinspronti();\n+\t\twhile (p->w_readers != nullptr && p->nreaders < MAX_RW_READERS) {\n+\t\t\tdes_proc* proc = rimozione_lista(p->w_readers);\n+\t\t\tnatl free_pos = rw_find_reader(p, 0);\n+\t\t\tp->readers[free_pos] = proc->id;\n+\t\t\tp->nreaders++;\n+\t\t\tinserimento_lista(pronti, proc);\n+\t\t}\n+\t\tschedulatore();\n+\t}\n //   SOLUZIONE 2026-01-28 )\n }\n // ESAME 2026-01-28 )\n",
  "error": null
}