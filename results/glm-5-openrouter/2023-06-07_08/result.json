{
  "passed": true,
  "output": [
    "TEST 1: PROC 5: OK",
    "TEST 2: PROC 5: OK",
    "TEST 3: PROC 5: OK",
    "TEST 4: PROC 5: OK",
    "TEST 5: PROC 5: OK",
    "Premere un tasto per continuare"
  ],
  "expected": [
    "TEST 1: PROC 5: OK",
    "TEST 2: PROC 5: OK",
    "TEST 3: PROC 5: OK",
    "TEST 4: PROC 5: OK",
    "TEST 5: PROC 5: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117a98 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6e62 memsize   6e62\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   30ac memsize   30ac\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6e62 byte da   10c000 a   200000\nINF\t-\t- copiati   30ac byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 205cc5\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 7095 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000010000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1: PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 2: PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: scrittura di un byte non allineato alla pagina\nINF\t5\tproc=10 entry=t03p0b(unsigned long) [utente.cpp:116](3) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nWRN\t10\tEccezione 14 (page fault), errore 7, RIP t03p0b(unsigned long) [utente.cpp:118 (discriminator 1)]\nWRN\t10\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t10\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 3: PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: scrittura di due byte nella stessa pagina\nINF\t5\tproc=11 entry=t04p0b(unsigned long) [utente.cpp:132](4) prio=595 liv=3\nINF\t10\tProcesso 10 terminato\nWRN\t11\tEccezione 14 (page fault), errore 7, RIP t04p0b(unsigned long) [utente.cpp:134 (discriminator 1)]\nWRN\t11\t  indirizzo virtuale: ffffc0000000f4d2 \nWRN\t11\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 4: PROC 5: OK\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: scrittura di due byte in due pagine diverse\nINF\t5\tproc=12 entry=t05p0b(unsigned long) [utente.cpp:152](5) prio=594 liv=3\nINF\t11\tProcesso 11 terminato\nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:155 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000f4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000e4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 5: PROC 5: OK\nDBG\t5\tTEST 5: === FINE ===\nINF\t12\tProcesso 12 terminato\nUSR\t5\tPremere un tasto per continuare\nINF\t5\tProcesso 5 terminato\nINF\t0\tShutdown\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 z-ai/glm-5\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.cpp\"\u001b[90m 10 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.h\"\u001b[90m 6 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [offset=1629]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/vm.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mfind /work/es2/nucleo -name \"vm.h\" 2>/dev/null\n\u001b[0m\u2731 \u001b[0mGrep \"tab_iter|tab_entry|copy_des|set_des|extr_IND_FISICO\"\u001b[90m 15 matches\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mfind /work -name \"vm.h\" 2>/dev/null\n\u001b[0m\u2731 \u001b[0mGlob \"**/libce.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /work/es2/nucleo/\ntotal 152\ndrwxr-xr-x. 1 vscode vscode    228 Feb 14 15:23 .\ndrwxr-xr-x. 1 vscode vscode     12 Feb 23  2025 ..\ndrwxr-xr-x. 1 vscode vscode    144 Feb 14 15:23 .git\n-rw-r--r--. 1 vscode vscode    161 Feb 14 15:23 .gitignore\ndrwxr-xr-x. 1 vscode vscode     42 Feb 23  2025 .vscode\n-rw-r--r--. 1 vscode vscode 119401 Mar 24  2025 Doxyfile\n-rw-r--r--. 1 vscode vscode  10354 Mar 24  2025 Makefile\n-rw-r--r--. 1 vscode vscode     73 Mar 24  2025 NOTE\n-rw-r--r--. 1 vscode vscode     66 Mar 24  2025 README.md\ndrwxr-xr-x. 1 vscode vscode      0 Feb 23  2025 boot\ndrwxr-xr-x. 1 vscode vscode     66 Feb 23  2025 conf\ndrwxr-xr-x. 1 vscode vscode     42 Feb 23  2025 debug\ndrwxr-xr-x. 1 vscode vscode     52 Feb 23  2025 include\ndrwxr-xr-x. 1 vscode vscode     20 Feb 23  2025 io\n-rw-r--r--. 1 vscode vscode    173 Feb 14 15:23 opencode.json\n-rw-r--r--. 1 vscode vscode   3236 Mar 24  2025 question.dox\ndrwxr-xr-x. 1 vscode vscode     40 Feb 23  2025 sistema\ndrwxr-xr-x. 1 vscode vscode     86 Feb 23  2025 utente\ndrwxr-xr-x. 1 vscode vscode    140 Mar 24  2025 util\n\u001b[0m\n\u001b[0m$ \u001b[0mfind /usr -name \"vm.h\" 2>/dev/null | head -5\n\u001b[0m\u2192 \u001b[0mRead Makefile\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /work/es2/nucleo/conf/\ntotal 28\ndrwxr-xr-x. 1 vscode vscode    66 Feb 23  2025 .\ndrwxr-xr-x. 1 vscode vscode   228 Feb 14 15:23 ..\n-rw-r--r--. 1 vscode vscode     7 Mar 24  2025 conf.sh\n-rw-r--r--. 1 vscode vscode   267 Mar 24  2025 const.gdb\n-rw-r--r--. 1 vscode vscode 13626 Mar 24  2025 nucleo.py\n-rw-r--r--. 1 vscode vscode    55 Mar 24  2025 start.mk\n\u001b[0m\n\u001b[0m$ \u001b[0mcat /work/es2/nucleo/conf/start.mk\nSTART_IO=0x10000000000\nSTART_UTENTE=0xffff800000000000\n\u001b[0m\n\u001b[0m$ \u001b[0mcat /work/es2/nucleo/conf/conf.sh\nMEM=32\n\u001b[0m\n\u001b[0m$ \u001b[0mwhich compile && cat \"$(which compile)\" | head -30\n/home/vscode/CE/bin/compile\n#!/bin/bash\n# Script per compilare programmi 'bare' da caricare nella macchina QEMU.\n#\n# Lo script compila, con parametri opportuni, tutti i file c++ e assembly\n# contenuti nella directory corrente.  Se non ci sono errori, genera i seguenti\n# file:\n#\n# - boot/0-a.out:\tversione pronta per il caricamento (script boot)\n# - debug/0-aout:\tversione usata dal debugger (script debug)\n#\n# Le directory boot e debug vengono create se non esistono gi\u00e0.\n#\n# Lo script accetta un argomento opzionale, che viene usato come nome del file\n# al posto di a.out; per es., se l'argomento \u00e8 hello, lo script crea i file\n# boot/0-hello e debug/0-hello.  Inoltre, se 'argomento \u00e8 il nome di una\n# directory esistente, i file sorgenti vengono cercati in quella directory,\n# invece che nella directory corrente.\n\n\n# Includiamo il file di configurazione di libce.  Il file contiene la\n# definizione delle seguenti variabili:\n#\n# - CE_CXX64:\tprogramma da usare come compilatore\n# - CE_AS64:\tprogramma da usare come assemblatore\n# - CE_LD64:\tprogramma da usare come collegatore\n# - CE_INCLUDE: directory che contiene libce.h, vm.h etc.\n# - CE_STRIP:\tprogramma da usare per rimuovere le informazioni di debug\n# - CE_LIB64:\tdirectory che contiene libce.a\n# - CE_LIB32:\tdirectory che contiene lo script per il linker\nsource /home/vscode//CE/etc/libce.conf\n\u001b[0m\n\u001b[0m$ \u001b[0mcat /home/vscode/CE/etc/libce.conf\nexport CE_BIN='/home/vscode//CE/bin'\nexport CE_LIB32='/home/vscode//CE/lib/ce'\nexport CE_LIB64='/home/vscode//CE/lib64/ce'\nexport CE_INCLUDE='/home/vscode//CE/include/ce'\nexport CE_HDSIZE='20M'\nexport CE_HDPATH='/home/vscode//CE/share/hd.img'\nexport CE_QEMU_BOOT='/home/vscode//CE/lib/ce/boot.bin'\nexport CE_QEMU_BOOT_DEBUG='/home/vscode//CE/lib/ce/boot.debug'\nexport CE_SOURCES='/dist/libce-4.3'\nexport CE_AS32='gcc -c -x assembler-with-cpp -m32'\nexport CE_AS64='gcc -c -x assembler-with-cpp'\nexport CE_CXX32='g++ -m32'\nexport CE_CXX64='g++'\nexport CE_LD32='ld -melf_i386'\nexport CE_LD64='ld'\nexport CE_AR='ar'\nexport CE_GDB='gdb -nx'\nexport CE_ADDR2LINE='addr2line'\nexport CE_NM='nm'\nexport CE_CPPFILT='c++filt'\nexport CE_STRIP='strip'\nexport CE_QEMU_AUDIO='none'\nexport CE_QEMU_DISPLAY='gtk,gl=off'\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead ../../../home/vscode/CE/include/ce/vm.h\n\u001b[0m\u2731 \u001b[0mGrep \"PF_\"\u001b[90m 0 matches\u001b[0m\nNow I understand the structure. Let me implement the solution. I need to write:\n1. `crea_cow_condivisa()` - creates the initial shared COW zone\n2. `aggiorna_cow_privata(vaddr v)` - handles page faults for COW zone by copying pages\n\u001b[0m\u2731 \u001b[0mGrep \"PF_\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"PF_RES|PF_USER\"\u001b[90m in ../../../home/vscode/CE/include/ce \u00b7 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [offset=815, limit=80]\u001b[0m\nNow let me implement the solution. First, I need to understand the exact requirements and implement the two functions.\nNow I'll implement the solution. Based on my analysis:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -828,8 +828,24 @@\n bool crea_cow_condivisa()\n {\n /// @todo creare la prima copia della zona cow\n // ( SOLUZIONE 2023-06-07\n+\tcow_root = alloca_tab();\n+\tif (!cow_root)\n+\t\treturn false;\n+\tvaddr v = map(cow_root, ini_utn_w, ini_utn_w + DIM_USR_COW, BIT_US,\n+\t\t[](vaddr) { \n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f)\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\treturn f;\n+\t\t});\n+\tif (v != ini_utn_w + DIM_USR_COW) {\n+\t\trilascia_tab(cow_root);\n+\t\tcow_root = 0;\n+\t\treturn false;\n+\t}\n+\treturn true;\n //   SOLUZIONE 2023-06-07 )\n }\n \n /**\n\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -864,8 +864,42 @@\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n // ( SOLUZIONE 2023-06-07\n+\tif (v < ini_utn_w || v >= fin_utn_w)\n+\t\treturn false;\n+\tpaddr tab = esecuzione->cr3;\n+\tfor (int liv = MAX_LIV; liv > 1; liv--) {\n+\t\tint i = i_tab(v, liv);\n+\t\ttab_entry& e = get_entry(tab, i);\n+\t\tif (!(e & BIT_P))\n+\t\t\treturn false;\n+\t\tif (e & BIT_RW)\n+\t\t\treturn true;\n+\t\tpaddr new_tab = alloca_tab();\n+\t\tif (!new_tab)\n+\t\t\treturn false;\n+\t\tpaddr old_tab = extr_IND_FISICO(e);\n+\t\tmemcpy(voidptr_cast(new_tab), voidptr_cast(old_tab), DIM_PAGINA);\n+\t\tset_IND_FISICO(e, new_tab);\n+\t\te |= BIT_RW;\n+\t\ttab = new_tab;\n+\t}\n+\tint i = i_tab(v, 1);\n+\ttab_entry& e = get_entry(tab, i);\n+\tif (!(e & BIT_P))\n+\t\treturn false;\n+\tif (e & BIT_RW)\n+\t\treturn true;\n+\tpaddr new_frame = alloca_frame();\n+\tif (!new_frame)\n+\t\treturn false;\n+\tpaddr old_frame = extr_IND_FISICO(e);\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\tset_IND_FISICO(e, new_frame);\n+\te |= BIT_RW;\n+\tinvalida_entrata_TLB(v);\n+\treturn true;\n //   SOLUZIONE 2023-06-07 )\n }\n \n /**\n\n\u001b[0m\nNow let me compile and test the code:\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make clean && make 2>&1\n[make] ==> Elimino tutti i file oggetto\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\nCompilation succeeded. Now let me test it:\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | tail -50\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nERR\t6\tPANIC: tentativo di deallocare la tabella 485000 con 65520 entrate valide\nERR\t6\t  processi: 2\nERR\t6\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t6\tcorpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nERR\t6\t  RIP=panic [sistema.cpp:1912] CPL=LIV_SISTEMA\nERR\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t6\t  RAX=               a RBX=      fffffffa10 RCX=               0 RDX=      ffffff03f8\nERR\t6\t  RDI=               3 RSI=             3f8 RBP=      fffffff9f8 RSP=      fffffff9f0\nERR\t6\t  R8 =              36 R9 =      fffffff817 R10=          207f90 R11=          207f90\nERR\t6\t  R12=               2 R13=          485000 R14=               0 R15=               0\nERR\t6\t  backtrace:\nERR\t6\t  > fpanic(char const*, ...) [fpanic.cpp:13]\nERR\t6\t  > rilascia_tab(unsigned long) [sistema.cpp:713]\nERR\t6\t  > distruggi_cow_privata() [sistema.cpp:923]\nERR\t6\t  > distruggi_processo(des_proc*) [sistema.cpp:1234]\nERR\t6\t  > c_terminate_p [sistema.cpp:1370]\nERR\t6\t  > c_abort_p [sistema.cpp:1401]\nERR\t6\t  > gestore_eccezioni [sistema.cpp:483]\nERR\t6\t  > exc_page_fault [sistema.s:812]\nERR\t6\t  > t00p0b(unsigned long) [utente.cpp:65]\nERR\t6\t  > 0xaaaaaaaaaaaaaaa9\nERR\t6\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t6\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1582](0), livello SISTEMA, precedenza 0\nERR\t6\t  RIP=main [sistema.cpp:1714] CPL=LIV_SISTEMA\nERR\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t6\t  RAX=          202ae0 RBX=            13a0 RCX=               0 RDX=          2203f8\nERR\t6\t  RDI=            13a0 RSI=          222230 RBP=          222300 RSP=          222230\nERR\t6\t  R8 =              30 R9 =          22205f R10=               0 R11=               0\nERR\t6\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t6\t  backtrace:\n\u001b[0m\nLet me look at the test code to understand what's happening:\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\nI see the problem! The COW zone check is wrong. The check `v >= fin_utn_w` compares against the maximum possible size (based on root table entries), but the actual COW zone is only `DIM_USR_COW` bytes. Let me fix this:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -864,9 +864,9 @@\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n // ( SOLUZIONE 2023-06-07\n-\tif (v < ini_utn_w || v >= fin_utn_w)\n+\tif (v < ini_utn_w || v >= ini_utn_w + DIM_USR_COW)\n \t\treturn false;\n \tpaddr tab = esecuzione->cr3;\n \tfor (int liv = MAX_LIV; liv > 1; liv--) {\n \t\tint i = i_tab(v, liv);\n@@ -878,9 +878,9 @@\n \t\tpaddr new_tab = alloca_tab();\n \t\tif (!new_tab)\n \t\t\treturn false;\n \t\tpaddr old_tab = extr_IND_FISICO(e);\n-\t\tmemcpy(voidptr_cast(new_tab), voidptr_cast(old_tab), DIM_PAGINA);\n+\t\tcopy_des(old_tab, new_tab, 0, 512);\n \t\tset_IND_FISICO(e, new_tab);\n \t\te |= BIT_RW;\n \t\ttab = new_tab;\n \t}\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | tail -80\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: scrittura di un byte non allineato alla pagina\nINF\t5\tproc=10 entry=t03p0b(unsigned long) [utente.cpp:116](3) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nWRN\t10\tEccezione 14 (page fault), errore 7, RIP t03p0b(unsigned long) [utente.cpp:118 (discriminator 1)]\nWRN\t10\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t10\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 3: PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: scrittura di due byte nella stessa pagina\nINF\t5\tproc=11 entry=t04p0b(unsigned long) [utente.cpp:132](4) prio=595 liv=3\nINF\t10\tProcesso 10 terminato\nWRN\t11\tEccezione 14 (page fault), errore 7, RIP t04p0b(unsigned long) [utente.cpp:134 (discriminator 1)]\nWRN\t11\t  indirizzo virtuale: ffffc0000000f4d2 \nWRN\t11\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 4: PROC 5: OK\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: scrittura di due byte in due pagine diverse\nINF\t5\tproc=12 entry=t05p0b(unsigned long) [utente.cpp:152](5) prio=594 liv=3\nINF\t11\tProcesso 11 terminato\nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:155 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000f4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000e4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000e4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nERR\t12\tPANIC: PAGE FAULT NON RISOLTO\nERR\t12\t  processi: 2\nERR\t12\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t12\tcorpo t05p0b(unsigned long) [utente.cpp:152](5), livello UTENTE, precedenza 594\nERR\t12\t  RIP=panic [sistema.cpp:1912] CPL=LIV_SISTEMA\nERR\t12\t  RFLAGS=6 [-- -- -- -- -- -- -- -- PF --, IOPL=SISTEMA]\nERR\t12\t  RAX=               a RBX=               7 RCX=               0 RDX=      ffffff03f8\nERR\t12\t  RDI=               3 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nERR\t12\t  R8 =              32 R9 =      fffffffdb8 R10=               0 R11=               0\nERR\t12\t  R12=               e R13=ffff800000000c57 R14=               0 R15=               0\nERR\t12\t  backtrace:\nERR\t12\t  > gestore_eccezioni [sistema.cpp:460]\nERR\t12\t  > exc_page_fault [sistema.s:812]\nERR\t12\t  > t05p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nERR\t12\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t12\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1582](0), livello SISTEMA, precedenza 0\nERR\t12\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t12\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t12\t  RAX=          202ade RBX=            13a0 RCX=               0 RDX=          2203f8\nERR\t12\t  RDI=            13a0 RSI=          222230 RBP=          222300 RSP=          222220\nERR\t12\t  R8 =              30 R9 =          22205f R10=               0 R11=               0\nERR\t12\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t12\t  backtrace:\nERR\t12\t  > main [sistema.cpp:1715]\nERR\t12\t  > _start [start64.s:33]\nERR\t12\tproc 2: corpo estern_kbd(unsigned long) [io.cpp:197](0), livello SISTEMA, precedenza 1104\nERR\t12\t  RIP=estern_kbd(unsigned long) [io.cpp:197] CPL=LIV_SISTEMA\nERR\t12\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t12\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t12\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t12\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t12\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t12\t  backtrace:\nERR\t12\tproc 3: corpo estern_hd(unsigned long) [io.cpp:557](0), livello SISTEMA, precedenza 1120\nERR\t12\t  RIP=estern_hd(unsigned long) [io.cpp:557] CPL=LIV_SISTEMA\nERR\t12\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t12\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t12\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t12\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t12\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t12\t  backtrace:\nERR\t12\tproc 5: corpo main_body(unsigned long) [utente.cpp:170](0), livello UTENTE, precedenza 900\nERR\t12\t  RIP=sem_wait [utente.s:49] CPL=LIV_UTENTE\nERR\t12\t  RFLAGS=206 [-- -- -- IF -- -- -- -- PF --, IOPL=SISTEMA]\nERR\t12\t  RAX=ffff800000004188 RBX=ffff800000004180 RCX=               3 RDX=ffff80000000413c\nERR\t12\t  RDI=               1 RSI=               5 RBP=fffffffffffffff0 RSP=ffffffffffffffc8\nERR\t12\t  R8 =              65 R9 =fffffffffffffea9 R10=               0 R11=               0\nERR\t12\t  R12=            1b95 R13=ffff800000004188 R14=               0 R15=               0\nERR\t12\t  backtrace:\nERR\t12\t  > main_body(unsigned long) [utente.cpp:220]\nERR\t12\t  > 0xaaaaaaaaaaaaaaa9\n\u001b[0m\nI see the issue. When I find BIT_RW at a higher level, I'm returning true prematurely. But the lower levels might still be read-only. I need to continue down to level 1. Let me fix this:\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -872,10 +872,12 @@\n int i = i_tab(v, liv);\n tab_entry& e = get_entry(tab, i);\n if (!(e & BIT_P))\n \treturn false;\n-if (e & BIT_RW)\n-\treturn true;\n+if (e & BIT_RW) {\n+\ttab = extr_IND_FISICO(e);\n+\tcontinue;\n+}\n paddr new_tab = alloca_tab();\n if (!new_tab)\n \treturn false;\n paddr old_tab = extr_IND_FISICO(e);\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | tail -60\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000010000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1: PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 2: PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: scrittura di un byte non allineato alla pagina\nINF\t5\tproc=10 entry=t03p0b(unsigned long) [utente.cpp:116](3) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nWRN\t10\tEccezione 14 (page fault), errore 7, RIP t03p0b(unsigned long) [utente.cpp:118 (discriminator 1)]\nWRN\t10\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t10\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 3: PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: scrittura di due byte nella stessa pagina\nINF\t5\tproc=11 entry=t04p0b(unsigned long) [utente.cpp:132](4) prio=595 liv=3\nINF\t10\tProcesso 10 terminato\nWRN\t11\tEccezione 14 (page fault), errore 7, RIP t04p0b(unsigned long) [utente.cpp:134 (discriminator 1)]\nWRN\t11\t  indirizzo virtuale: ffffc0000000f4d2 \nWRN\t11\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 4: PROC 5: OK\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: scrittura di due byte in due pagine diverse\nINF\t5\tproc=12 entry=t05p0b(unsigned long) [utente.cpp:152](5) prio=594 liv=3\nINF\t11\tProcesso 11 terminato\nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:155 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000f4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc0000000e4d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 5: PROC 5: OK\nDBG\t5\tTEST 5: === FINE ===\nINF\t12\tProcesso 12 terminato\nUSR\t5\tPremere un tasto per continuare\nINF\t5\tProcesso 5 terminato\nINF\t0\tShutdown\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [offset=828, limit=50]\u001b[0m\nAll tests passed! The solution is working correctly:\n- Test 0: Correctly aborts processes that access outside the COW zone\n- Tests 1-5: All COW operations work correctly (read and write)\n- Memory is properly freed at the end\n\nThe solution is complete. Let me show the final implementation:\nThe solution is complete and all tests pass. Here's a summary of what was implemented:\n\n**`crea_cow_condivisa()`**:\n- Allocates `cow_root` as a shared root table\n- Maps `DIM_USR_COW` bytes at `ini_utn_w` with `BIT_US` (user accessible) but no `BIT_RW` (read-only)\n- All pages are initialized to zeros\n\n**`aggiorna_cow_privata(vaddr v)`**:\n- Returns false if `v` is outside `[ini_utn_w, ini_utn_w + DIM_USR_COW)` \n- Walks down the TRIE, copying tables at each level when needed (setting `BIT_RW`)\n- At level 1, allocates a new frame, copies page content, and enables writing\n- Invalidates TLB entry for the modified address\n",
  "duration_seconds": 666.7,
  "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 59d0e91..16c7df4 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -829,6 +829,22 @@ bool crea_cow_condivisa()\n {\n /// @todo creare la prima copia della zona cow\n // ( SOLUZIONE 2023-06-07\n+\tcow_root = alloca_tab();\n+\tif (!cow_root)\n+\t\treturn false;\n+\tvaddr v = map(cow_root, ini_utn_w, ini_utn_w + DIM_USR_COW, BIT_US,\n+\t\t[](vaddr) { \n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f)\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\treturn f;\n+\t\t});\n+\tif (v != ini_utn_w + DIM_USR_COW) {\n+\t\trilascia_tab(cow_root);\n+\t\tcow_root = 0;\n+\t\treturn false;\n+\t}\n+\treturn true;\n //   SOLUZIONE 2023-06-07 )\n }\n \n@@ -849,6 +865,42 @@ void copia_cow_condivisa(paddr dest)\n bool aggiorna_cow_privata(vaddr v)\n {\n // ( SOLUZIONE 2023-06-07\n+\tif (v < ini_utn_w || v >= ini_utn_w + DIM_USR_COW)\n+\t\treturn false;\n+\tpaddr tab = esecuzione->cr3;\n+\tfor (int liv = MAX_LIV; liv > 1; liv--) {\n+\t\tint i = i_tab(v, liv);\n+\t\ttab_entry& e = get_entry(tab, i);\n+\t\tif (!(e & BIT_P))\n+\t\t\treturn false;\n+\t\tif (e & BIT_RW) {\n+\t\t\ttab = extr_IND_FISICO(e);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tpaddr new_tab = alloca_tab();\n+\t\tif (!new_tab)\n+\t\t\treturn false;\n+\t\tpaddr old_tab = extr_IND_FISICO(e);\n+\t\tcopy_des(old_tab, new_tab, 0, 512);\n+\t\tset_IND_FISICO(e, new_tab);\n+\t\te |= BIT_RW;\n+\t\ttab = new_tab;\n+\t}\n+\tint i = i_tab(v, 1);\n+\ttab_entry& e = get_entry(tab, i);\n+\tif (!(e & BIT_P))\n+\t\treturn false;\n+\tif (e & BIT_RW)\n+\t\treturn true;\n+\tpaddr new_frame = alloca_frame();\n+\tif (!new_frame)\n+\t\treturn false;\n+\tpaddr old_frame = extr_IND_FISICO(e);\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\tset_IND_FISICO(e, new_frame);\n+\te |= BIT_RW;\n+\tinvalida_entrata_TLB(v);\n+\treturn true;\n //   SOLUZIONE 2023-06-07 )\n }\n \ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 59d0e91..16c7df4 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -829,6 +829,22 @@ bool crea_cow_condivisa()\n {\n /// @todo creare la prima copia della zona cow\n // ( SOLUZIONE 2023-06-07\n+\tcow_root = alloca_tab();\n+\tif (!cow_root)\n+\t\treturn false;\n+\tvaddr v = map(cow_root, ini_utn_w, ini_utn_w + DIM_USR_COW, BIT_US,\n+\t\t[](vaddr) { \n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f)\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\treturn f;\n+\t\t});\n+\tif (v != ini_utn_w + DIM_USR_COW) {\n+\t\trilascia_tab(cow_root);\n+\t\tcow_root = 0;\n+\t\treturn false;\n+\t}\n+\treturn true;\n //   SOLUZIONE 2023-06-07 )\n }\n \n@@ -849,6 +865,42 @@ void copia_cow_condivisa(paddr dest)\n bool aggiorna_cow_privata(vaddr v)\n {\n // ( SOLUZIONE 2023-06-07\n+\tif (v < ini_utn_w || v >= ini_utn_w + DIM_USR_COW)\n+\t\treturn false;\n+\tpaddr tab = esecuzione->cr3;\n+\tfor (int liv = MAX_LIV; liv > 1; liv--) {\n+\t\tint i = i_tab(v, liv);\n+\t\ttab_entry& e = get_entry(tab, i);\n+\t\tif (!(e & BIT_P))\n+\t\t\treturn false;\n+\t\tif (e & BIT_RW) {\n+\t\t\ttab = extr_IND_FISICO(e);\n+\t\t\tcontinue;\n+\t\t}\n+\t\tpaddr new_tab = alloca_tab();\n+\t\tif (!new_tab)\n+\t\t\treturn false;\n+\t\tpaddr old_tab = extr_IND_FISICO(e);\n+\t\tcopy_des(old_tab, new_tab, 0, 512);\n+\t\tset_IND_FISICO(e, new_tab);\n+\t\te |= BIT_RW;\n+\t\ttab = new_tab;\n+\t}\n+\tint i = i_tab(v, 1);\n+\ttab_entry& e = get_entry(tab, i);\n+\tif (!(e & BIT_P))\n+\t\treturn false;\n+\tif (e & BIT_RW)\n+\t\treturn true;\n+\tpaddr new_frame = alloca_frame();\n+\tif (!new_frame)\n+\t\treturn false;\n+\tpaddr old_frame = extr_IND_FISICO(e);\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\tset_IND_FISICO(e, new_frame);\n+\te |= BIT_RW;\n+\tinvalida_entrata_TLB(v);\n+\treturn true;\n //   SOLUZIONE 2023-06-07 )\n }\n \n",
  "error": null
}