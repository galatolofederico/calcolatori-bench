{
  "passed": true,
  "output": [
    "TEST 1 PROC 4: OK",
    "TEST 2 PROC 4: OK",
    "TEST 3 PROC 4: OK",
    "TEST 4 PROC 4: OK",
    "TEST 5 PROC 4: OK",
    "TEST 6 PROC 4: OK",
    "TEST 7 PROC 4: OK",
    "Premere un tasto per continuare"
  ],
  "expected": [
    "TEST 1 PROC 4: OK",
    "TEST 2 PROC 4: OK",
    "TEST 3 PROC 4: OK",
    "TEST 4 PROC 4: OK",
    "TEST 5 PROC 4: OK",
    "TEST 6 PROC 4: OK",
    "TEST 7 PROC 4: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6fd2 memsize   6fd2\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   321c memsize   321c\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6fd2 byte da   10c000 a   200000\nINF\t-\t- copiati   321c byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205df7\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t5\t  R8 =              35 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): processo non ha read lock\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t6\t  R8 =              36 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=          20b1a0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): processo non ha lock su rwlock\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t7\t  R8 =              37 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=          20b1a0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2087]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): processo non ha read lock\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t8\t  R8 =              38 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=          20b1a0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t9\t  R12=               1 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nUSR\t4\tTEST 2 PROC 4: OK\nDBG\t4\tTEST 2: === FINE ===\nDBG\t4\tTEST 3: >>>INIZIO<<<: piu' scrittori (precedenza superior)\nINF\t4\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:180](3) prio=591 liv=3\nINF\t4\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:194](3) prio=590 liv=3\nINF\t13\tProcesso 13 terminato\nINF\t14\tProcesso 14 terminato\nUSR\t4\tTEST 3 PROC 4: OK\nDBG\t4\tTEST 3: === FINE ===\nDBG\t4\tTEST 4: >>>INIZIO<<<: lettori e scrittori\nINF\t4\tproc=16 entry=t04p0b(unsigned long) [utente.cpp:221](4) prio=589 liv=3\nINF\t4\tproc=17 entry=t04p1b(unsigned long) [utente.cpp:236](4) prio=588 liv=3\nINF\t4\tproc=18 entry=t04p2b(unsigned long) [utente.cpp:254](4) prio=587 liv=3\nINF\t4\tproc=19 entry=t04p3b(unsigned long) [utente.cpp:265](4) prio=586 liv=3\nINF\t15\tProcesso 15 terminato\nINF\t16\tProcesso 16 terminato\nINF\t17\tProcesso 17 terminato\nINF\t18\tProcesso 18 terminato\nUSR\t4\tTEST 4 PROC 4: OK\nDBG\t4\tTEST 4: === FINE ===\nDBG\t4\tTEST 5: >>>INIZIO<<<: lettori arrivati durante l'upgrade\nINF\t4\tproc=20 entry=t05p0b(unsigned long) [utente.cpp:288](5) prio=585 liv=3\nINF\t4\tproc=21 entry=t05p1b(unsigned long) [utente.cpp:303](5) prio=584 liv=3\nINF\t19\tProcesso 19 terminato\nINF\t20\tProcesso 20 terminato\nUSR\t4\tTEST 5 PROC 4: OK\nDBG\t4\tTEST 5: === FINE ===\nDBG\t4\tTEST 6: >>>INIZIO<<<: piu' upgrade\nINF\t4\tproc=22 entry=t06p0b(unsigned long) [utente.cpp:328](6) prio=583 liv=3\nINF\t4\tproc=23 entry=t06p1b(unsigned long) [utente.cpp:347](6) prio=582 liv=3\nINF\t4\tproc=24 entry=t06p2b(unsigned long) [utente.cpp:362](6) prio=581 liv=3\nINF\t21\tProcesso 21 terminato\nINF\t22\tProcesso 22 terminato\nINF\t23\tProcesso 23 terminato\nUSR\t4\tTEST 6 PROC 4: OK\nDBG\t4\tTEST 6: === FINE ===\nDBG\t4\tTEST 7: >>>INIZIO<<<: piu' rwlock\nINF\t4\tproc=25 entry=t07p0b(unsigned long) [utente.cpp:387](7) prio=580 liv=3\nINF\t4\tproc=26 entry=t07p1b(unsigned long) [utente.cpp:411](7) prio=579 liv=3\nINF\t4\tproc=27 entry=t07p2b(unsigned long) [utente.cpp:423](7) prio=578 liv=3\nINF\t24\tProcesso 24 terminato\nINF\t25\tProcesso 25 terminato\nINF\t26\tProcesso 26 terminato\nUSR\t4\tTEST 7 PROC 4: OK\nDBG\t4\tTEST 7: === FINE ===\nUSR\t4\tPremere un tasto per continuare\nINF\t4\tProcesso 4 terminato\nINF\t27\tProcesso 27 terminato\nINF\t0\tShutdown\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 z-ai/glm-5:nitro\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.cpp\"\u001b[90m 10 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.h\"\u001b[90m 6 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"ESAME|SOLUZIONE\"\u001b[90m 10 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=1850]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=1949]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=80, offset=20]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=99]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"w_readers|w_writers\"\u001b[90m 6 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inspronti\"\u001b[90m 3 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=360]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"c_abort_p\"\u001b[90m 14 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\n\u001b[0m\u2731 \u001b[0mGrep \"MAX_PROC_RW|MAX_RW\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[ ] Implement rw_upgrade and rw_downgrade in sistema.cpp\n[ ] Compile with make\n[ ] Test with timeout 10s boot\n\u001b[0m\nNow I understand the structure. Let me implement the `rw_upgrade` and `rw_downgrade` functions.\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2025,8 +2025,105 @@\n \t\tr->nreaders++;\n \t}\n }\n // ( SOLUZIONE 2024-09-11\n+\n+/// Parte C++ della primitiva rw_upgrade()\n+extern \"C\" void c_rw_upgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state != RW_READER) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): processo non ha read lock\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tr->nreaders--;\n+\n+\tif (r->nreaders == 0 && r->writer == 0) {\n+\t\tif (r->w_writers == nullptr || esecuzione->precedenza >= r->w_writers->precedenza) {\n+\t\t\tr->writer = esecuzione->id;\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t} else {\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\t\tschedulatore();\n+\t\t}\n+\t} else {\n+\t\trp->state = RW_UPGRADED;\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t}\n+}\n+\n+/// Parte C++ della primitiva rw_downgrade()\n+extern \"C\" void c_rw_downgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): processo non ha lock su rwlock\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tswitch (rp->state) {\n+\t\tcase RW_READER:\n+\t\t\tr->nreaders--;\n+\t\t\trp->r = nullptr;\n+\t\t\tbreak;\n+\t\tcase RW_WRITER:\n+\t\t\tr->writer = 0;\n+\t\t\trp->r = nullptr;\n+\t\t\tbreak;\n+\t\tcase RW_UPGRADED:\n+\t\t\tr->writer = 0;\n+\t\t\tr->nreaders++;\n+\t\t\trp->state = RW_READER;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tflog(LOG_WARN, \"rw_downgrade(%d): stato non valido\", rw);\n+\t\t\tc_abort_p();\n+\t\t\treturn;\n+\t}\n+\n+\tif (r->writer == 0) {\n+\t\tbool readers_woken = false;\n+\t\twhile (r->w_readers != nullptr) {\n+\t\t\tdes_proc *p = rimozione_lista(r->w_readers);\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\twp->state = RW_READER;\n+\t\t\tr->nreaders++;\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t\treaders_woken = true;\n+\t\t}\n+\n+\t\tif (!readers_woken && r->nreaders == 0 && r->w_writers != nullptr) {\n+\t\t\tdes_proc *p = rimozione_lista(r->w_writers);\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\tr->writer = p->id;\n+\t\t\tif (wp->state == RW_NONE) {\n+\t\t\t\twp->state = RW_WRITER;\n+\t\t\t}\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t}\n+\t}\n+}\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \n /// @}\n\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement rw_upgrade and rw_downgrade in sistema.cpp\n[ ] Compile with make\n[ ] Test with timeout 10s boot\n\u001b[0m\n\u001b[0m$ \u001b[0mmake\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement rw_upgrade and rw_downgrade in sistema.cpp\n[x] Compile with make\n[ ] Test with timeout 10s boot\n\u001b[0m\n\u001b[0m$ \u001b[0mtimeout 10s boot\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f66 memsize   6f66\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   320c memsize   320c\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f66 byte da   10c000 a   200000\nINF\t-\t- copiati   320c byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d8b\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t5\t  R8 =              35 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): processo non ha read lock\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t6\t  R8 =              36 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): processo non ha lock su rwlock\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t7\t  R8 =              37 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=          20b1a0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2080]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): processo non ha read lock\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t8\t  R8 =              38 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t9\t  R12=               1 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2071]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nUSR\t4\tTEST 2 PROC 4: OK\nDBG\t4\tTEST 2: === FINE ===\nDBG\t4\tTEST 3: >>>INIZIO<<<: piu' scrittori (precedenza superior)\nINF\t4\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:180](3) prio=591 liv=3\nINF\t4\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:194](3) prio=590 liv=3\nINF\t13\tProcesso 13 terminato\nqemu-system-x86_64: terminating on signal 15 from pid 509 (timeout)\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=2028]\u001b[0m\nThe test hangs at test 3. I see the issue - when an upgrader can't get the lock immediately due to a higher-priority waiting writer, I need to wake that writer before blocking. Let me fix the code:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2053,8 +2053,15 @@\n \t\trp->state = RW_UPGRADED;\n \t} else {\n \t\trp->state = RW_UPGRADED;\n \t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tdes_proc *p = rimozione_lista(r->w_writers);\n+\t\tr->writer = p->id;\n+\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\tif (wp->state == RW_NONE) {\n+\t\t\twp->state = RW_WRITER;\n+\t\t}\n+\t\tinserimento_lista(pronti, p);\n \t\tschedulatore();\n \t}\n } else {\n \trp->state = RW_UPGRADED;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mmake && timeout 10s boot\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6fc8 memsize   6fc8\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   321c memsize   321c\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6fc8 byte da   10c000 a   200000\nINF\t-\t- copiati   321c byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205ded\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t5\t  R8 =              35 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): processo non ha read lock\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t6\t  R8 =              36 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=          20b1a0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): processo non ha lock su rwlock\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t7\t  R8 =              37 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=          20b1a0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2087]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): processo non ha read lock\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t8\t  R8 =              38 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=          20b1a0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t9\t  R12=               1 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nUSR\t4\tTEST 2 PROC 4: OK\nDBG\t4\tTEST 2: === FINE ===\nDBG\t4\tTEST 3: >>>INIZIO<<<: piu' scrittori (precedenza superior)\nINF\t4\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:180](3) prio=591 liv=3\nINF\t4\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:194](3) prio=590 liv=3\nINF\t13\tProcesso 13 terminato\nINF\t14\tProcesso 14 terminato\nUSR\t4\tTEST 3 PROC 4: OK\nDBG\t4\tTEST 3: === FINE ===\nDBG\t4\tTEST 4: >>>INIZIO<<<: lettori e scrittori\nINF\t4\tproc=16 entry=t04p0b(unsigned long) [utente.cpp:221](4) prio=589 liv=3\nINF\t4\tproc=17 entry=t04p1b(unsigned long) [utente.cpp:236](4) prio=588 liv=3\nINF\t4\tproc=18 entry=t04p2b(unsigned long) [utente.cpp:254](4) prio=587 liv=3\nINF\t4\tproc=19 entry=t04p3b(unsigned long) [utente.cpp:265](4) prio=586 liv=3\nINF\t15\tProcesso 15 terminato\nINF\t16\tProcesso 16 terminato\nINF\t17\tProcesso 17 terminato\nINF\t18\tProcesso 18 terminato\nUSR\t4\tTEST 4 PROC 4: OK\nDBG\t4\tTEST 4: === FINE ===\nDBG\t4\tTEST 5: >>>INIZIO<<<: lettori arrivati durante l'upgrade\nINF\t4\tproc=20 entry=t05p0b(unsigned long) [utente.cpp:288](5) prio=585 liv=3\nINF\t4\tproc=21 entry=t05p1b(unsigned long) [utente.cpp:303](5) prio=584 liv=3\nINF\t19\tProcesso 19 terminato\nUSR\t21\tTEST 5 PROC 21: ERRORE: dovremmo essere al turno 5, invece siamo a 3\nINF\t21\tProcesso 21 terminato\nDBG\t4\tTEST 5: === FINE ===\nDBG\t4\tTEST 6: >>>INIZIO<<<: piu' upgrade\nINF\t4\tproc=22 entry=t06p0b(unsigned long) [utente.cpp:328](6) prio=583 liv=3\nINF\t4\tproc=23 entry=t06p1b(unsigned long) [utente.cpp:347](6) prio=582 liv=3\nINF\t4\tproc=24 entry=t06p2b(unsigned long) [utente.cpp:362](6) prio=581 liv=3\nINF\t20\tProcesso 20 terminato\nUSR\t24\tTEST 6 PROC 24: ERRORE: dovremmo essere al turno 12, invece siamo a 6\nINF\t24\tProcesso 24 terminato\nINF\t22\tProcesso 22 terminato\nDBG\t4\tTEST 6: === FINE ===\nDBG\t4\tTEST 7: >>>INIZIO<<<: piu' rwlock\nINF\t4\tproc=25 entry=t07p0b(unsigned long) [utente.cpp:387](7) prio=580 liv=3\nINF\t4\tproc=26 entry=t07p1b(unsigned long) [utente.cpp:411](7) prio=579 liv=3\nINF\t4\tproc=27 entry=t07p2b(unsigned long) [utente.cpp:423](7) prio=578 liv=3\nINF\t23\tProcesso 23 terminato\nINF\t25\tProcesso 25 terminato\nINF\t26\tProcesso 26 terminato\nUSR\t4\tTEST 7 PROC 4: OK\nDBG\t4\tTEST 7: === FINE ===\nUSR\t4\tPremere un tasto per continuare\nINF\t4\tProcesso 4 terminato\nINF\t27\tProcesso 27 terminato\nINF\t0\tShutdown\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=2089]\u001b[0m\nTests 5 and 6 fail. The issue is that after `rw_downgrade`, other processes should run before the current process continues. I need to call `inspronti()` and `schedulatore()` to yield after waking processes.\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2127,8 +2127,11 @@\n \t\t\t\twp->state = RW_WRITER;\n \t\t\t}\n \t\t\tinserimento_lista(pronti, p);\n \t\t}\n+\n+\t\tinspronti();\n+\t\tschedulatore();\n \t}\n }\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n\n\u001b[0m\n\u001b[0m$ \u001b[0mmake && timeout 10s boot\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6fc6 memsize   6fc6\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   321c memsize   321c\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6fc6 byte da   10c000 a   200000\nINF\t-\t- copiati   321c byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205deb\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t5\t  R8 =              35 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): processo non ha read lock\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t6\t  R8 =              36 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=          20b1a0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): processo non ha lock su rwlock\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t7\t  R8 =              37 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=          20b1a0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2087]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): processo non ha read lock\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t8\t  R8 =              38 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=          20b1a0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t9\t  R12=               1 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nUSR\t4\tTEST 2 PROC 4: OK\nDBG\t4\tTEST 2: === FINE ===\nDBG\t4\tTEST 3: >>>INIZIO<<<: piu' scrittori (precedenza superior)\nINF\t4\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:180](3) prio=591 liv=3\nINF\t4\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:194](3) prio=590 liv=3\nINF\t13\tProcesso 13 terminato\nINF\t14\tProcesso 14 terminato\nUSR\t4\tTEST 3 PROC 4: OK\nDBG\t4\tTEST 3: === FINE ===\nDBG\t4\tTEST 4: >>>INIZIO<<<: lettori e scrittori\nINF\t4\tproc=16 entry=t04p0b(unsigned long) [utente.cpp:221](4) prio=589 liv=3\nINF\t4\tproc=17 entry=t04p1b(unsigned long) [utente.cpp:236](4) prio=588 liv=3\nINF\t4\tproc=18 entry=t04p2b(unsigned long) [utente.cpp:254](4) prio=587 liv=3\nINF\t4\tproc=19 entry=t04p3b(unsigned long) [utente.cpp:265](4) prio=586 liv=3\nINF\t15\tProcesso 15 terminato\nINF\t16\tProcesso 16 terminato\nINF\t17\tProcesso 17 terminato\nINF\t18\tProcesso 18 terminato\nUSR\t4\tTEST 4 PROC 4: OK\nDBG\t4\tTEST 4: === FINE ===\nDBG\t4\tTEST 5: >>>INIZIO<<<: lettori arrivati durante l'upgrade\nINF\t4\tproc=20 entry=t05p0b(unsigned long) [utente.cpp:288](5) prio=585 liv=3\nINF\t4\tproc=21 entry=t05p1b(unsigned long) [utente.cpp:303](5) prio=584 liv=3\nINF\t19\tProcesso 19 terminato\nUSR\t21\tTEST 5 PROC 21: ERRORE: dovremmo essere al turno 5, invece siamo a 3\nINF\t21\tProcesso 21 terminato\nDBG\t4\tTEST 5: === FINE ===\nDBG\t4\tTEST 6: >>>INIZIO<<<: piu' upgrade\nINF\t4\tproc=22 entry=t06p0b(unsigned long) [utente.cpp:328](6) prio=583 liv=3\nINF\t4\tproc=23 entry=t06p1b(unsigned long) [utente.cpp:347](6) prio=582 liv=3\nINF\t4\tproc=24 entry=t06p2b(unsigned long) [utente.cpp:362](6) prio=581 liv=3\nINF\t20\tProcesso 20 terminato\nUSR\t24\tTEST 6 PROC 24: ERRORE: dovremmo essere al turno 12, invece siamo a 6\nINF\t24\tProcesso 24 terminato\nINF\t22\tProcesso 22 terminato\nDBG\t4\tTEST 6: === FINE ===\nDBG\t4\tTEST 7: >>>INIZIO<<<: piu' rwlock\nINF\t4\tproc=25 entry=t07p0b(unsigned long) [utente.cpp:387](7) prio=580 liv=3\nINF\t4\tproc=26 entry=t07p1b(unsigned long) [utente.cpp:411](7) prio=579 liv=3\nINF\t4\tproc=27 entry=t07p2b(unsigned long) [utente.cpp:423](7) prio=578 liv=3\nINF\t23\tProcesso 23 terminato\nINF\t25\tProcesso 25 terminato\nINF\t26\tProcesso 26 terminato\nUSR\t4\tTEST 7 PROC 4: OK\nDBG\t4\tTEST 7: === FINE ===\nUSR\t4\tPremere un tasto per continuare\nINF\t4\tProcesso 4 terminato\nINF\t27\tProcesso 27 terminato\nINF\t0\tShutdown\n\u001b[0m\nThe issue is that `inspronti()` inserts at the head of `pronti`, so the current process runs next instead of the highest priority process. I need to use `inserimento_lista(pronti, esecuzione)` to insert by priority.\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2128,9 +2128,9 @@\n \t\t\t}\n \t\t\tinserimento_lista(pronti, p);\n \t\t}\n \n-\t\tinspronti();\n+\t\tinserimento_lista(pronti, esecuzione);\n \t\tschedulatore();\n \t}\n }\n //   SOLUZIONE 2024-09-11 )\n\n\u001b[0m\n\u001b[0m$ \u001b[0mmake && timeout 10s boot\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6fd2 memsize   6fd2\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   321c memsize   321c\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6fd2 byte da   10c000 a   200000\nINF\t-\t- copiati   321c byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205df7\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t5\t  R8 =              35 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): processo non ha read lock\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t6\t  R8 =              36 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=          20b1a0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): processo non ha lock su rwlock\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t7\t  R8 =              37 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=          20b1a0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2087]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): processo non ha read lock\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t8\t  R8 =              38 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=          20b1a0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t9\t  R12=               1 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t12\tProcesso 12 terminato\nUSR\t4\tTEST 2 PROC 4: OK\nDBG\t4\tTEST 2: === FINE ===\nDBG\t4\tTEST 3: >>>INIZIO<<<: piu' scrittori (precedenza superior)\nINF\t4\tproc=14 entry=t03p0b(unsigned long) [utente.cpp:180](3) prio=591 liv=3\nINF\t4\tproc=15 entry=t03p1b(unsigned long) [utente.cpp:194](3) prio=590 liv=3\nINF\t13\tProcesso 13 terminato\nINF\t14\tProcesso 14 terminato\nUSR\t4\tTEST 3 PROC 4: OK\nDBG\t4\tTEST 3: === FINE ===\nDBG\t4\tTEST 4: >>>INIZIO<<<: lettori e scrittori\nINF\t4\tproc=16 entry=t04p0b(unsigned long) [utente.cpp:221](4) prio=589 liv=3\nINF\t4\tproc=17 entry=t04p1b(unsigned long) [utente.cpp:236](4) prio=588 liv=3\nINF\t4\tproc=18 entry=t04p2b(unsigned long) [utente.cpp:254](4) prio=587 liv=3\nINF\t4\tproc=19 entry=t04p3b(unsigned long) [utente.cpp:265](4) prio=586 liv=3\nINF\t15\tProcesso 15 terminato\nINF\t16\tProcesso 16 terminato\nINF\t17\tProcesso 17 terminato\nINF\t18\tProcesso 18 terminato\nUSR\t4\tTEST 4 PROC 4: OK\nDBG\t4\tTEST 4: === FINE ===\nDBG\t4\tTEST 5: >>>INIZIO<<<: lettori arrivati durante l'upgrade\nINF\t4\tproc=20 entry=t05p0b(unsigned long) [utente.cpp:288](5) prio=585 liv=3\nINF\t4\tproc=21 entry=t05p1b(unsigned long) [utente.cpp:303](5) prio=584 liv=3\nINF\t19\tProcesso 19 terminato\nINF\t20\tProcesso 20 terminato\nUSR\t4\tTEST 5 PROC 4: OK\nDBG\t4\tTEST 5: === FINE ===\nDBG\t4\tTEST 6: >>>INIZIO<<<: piu' upgrade\nINF\t4\tproc=22 entry=t06p0b(unsigned long) [utente.cpp:328](6) prio=583 liv=3\nINF\t4\tproc=23 entry=t06p1b(unsigned long) [utente.cpp:347](6) prio=582 liv=3\nINF\t4\tproc=24 entry=t06p2b(unsigned long) [utente.cpp:362](6) prio=581 liv=3\nINF\t21\tProcesso 21 terminato\nINF\t22\tProcesso 22 terminato\nINF\t23\tProcesso 23 terminato\nUSR\t4\tTEST 6 PROC 4: OK\nDBG\t4\tTEST 6: === FINE ===\nDBG\t4\tTEST 7: >>>INIZIO<<<: piu' rwlock\nINF\t4\tproc=25 entry=t07p0b(unsigned long) [utente.cpp:387](7) prio=580 liv=3\nINF\t4\tproc=26 entry=t07p1b(unsigned long) [utente.cpp:411](7) prio=579 liv=3\nINF\t4\tproc=27 entry=t07p2b(unsigned long) [utente.cpp:423](7) prio=578 liv=3\nINF\t24\tProcesso 24 terminato\nINF\t25\tProcesso 25 terminato\nINF\t26\tProcesso 26 terminato\nUSR\t4\tTEST 7 PROC 4: OK\nDBG\t4\tTEST 7: === FINE ===\nUSR\t4\tPremere un tasto per continuare\nINF\t4\tProcesso 4 terminato\nINF\t27\tProcesso 27 terminato\nINF\t0\tShutdown\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement rw_upgrade and rw_downgrade in sistema.cpp\n[x] Compile with make\n[x] Test with timeout 10s boot\n\u001b[0m\nAll 8 tests pass now.\nThe solution is complete. I implemented `rw_upgrade` and `rw_downgrade` in `sistema/sistema.cpp`:\n\n**`rw_upgrade`**: Releases read lock and tries to acquire write lock. If other readers exist or a higher-priority writer is waiting, the process blocks on `w_writers`. When blocking due to a higher-priority waiting writer, that writer is immediately woken.\n\n**`rw_downgrade`**: Handles three cases:\n- `RW_READER`: releases read lock completely\n- `RW_WRITER`: releases write lock completely  \n- `RW_UPGRADED`: downgrades to read lock (writer\u2192reader)\n\nAfter releasing, wakes waiting readers (priority) then one writer if no readers. Finally yields via `inserimento_lista(pronti, esecuzione)` and `schedulatore()` to allow higher-priority processes to run.\n",
  "duration_seconds": 1029.33,
  "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 44b9249..7ac4e41 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -2026,6 +2026,113 @@ extern \"C\" void c_rw_readlock(natl rw)\n \t}\n }\n // ( SOLUZIONE 2024-09-11\n+\n+/// Parte C++ della primitiva rw_upgrade()\n+extern \"C\" void c_rw_upgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state != RW_READER) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): processo non ha read lock\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tr->nreaders--;\n+\n+\tif (r->nreaders == 0 && r->writer == 0) {\n+\t\tif (r->w_writers == nullptr || esecuzione->precedenza >= r->w_writers->precedenza) {\n+\t\t\tr->writer = esecuzione->id;\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t} else {\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\t\tdes_proc *p = rimozione_lista(r->w_writers);\n+\t\t\tr->writer = p->id;\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\tif (wp->state == RW_NONE) {\n+\t\t\t\twp->state = RW_WRITER;\n+\t\t\t}\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t\tschedulatore();\n+\t\t}\n+\t} else {\n+\t\trp->state = RW_UPGRADED;\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t}\n+}\n+\n+/// Parte C++ della primitiva rw_downgrade()\n+extern \"C\" void c_rw_downgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): processo non ha lock su rwlock\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tswitch (rp->state) {\n+\t\tcase RW_READER:\n+\t\t\tr->nreaders--;\n+\t\t\trp->r = nullptr;\n+\t\t\tbreak;\n+\t\tcase RW_WRITER:\n+\t\t\tr->writer = 0;\n+\t\t\trp->r = nullptr;\n+\t\t\tbreak;\n+\t\tcase RW_UPGRADED:\n+\t\t\tr->writer = 0;\n+\t\t\tr->nreaders++;\n+\t\t\trp->state = RW_READER;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tflog(LOG_WARN, \"rw_downgrade(%d): stato non valido\", rw);\n+\t\t\tc_abort_p();\n+\t\t\treturn;\n+\t}\n+\n+\tif (r->writer == 0) {\n+\t\tbool readers_woken = false;\n+\t\twhile (r->w_readers != nullptr) {\n+\t\t\tdes_proc *p = rimozione_lista(r->w_readers);\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\twp->state = RW_READER;\n+\t\t\tr->nreaders++;\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t\treaders_woken = true;\n+\t\t}\n+\n+\t\tif (!readers_woken && r->nreaders == 0 && r->w_writers != nullptr) {\n+\t\t\tdes_proc *p = rimozione_lista(r->w_writers);\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\tr->writer = p->id;\n+\t\t\tif (wp->state == RW_NONE) {\n+\t\t\t\twp->state = RW_WRITER;\n+\t\t\t}\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t}\n+\n+\t\tinserimento_lista(pronti, esecuzione);\n+\t\tschedulatore();\n+\t}\n+}\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 44b9249..7ac4e41 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -2026,6 +2026,113 @@ extern \"C\" void c_rw_readlock(natl rw)\n \t}\n }\n // ( SOLUZIONE 2024-09-11\n+\n+/// Parte C++ della primitiva rw_upgrade()\n+extern \"C\" void c_rw_upgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state != RW_READER) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): processo non ha read lock\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tr->nreaders--;\n+\n+\tif (r->nreaders == 0 && r->writer == 0) {\n+\t\tif (r->w_writers == nullptr || esecuzione->precedenza >= r->w_writers->precedenza) {\n+\t\t\tr->writer = esecuzione->id;\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t} else {\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\t\tdes_proc *p = rimozione_lista(r->w_writers);\n+\t\t\tr->writer = p->id;\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\tif (wp->state == RW_NONE) {\n+\t\t\t\twp->state = RW_WRITER;\n+\t\t\t}\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t\tschedulatore();\n+\t\t}\n+\t} else {\n+\t\trp->state = RW_UPGRADED;\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t}\n+}\n+\n+/// Parte C++ della primitiva rw_downgrade()\n+extern \"C\" void c_rw_downgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): processo non ha lock su rwlock\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tswitch (rp->state) {\n+\t\tcase RW_READER:\n+\t\t\tr->nreaders--;\n+\t\t\trp->r = nullptr;\n+\t\t\tbreak;\n+\t\tcase RW_WRITER:\n+\t\t\tr->writer = 0;\n+\t\t\trp->r = nullptr;\n+\t\t\tbreak;\n+\t\tcase RW_UPGRADED:\n+\t\t\tr->writer = 0;\n+\t\t\tr->nreaders++;\n+\t\t\trp->state = RW_READER;\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tflog(LOG_WARN, \"rw_downgrade(%d): stato non valido\", rw);\n+\t\t\tc_abort_p();\n+\t\t\treturn;\n+\t}\n+\n+\tif (r->writer == 0) {\n+\t\tbool readers_woken = false;\n+\t\twhile (r->w_readers != nullptr) {\n+\t\t\tdes_proc *p = rimozione_lista(r->w_readers);\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\twp->state = RW_READER;\n+\t\t\tr->nreaders++;\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t\treaders_woken = true;\n+\t\t}\n+\n+\t\tif (!readers_woken && r->nreaders == 0 && r->w_writers != nullptr) {\n+\t\t\tdes_proc *p = rimozione_lista(r->w_writers);\n+\t\t\tdes_proc_rw *wp = rw_proc_find(r, p);\n+\t\t\tr->writer = p->id;\n+\t\t\tif (wp->state == RW_NONE) {\n+\t\t\t\twp->state = RW_WRITER;\n+\t\t\t}\n+\t\t\tinserimento_lista(pronti, p);\n+\t\t}\n+\n+\t\tinserimento_lista(pronti, esecuzione);\n+\t\tschedulatore();\n+\t}\n+}\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \n",
  "error": null
}