{
  "passed": false,
  "output": [],
  "expected": [
    "TEST 1 PROC 7: OK",
    "TEST 2 PROC 7: OK",
    "TEST 3 PROC 7: OK",
    "TEST 4 PROC 7: OK",
    "TEST 5 PROC 7: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "ce1: opening ce1.out...OK (16)\nce1: opening ce1.in...OK (17)\ninit async\nce2: opening ce2.out...OK (18)\nce2: opening ce2.in...bars...\t\t\nOK (19)\ninit async\nbars...\t\t\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=116b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   67a2 memsize   67a2\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   2ef4 memsize   2ef4\nINF\t-\t  . seg[3]: off   a000 vaddr           20a000 size    180 memsize  17404\nINF\t-\t- mod[1]: start=117000 end=11e590 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   43fb memsize   43fb\nINF\t-\t  . seg[2]: off   5000 vaddr      10000005000 size   1c9c memsize   1c9c\nINF\t-\t  . seg[3]: off   7000 vaddr      10000007000 size    1a8 memsize    840\nINF\t-\t- mod[2]: start=11f000 end=1235c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2acf memsize   2acf\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d8c memsize    d8c\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1d8 memsize    310\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   67a2 byte da   10c000 a   200000\nINF\t-\t- copiati   2ef4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   116000 a   20a000\nINF\t-\t- azzerati ulteriori 17284 byte\nINF\t-\t- entry point 2055c7\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 546 (M1) 7646 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000005000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000005000,      10000007000)\nINF\t0\t - segmento sistema read/write mappato a [     10000007000,      10000008000)\nINF\t0\t - heap:                                 [     10000008000,      10000108000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7115 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000008000, 0x10000108000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\testern=4 entry=estern_ce [io.cpp:759](0) prio=1136 (tipo=70) liv=0 irq=11\nINF\t1\tce0: 00:03.0 base=c014 IRQ=11\nINF\t1\testern=5 entry=estern_ce [io.cpp:759](1) prio=1137 (tipo=71) liv=0 irq=10\nINF\t1\tce1: 00:04.0 base=c024 IRQ=10\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t6\tHeap del modulo utente: 100000B [0xffff800000004310, 0xffff800000104310)\nINF\t6\tproc=7 entry=main_body(unsigned long) [utente.cpp:233](0) prio=900 liv=3\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t7\tproc=8 entry=t00p0b(unsigned long) [utente.cpp:74](0) prio=600 liv=3\nINF\t7\tproc=9 entry=t00p1b(unsigned long) [utente.cpp:81](0) prio=599 liv=3\nINF\t7\tproc=10 entry=t00p2b(unsigned long) [utente.cpp:88](0) prio=598 liv=3\nINF\t7\tproc=11 entry=t00p3b(unsigned long) [utente.cpp:95](0) prio=597 liv=3\nINF\t7\tproc=12 entry=t00p4b(unsigned long) [utente.cpp:102](0) prio=596 liv=3\nWRN\t8\tceasyncread_n: ce non riconosciuto: 2\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=              25 RBX=            13a0 RCX=               0 RDX=              25\nWRN\t8\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t8\t  R8 =              32 R9 =      fffffffe65 R10=               0 R11=               0\nWRN\t8\t  R12=               a R13=ffff8000000042d0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > a_abort_p [sistema.s:311]\nWRN\t8\t  > abort_p [io.s:108]\nWRN\t8\t  > c_ceasyncread_n [io.cpp:676]\nWRN\t8\t  > a_ceasyncread_n [io.s:293]\nWRN\t8\t  > ceasyncread_n [utente.s:147]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\tceasyncread_n: quanti = 0\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=              19 RBX=            1820 RCX=               0 RDX=              19\nWRN\t9\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t9\t  R8 =              30 R9 =      fffffffe59 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=ffff8000000042d0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > a_abort_p [sistema.s:311]\nWRN\t9\t  > abort_p [io.s:108]\nWRN\t9\t  > c_ceasyncread_n [io.cpp:681]\nWRN\t9\t  > a_ceasyncread_n [io.s:293]\nWRN\t9\t  > ceasyncread_n [utente.s:147]\nWRN\t9\tProcesso 9 abortito\nWRN\t10\tceasyncread_n: buf nullo\nWRN\t10\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t10\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t10\t  RAX=              18 RBX=            18e0 RCX=               0 RDX=              18\nWRN\t10\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t10\t  R8 =              6f R9 =      fffffffe58 R10=               0 R11=               0\nWRN\t10\t  R12=               a R13=               0 R14=               0 R15=               0\nWRN\t10\t  backtrace:\nWRN\t10\t  > a_abort_p [sistema.s:311]\nWRN\t10\t  > abort_p [io.s:108]\nWRN\t10\t  > c_ceasyncread_n [io.cpp:686]\nWRN\t10\t  > a_ceasyncread_n [io.s:293]\nWRN\t10\t  > ceasyncread_n [utente.s:147]\nWRN\t10\tProcesso 10 abortito\nWRN\t11\tceasyncread_n: parametri non validi:  [utente.cpp:71], 10\nWRN\t11\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t11\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t11\t  RAX=              3b RBX=            19a0 RCX=               0 RDX=              3b\nWRN\t11\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t11\t  R8 =              30 R9 =      fffffffe7b R10=               0 R11=               0\nWRN\t11\t  R12=               a R13=ffff800000003000 R14=               0 R15=               0\nWRN\t11\t  backtrace:\nWRN\t11\t  > a_abort_p [sistema.s:311]\nWRN\t11\t  > abort_p [io.s:108]\nWRN\t11\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t11\t  > a_ceasyncread_n [io.s:293]\nWRN\t11\t  > ceasyncread_n [utente.s:147]\nWRN\t11\tProcesso 11 abortito\nWRN\t12\tceasyncread_n: parametri non validi: 0xffffffffffffffd6, 10\nWRN\t12\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t12\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t12\t  RAX=              3b RBX=            1a60 RCX=               0 RDX=              3b\nWRN\t12\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t12\t  R8 =              30 R9 =      fffffffe7b R10=               0 R11=               0\nWRN\t12\t  R12=               a R13=ffffffffffffffd6 R14=               0 R15=               0\nWRN\t12\t  backtrace:\nWRN\t12\t  > a_abort_p [sistema.s:311]\nWRN\t12\t  > abort_p [io.s:108]\nWRN\t12\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t12\t  > a_ceasyncread_n [io.s:293]\nWRN\t12\t  > ceasyncread_n [utente.s:147]\nWRN\t12\tProcesso 12 abortito\nDBG\t7\tTEST 0: === FINE ===\nDBG\t7\tTEST 1: >>>INIZIO<<<: caso base\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\nqemu-system-x86_64: terminating on signal 15 from pid 3618 (timeout)\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5:nitro\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 97 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"SOLUZIONE|ESAME\"\u001b[90m in . \u00b7 18 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=200, offset=620]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/io.h\u001b[90m [limit=50, offset=75]\u001b[0m\nLet me also check the header file to see the function declarations:\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=60, offset=20]\u001b[0m\nNow let me check the constants file:\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=30, offset=75]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inb|outb\"\u001b[90m in . \u00b7 0 matches\u001b[0m\nLet me also check how the existing code uses inb/outb and look at other parts of io.cpp:\n\u001b[0m\u2731 \u001b[0mGrep \"read_io|write_io\"\u001b[90m in . \u00b7 0 matches\u001b[0m\nLet me look for I/O functions:\n\u001b[0m\u2731 \u001b[0mGrep \"ioaddr\"\u001b[90m in . \u00b7 2 matches\u001b[0m\nLet me look for how I/O is done in the kernel:\n\u001b[0m\u2731 \u001b[0mGrep \"inputb|outputb\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.s\u001b[90m [limit=100, offset=1]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/libce.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.h\"\u001b[90m 6 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"::inb|::outb\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.s\u001b[90m [limit=100, offset=1]\u001b[0m\nLet me look at sistema.cpp to find how I/O is done:\n\u001b[0m\u2731 \u001b[0mGrep \"inb|outb\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/sysio.h\u001b[90m [limit=50, offset=1]\u001b[0m\nLet me look for I/O related code in the header files:\n\u001b[0m\u2731 \u001b[0mGrep \"trojan|access\"\u001b[90m in . \u00b7 27 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"\"libce.h\"\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#include.*libce\"\u001b[90m in . \u00b7 6 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.h\"\u001b[90m 6 matches\u001b[0m\nLet me check how I/O port operations are done:\n\u001b[0m\u2731 \u001b[0mGrep \"\\bin\\b|\\bout\\b\"\u001b[90m in . \u00b7 155 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"\\binput\\b|\\boutput\\b\"\u001b[90m in . \u00b7 10 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"read|write\"\u001b[90m in io \u00b7 63 matches\u001b[0m\nNow I can see that `c_ceread_n` is called. Let me search for it:\n\u001b[0m\u2731 \u001b[0mGrep \"c_ceread_n|c_ceasyncread\"\u001b[90m in . \u00b7 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.s\u001b[90m [limit=30, offset=280]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=100, offset=660]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/lib.h\u001b[90m [limit=100, offset=1]\u001b[0m\nLet me check what functions are available in the user library for I/O:\n\u001b[0m\u2192 \u001b[0mRead Makefile\u001b[90m [limit=100, offset=1]\u001b[0m\nLet me check the Makefile to understand how the build works:\nNow let me try to compile to see the current errors:\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1 | head -80\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\nld: io/io_s.o: in function `a_ceasyncread_n':\n/work/es2/nucleo/io/io.s:293:(.text+0x20e): undefined reference to `c_ceasyncread_n'\n/work/es2/nucleo/io/io.s:293:(.text+0x20e): relocation truncated to fit: R_X86_64_PLT32 against undefined symbol `c_ceasyncread_n'\nmake: *** [Makefile:142: debug/1-io] Error 1\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /usr/include/libce* 2>/dev/null || ls -la /usr/local/include/libce* 2>/dev/null || find /usr -name \"libce.h\" 2>/dev/null\n\u001b[0m\n\u001b[0m$ \u001b[0mecho $LIBCECONF\n\u001b[0m\n\u001b[0m$ \u001b[0mwhich compile\n/home/vscode/CE/bin/compile\n\u001b[0m\n\u001b[0m$ \u001b[0mcat /home/vscode/CE/bin/compile | head -20\n#!/bin/bash\n# Script per compilare programmi 'bare' da caricare nella macchina QEMU.\n#\n# Lo script compila, con parametri opportuni, tutti i file c++ e assembly\n# contenuti nella directory corrente.  Se non ci sono errori, genera i seguenti\n# file:\n#\n# - boot/0-a.out:\tversione pronta per il caricamento (script boot)\n# - debug/0-aout:\tversione usata dal debugger (script debug)\n#\n# Le directory boot e debug vengono create se non esistono gi\u00e0.\n#\n# Lo script accetta un argomento opzionale, che viene usato come nome del file\n# al posto di a.out; per es., se l'argomento \u00e8 hello, lo script crea i file\n# boot/0-hello e debug/0-hello.  Inoltre, se 'argomento \u00e8 il nome di una\n# directory esistente, i file sorgenti vengono cercati in quella directory,\n# invece che nella directory corrente.\n\n\n# Includiamo il file di configurazione di libce.  Il file contiene la\n\u001b[0m\n\u001b[0m$ \u001b[0msource /home/vscode/CE/bin/compile && echo \"CE_INCLUDE: $CE_INCLUDE, CE_LIB64: $CE_LIB64\"\n[compile] ==> Collego  debug/0-a.out [0x200000]\nld: cannot find *.o: No such file or directory\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /home/vscode/CE/\ntotal 4\ndrwxr-xr-x. 1 vscode vscode  50 Feb 15 16:10 .\ndrwxr-x---. 1 vscode vscode  46 Feb 15 16:46 ..\ndrwxr-xr-x. 1 vscode vscode 220 Feb 15 16:10 bin\ndrwxr-xr-x. 1 vscode vscode  20 Feb 15 16:09 etc\ndrwxr-xr-x. 1 vscode vscode  76 Feb 15 16:10 include\ndrwxr-xr-x. 1 vscode vscode  32 Feb 15 16:10 lib\ndrwxr-xr-x. 1 vscode vscode   4 Feb 15 16:09 lib64\ndrwxr-xr-x. 1 vscode vscode  36 Feb 15 16:10 libexec\ndrwxr-xr-x. 1 vscode vscode  54 Feb 15 16:10 share\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /home/vscode/CE/include/\ntotal 120\ndrwxr-xr-x. 1 vscode vscode    76 Feb 15 16:10 .\ndrwxr-xr-x. 1 vscode vscode    50 Feb 15 16:10 ..\ndrwxr-xr-x. 1 vscode vscode    60 Feb 15 16:09 ce\n-rw-r--r--. 1 vscode vscode  1761 Feb 15 16:10 fdt.h\n-rw-r--r--. 1 vscode vscode 75652 Feb 15 16:10 libfdt.h\n-rw-r--r--. 1 vscode vscode  2753 Feb 15 16:10 libfdt_env.h\n-rw-r--r--. 1 vscode vscode 33251 Feb 24  2025 qemu-plugin.h\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /home/vscode/CE/include/ce/\ntotal 80\ndrwxr-xr-x. 1 vscode vscode    60 Feb 15 16:09 .\ndrwxr-xr-x. 1 vscode vscode    76 Feb 15 16:10 ..\n-r--r--r--. 1 vscode vscode  1640 Feb 15 16:09 boot.h\n-r--r--r--. 1 vscode vscode   515 Feb 15 16:09 cfi.h\n-r--r--r--. 1 vscode vscode  1034 Feb 15 16:09 iostream\n-r--r--r--. 1 vscode vscode 43797 Feb 15 16:09 libce.h\n-r--r--r--. 1 vscode vscode 22137 Feb 15 16:09 vm.h\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inb|outb|read.*port|write.*port\"\u001b[90m in ../../../home/vscode/CE/include/ce \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"input|output\"\u001b[90m in ../../../home/vscode/CE/include/ce \u00b7 12 matches\u001b[0m\nNow I understand. I need to implement `c_ceasyncread_n` and `estern_ce`. Let me first check the user code to understand the test expectations:\n\u001b[0m\u2731 \u001b[0mGrep \"ceasyncread|cewait\"\u001b[90m in . \u00b7 36 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=120, offset=1]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"utente_cond|UTN\"\u001b[90m in . \u00b7 21 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=60, offset=120]\u001b[0m\nLet me look at how access is used to verify buffers:\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=20, offset=1]\u001b[0m\nNow I understand the requirements. Let me implement the solution:\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=20, offset=666]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -668,8 +668,61 @@\n /// Indice del prossimo descrittore di periferica CE disponibile\n natl next_ce;\n \n // ( SOLUZIONE 2025-09-10\n+extern \"C\" natl c_ceasyncread_n(natl id, char *buf, natl quanti)\n+{\n+\tif (id >= next_ce) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: ce non riconosciuto: %u\", id);\n+\t\tabort_p();\n+\t}\n+\n+\tif (quanti == 0) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: quanti = 0\");\n+\t\tabort_p();\n+\t}\n+\n+\tif (!buf) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: buf nullo\");\n+\t\tabort_p();\n+\t}\n+\n+\tif (!access(buf, quanti, true, false)) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: parametri non validi: %p, %u\", buf, quanti);\n+\t\tabort_p();\n+\t}\n+\n+\tdes_ce *ce = &array_ce[id];\n+\tsem_wait(ce->mutex);\n+\n+\tnatl trid = 0xFFFFFFFF;\n+\tfor (int i = 0; i < MAX_CE_ASYNC; i++) {\n+\t\tif (ce->tr[i].buf == nullptr) {\n+\t\t\ttrid = i;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (trid == 0xFFFFFFFF) {\n+\t\tsem_signal(ce->mutex);\n+\t\treturn 0xFFFFFFFF;\n+\t}\n+\n+\tdes_ce_tr *t = &ce->tr[trid];\n+\tt->buf = buf;\n+\tt->quanti = quanti;\n+\tt->next = 0xFFFFFFFF;\n+\n+\tif (ce->cur == 0xFFFFFFFF) {\n+\t\tce->cur = trid;\n+\t} else {\n+\t\tce->tr[ce->last].next = trid;\n+\t}\n+\tce->last = trid;\n+\n+\tsem_signal(ce->mutex);\n+\treturn trid;\n+}\n //   SOLUZIONE 2025-09-10 )\n \n extern \"C\" void c_cewait(natl id, natl trid)\n {\n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=30, offset=725]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=30, offset=755]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -757,8 +757,42 @@\n /// Corpo del processo esterno delle periferiche CE\n extern \"C\" void estern_ce(natq id)\n {\n // ( SOLUZIONE 2025-09-10\n+\tdes_ce *ce = &array_ce[id];\n+\n+\twhile (true) {\n+\t\twfi();\n+\n+\t\tsem_wait(ce->mutex);\n+\n+\t\twhile (ce->cur != 0xFFFFFFFF) {\n+\t\t\tdes_ce_tr *t = &ce->tr[ce->cur];\n+\n+\t\t\tif (t->quanti > 0) {\n+\t\t\t\tchar byte = inputb(ce->iRBR);\n+\t\t\t\t*t->buf++ = byte;\n+\t\t\t\tt->quanti--;\n+\t\t\t}\n+\n+\t\t\tif (t->quanti == 0) {\n+\t\t\t\tnatl old_cur = ce->cur;\n+\t\t\t\tce->cur = t->next;\n+\t\t\t\tt->next = 0xFFFFFFFF;\n+\n+\t\t\t\tif (ce->waiting > 0) {\n+\t\t\t\t\tce->waiting--;\n+\t\t\t\t\tsem_signal(ce->sync);\n+\t\t\t\t} else {\n+\t\t\t\t\tt->buf = nullptr;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tsem_signal(ce->mutex);\n+\t}\n //   SOLUZIONE 2025-09-10 )\n }\n \n /// @brief Trova le periferiche CE installate e crea i rispettivi processi esterni\n\n\u001b[0m\nNow let me compile the code:\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[make] ==> Compilo  io/io.cpp\nio/io.cpp: In function 'void estern_ce(natq)':\nio/io.cpp:778:38: warning: unused variable 'old_cur' [-Wunused-variable]\n  778 |                                 natl old_cur = ce->cur;\n      |                                      ^~~~~~~\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | head -100\nce1: opening ce1.out...OK (16)\nce1: opening ce1.in...OK (17)\ninit async\nce2: opening ce2.out...OK (18)\nce2: opening ce2.in...bars...\t\t\nOK (19)\ninit async\nbars...\t\t\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=116b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   67a2 memsize   67a2\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   2ef4 memsize   2ef4\nINF\t-\t  . seg[3]: off   a000 vaddr           20a000 size    180 memsize  17404\nINF\t-\t- mod[1]: start=117000 end=11e590 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   43d7 memsize   43d7\nINF\t-\t  . seg[2]: off   5000 vaddr      10000005000 size   1c94 memsize   1c94\nINF\t-\t  . seg[3]: off   7000 vaddr      10000007000 size    1a8 memsize    840\nINF\t-\t- mod[2]: start=11f000 end=1235c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2acf memsize   2acf\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d8c memsize    d8c\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1d8 memsize    310\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   67a2 byte da   10c000 a   200000\nINF\t-\t- copiati   2ef4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   116000 a   20a000\nINF\t-\t- azzerati ulteriori 17284 byte\nINF\t-\t- entry point 2055c7\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 546 (M1) 7646 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000005000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000005000,      10000007000)\nINF\t0\t - segmento sistema read/write mappato a [     10000007000,      10000008000)\nINF\t0\t - heap:                                 [     10000008000,      10000108000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7115 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000008000, 0x10000108000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\testern=4 entry=estern_ce [io.cpp:759](0) prio=1136 (tipo=70) liv=0 irq=11\nINF\t1\tce0: 00:03.0 base=c014 IRQ=11\nINF\t1\testern=5 entry=estern_ce [io.cpp:759](1) prio=1137 (tipo=71) liv=0 irq=10\nINF\t1\tce1: 00:04.0 base=c024 IRQ=10\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t6\tHeap del modulo utente: 100000B [0xffff800000004310, 0xffff800000104310)\nINF\t6\tproc=7 entry=main_body(unsigned long) [utente.cpp:233](0) prio=900 liv=3\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t7\tproc=8 entry=t00p0b(unsigned long) [utente.cpp:74](0) prio=600 liv=3\nINF\t7\tproc=9 entry=t00p1b(unsigned long) [utente.cpp:81](0) prio=599 liv=3\nINF\t7\tproc=10 entry=t00p2b(unsigned long) [utente.cpp:88](0) prio=598 liv=3\nINF\t7\tproc=11 entry=t00p3b(unsigned long) [utente.cpp:95](0) prio=597 liv=3\nINF\t7\tproc=12 entry=t00p4b(unsigned long) [utente.cpp:102](0) prio=596 liv=3\nWRN\t8\tceasyncread_n: ce non riconosciuto: 2\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=              25 RBX=            13a0 RCX=               0 RDX=              25\nWRN\t8\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t8\t  R8 =              32 R9 =      fffffffe65 R10=               0 R11=               0\nWRN\t8\t  R12=               a R13=ffff8000000042d0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > a_abort_p [sistema.s:311]\nWRN\t8\t  > abort_p [io.s:108]\nWRN\t8\t  > c_ceasyncread_n [io.cpp:676]\nWRN\t8\t  > a_ceasyncread_n [io.s:293]\nWRN\t8\t  > ceasyncread_n [utente.s:147]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\tceasyncread_n: quanti = 0\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | grep \"USR\"\nUSR\t12\tTEST 0 PROC 12: ERRORE: ceasyncread_n con argomenti non validi non ha causato abort\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=20, offset=100]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=695]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=60, offset=675]\u001b[0m\nI need to fix the access call - the buffer must be in the user shared area:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -685,9 +685,9 @@\n \tflog(LOG_WARN, \"ceasyncread_n: buf nullo\");\n \tabort_p();\n }\n \n-if (!access(buf, quanti, true, false)) {\n+if (!access(buf, quanti, true)) {\n \tflog(LOG_WARN, \"ceasyncread_n: parametri non validi: %p, %u\", buf, quanti);\n \tabort_p();\n }\n \n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[make] ==> Compilo  io/io.cpp\nio/io.cpp: In function 'void estern_ce(natq)':\nio/io.cpp:778:38: warning: unused variable 'old_cur' [-Wunused-variable]\n  778 |                                 natl old_cur = ce->cur;\n      |                                      ^~~~~~~\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | grep \"USR\"\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | tail -80\nDBG\t7\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t7\tproc=8 entry=t00p0b(unsigned long) [utente.cpp:74](0) prio=600 liv=3\nINF\t7\tproc=9 entry=t00p1b(unsigned long) [utente.cpp:81](0) prio=599 liv=3\nINF\t7\tproc=10 entry=t00p2b(unsigned long) [utente.cpp:88](0) prio=598 liv=3\nINF\t7\tproc=11 entry=t00p3b(unsigned long) [utente.cpp:95](0) prio=597 liv=3\nINF\t7\tproc=12 entry=t00p4b(unsigned long) [utente.cpp:102](0) prio=596 liv=3\nWRN\t8\tceasyncread_n: ce non riconosciuto: 2\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=              25 RBX=            13a0 RCX=               0 RDX=              25\nWRN\t8\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t8\t  R8 =              32 R9 =      fffffffe65 R10=               0 R11=               0\nWRN\t8\t  R12=               a R13=ffff8000000042d0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > a_abort_p [sistema.s:311]\nWRN\t8\t  > abort_p [io.s:108]\nWRN\t8\t  > c_ceasyncread_n [io.cpp:676]\nWRN\t8\t  > a_ceasyncread_n [io.s:293]\nWRN\t8\t  > ceasyncread_n [utente.s:147]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\tceasyncread_n: quanti = 0\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=              19 RBX=            1820 RCX=               0 RDX=              19\nWRN\t9\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t9\t  R8 =              30 R9 =      fffffffe59 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=ffff8000000042d0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > a_abort_p [sistema.s:311]\nWRN\t9\t  > abort_p [io.s:108]\nWRN\t9\t  > c_ceasyncread_n [io.cpp:681]\nWRN\t9\t  > a_ceasyncread_n [io.s:293]\nWRN\t9\t  > ceasyncread_n [utente.s:147]\nWRN\t9\tProcesso 9 abortito\nWRN\t10\tceasyncread_n: buf nullo\nWRN\t10\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t10\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t10\t  RAX=              18 RBX=            18e0 RCX=               0 RDX=              18\nWRN\t10\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t10\t  R8 =              6f R9 =      fffffffe58 R10=               0 R11=               0\nWRN\t10\t  R12=               a R13=               0 R14=               0 R15=               0\nWRN\t10\t  backtrace:\nWRN\t10\t  > a_abort_p [sistema.s:311]\nWRN\t10\t  > abort_p [io.s:108]\nWRN\t10\t  > c_ceasyncread_n [io.cpp:686]\nWRN\t10\t  > a_ceasyncread_n [io.s:293]\nWRN\t10\t  > ceasyncread_n [utente.s:147]\nWRN\t10\tProcesso 10 abortito\nWRN\t11\tceasyncread_n: parametri non validi:  [utente.cpp:71], 10\nWRN\t11\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t11\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t11\t  RAX=              3b RBX=            19a0 RCX=               0 RDX=              3b\nWRN\t11\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t11\t  R8 =              30 R9 =      fffffffe7b R10=               0 R11=               0\nWRN\t11\t  R12=               a R13=ffff800000003000 R14=               0 R15=               0\nWRN\t11\t  backtrace:\nWRN\t11\t  > a_abort_p [sistema.s:311]\nWRN\t11\t  > abort_p [io.s:108]\nWRN\t11\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t11\t  > a_ceasyncread_n [io.s:293]\nWRN\t11\t  > ceasyncread_n [utente.s:147]\nWRN\t11\tProcesso 11 abortito\nWRN\t12\tceasyncread_n: parametri non validi: 0xffffffffffffffd6, 10\nWRN\t12\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t12\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t12\t  RAX=              3b RBX=            1a60 RCX=               0 RDX=              3b\nWRN\t12\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t12\t  R8 =              30 R9 =      fffffffe7b R10=               0 R11=               0\nWRN\t12\t  R12=               a R13=ffffffffffffffd6 R14=               0 R15=               0\nWRN\t12\t  backtrace:\nWRN\t12\t  > a_abort_p [sistema.s:311]\nWRN\t12\t  > abort_p [io.s:108]\nWRN\t12\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t12\t  > a_ceasyncread_n [io.s:293]\nWRN\t12\t  > ceasyncread_n [utente.s:147]\nWRN\t12\tProcesso 12 abortito\nDBG\t7\tTEST 0: === FINE ===\nDBG\t7\tTEST 1: >>>INIZIO<<<: caso base\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\nqemu-system-x86_64: terminating on signal 15 from pid 1636 (timeout)\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 20s boot 2>&1 | grep -E \"(TEST|proc|ce|ERRORE|USR)\"\nce1: opening ce1.out...OK (16)\nce1: opening ce1.in...OK (17)\nce2: opening ce2.out...OK (18)\nce2: opening ce2.in...OK (19)\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tCreo il processo main I/O\nINF\t1\testern=4 entry=estern_ce [io.cpp:759](0) prio=1136 (tipo=70) liv=0 irq=11\nINF\t1\tce0: 00:03.0 base=c014 IRQ=11\nINF\t1\testern=5 entry=estern_ce [io.cpp:759](1) prio=1137 (tipo=71) liv=0 irq=10\nINF\t1\tce1: 00:04.0 base=c024 IRQ=10\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t6\tproc=7 entry=main_body(unsigned long) [utente.cpp:233](0) prio=900 liv=3\nINF\t6\tProcesso 6 terminato\nDBG\t7\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t7\tproc=8 entry=t00p0b(unsigned long) [utente.cpp:74](0) prio=600 liv=3\nINF\t7\tproc=9 entry=t00p1b(unsigned long) [utente.cpp:81](0) prio=599 liv=3\nINF\t7\tproc=10 entry=t00p2b(unsigned long) [utente.cpp:88](0) prio=598 liv=3\nINF\t7\tproc=11 entry=t00p3b(unsigned long) [utente.cpp:95](0) prio=597 liv=3\nINF\t7\tproc=12 entry=t00p4b(unsigned long) [utente.cpp:102](0) prio=596 liv=3\nWRN\t8\tceasyncread_n: ce non riconosciuto: 2\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_ceasyncread_n [io.cpp:676]\nWRN\t8\t  > a_ceasyncread_n [io.s:293]\nWRN\t8\t  > ceasyncread_n [utente.s:147]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\tceasyncread_n: quanti = 0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_ceasyncread_n [io.cpp:681]\nWRN\t9\t  > a_ceasyncread_n [io.s:293]\nWRN\t9\t  > ceasyncread_n [utente.s:147]\nWRN\t9\tProcesso 9 abortito\nWRN\t10\tceasyncread_n: buf nullo\nWRN\t10\t  backtrace:\nWRN\t10\t  > c_ceasyncread_n [io.cpp:686]\nWRN\t10\t  > a_ceasyncread_n [io.s:293]\nWRN\t10\t  > ceasyncread_n [utente.s:147]\nWRN\t10\tProcesso 10 abortito\nWRN\t11\tceasyncread_n: parametri non validi:  [utente.cpp:71], 10\nWRN\t11\t  backtrace:\nWRN\t11\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t11\t  > a_ceasyncread_n [io.s:293]\nWRN\t11\t  > ceasyncread_n [utente.s:147]\nWRN\t11\tProcesso 11 abortito\nWRN\t12\tceasyncread_n: parametri non validi: 0xffffffffffffffd6, 10\nWRN\t12\t  backtrace:\nWRN\t12\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t12\t  > a_ceasyncread_n [io.s:293]\nWRN\t12\t  > ceasyncread_n [utente.s:147]\nWRN\t12\tProcesso 12 abortito\nDBG\t7\tTEST 0: === FINE ===\nDBG\t7\tTEST 1: >>>INIZIO<<<: caso base\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead ce1.pl\u001b[90m [limit=50, offset=1]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead ce1.pl\u001b[90m [limit=100, offset=50]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=40, offset=765]\u001b[0m\nI see the issue. Looking at the device simulation, I need to enable interrupts on the device. Let me check how the PCI BAR addresses work:\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=50, offset=800]\u001b[0m\nLooking at the device simulation, I need to enable interrupts on the device. Let me check the ce_init function and add the interrupt enable:\nI need to enable interrupts on the device. Let me add that to ce_init (which is in the ESAME section but needs the interrupt enable):\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -813,8 +813,9 @@\n base &= ~0x1;\n ce->iCTL = base;\n ce->iSTS = base + 4;\n ce->iRBR = base + 8;\n+outputb(1, ce->iCTL);\n ce->cur = 0xFFFFFFFF;\n ce->last = 0xFFFFFFFF;\n for (int i = 0; i < MAX_CE_ASYNC; i++) {\n \tce->tr[i].buf = nullptr;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[make] ==> Compilo  io/io.cpp\nio/io.cpp: In function 'void estern_ce(natq)':\nio/io.cpp:778:38: warning: unused variable 'old_cur' [-Wunused-variable]\n  778 |                                 natl old_cur = ce->cur;\n      |                                      ^~~~~~~\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 20s boot 2>&1 | grep -E \"(TEST|proc|ERRORE|USR|ce0|ce1)\"\nce1: opening ce1.out...OK (16)\nce1: opening ce1.in...OK (17)\nINF\t0\tCreo il processo main I/O\nINF\t1\tce0: 00:03.0 base=c014 IRQ=11\nINF\t1\tce1: 00:04.0 base=c024 IRQ=10\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t6\tproc=7 entry=main_body(unsigned long) [utente.cpp:233](0) prio=900 liv=3\nDBG\t7\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t7\tproc=8 entry=t00p0b(unsigned long) [utente.cpp:74](0) prio=600 liv=3\nINF\t7\tproc=9 entry=t00p1b(unsigned long) [utente.cpp:81](0) prio=599 liv=3\nINF\t7\tproc=10 entry=t00p2b(unsigned long) [utente.cpp:88](0) prio=598 liv=3\nINF\t7\tproc=11 entry=t00p3b(unsigned long) [utente.cpp:95](0) prio=597 liv=3\nINF\t7\tproc=12 entry=t00p4b(unsigned long) [utente.cpp:102](0) prio=596 liv=3\nDBG\t7\tTEST 0: === FINE ===\nDBG\t7\tTEST 1: >>>INIZIO<<<: caso base\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 30s boot 2>&1 | tail -60\nWRN\t9\tceasyncread_n: quanti = 0\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=              19 RBX=            1820 RCX=               0 RDX=              19\nWRN\t9\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t9\t  R8 =              30 R9 =      fffffffe59 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=ffff8000000042d0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > a_abort_p [sistema.s:311]\nWRN\t9\t  > abort_p [io.s:108]\nWRN\t9\t  > c_ceasyncread_n [io.cpp:681]\nWRN\t9\t  > a_ceasyncread_n [io.s:293]\nWRN\t9\t  > ceasyncread_n [utente.s:147]\nWRN\t9\tProcesso 9 abortito\nWRN\t10\tceasyncread_n: buf nullo\nWRN\t10\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t10\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t10\t  RAX=              18 RBX=            18e0 RCX=               0 RDX=              18\nWRN\t10\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t10\t  R8 =              6f R9 =      fffffffe58 R10=               0 R11=               0\nWRN\t10\t  R12=               a R13=               0 R14=               0 R15=               0\nWRN\t10\t  backtrace:\nWRN\t10\t  > a_abort_p [sistema.s:311]\nWRN\t10\t  > abort_p [io.s:108]\nWRN\t10\t  > c_ceasyncread_n [io.cpp:686]\nWRN\t10\t  > a_ceasyncread_n [io.s:293]\nWRN\t10\t  > ceasyncread_n [utente.s:147]\nWRN\t10\tProcesso 10 abortito\nWRN\t11\tceasyncread_n: parametri non validi:  [utente.cpp:71], 10\nWRN\t11\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t11\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t11\t  RAX=              3b RBX=            19a0 RCX=               0 RDX=              3b\nWRN\t11\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t11\t  R8 =              30 R9 =      fffffffe7b R10=               0 R11=               0\nWRN\t11\t  R12=               a R13=ffff800000003000 R14=               0 R15=               0\nWRN\t11\t  backtrace:\nWRN\t11\t  > a_abort_p [sistema.s:311]\nWRN\t11\t  > abort_p [io.s:108]\nWRN\t11\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t11\t  > a_ceasyncread_n [io.s:293]\nWRN\t11\t  > ceasyncread_n [utente.s:147]\nWRN\t11\tProcesso 11 abortito\nWRN\t12\tceasyncread_n: parametri non validi: 0xffffffffffffffd6, 10\nWRN\t12\t  RIP=c_abort_p [sistema.cpp:1184] CPL=LIV_SISTEMA\nWRN\t12\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t12\t  RAX=              3b RBX=            1a60 RCX=               0 RDX=              3b\nWRN\t12\t  RDI=               2 RSI=      fffffffe40 RBP=      ffffffff68 RSP=      ffffffff60\nWRN\t12\t  R8 =              30 R9 =      fffffffe7b R10=               0 R11=               0\nWRN\t12\t  R12=               a R13=ffffffffffffffd6 R14=               0 R15=               0\nWRN\t12\t  backtrace:\nWRN\t12\t  > a_abort_p [sistema.s:311]\nWRN\t12\t  > abort_p [io.s:108]\nWRN\t12\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t12\t  > a_ceasyncread_n [io.s:293]\nWRN\t12\t  > ceasyncread_n [utente.s:147]\nWRN\t12\tProcesso 12 abortito\nDBG\t7\tTEST 0: === FINE ===\nDBG\t7\tTEST 1: >>>INIZIO<<<: caso base\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\nqemu-system-x86_64: terminating on signal 15 from pid 2298 ()\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"outputb|inputb\"\u001b[90m in io \u00b7 2 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"wfi\"\u001b[90m in io \u00b7 5 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=60, offset=230]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=40, offset=190]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead ce1.pl\u001b[90m [limit=40, offset=105]\u001b[0m\nLet me check how priorities work:\n\u001b[0m\u2731 \u001b[0mGrep \"MIN_EXT_PRIO\"\u001b[90m in . \u00b7 9 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead ../../../home/vscode/CE/include/ce/libce.h\u001b[90m [limit=30, offset=475]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=30, offset=115]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | grep -E \"(estern|ce0|ce1|proc.*13)\"\nce1: opening ce1.out...OK (16)\nce1: opening ce1.in...OK (17)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\testern=4 entry=estern_ce [io.cpp:759](0) prio=1136 (tipo=70) liv=0 irq=11\nINF\t1\tce0: 00:03.0 base=c014 IRQ=11\nINF\t1\testern=5 entry=estern_ce [io.cpp:759](1) prio=1137 (tipo=71) liv=0 irq=10\nINF\t1\tce1: 00:04.0 base=c024 IRQ=10\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\n\u001b[0m\nLet me try moving the interrupt enable after the external process is created:\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -813,9 +813,8 @@\n base &= ~0x1;\n ce->iCTL = base;\n ce->iSTS = base + 4;\n ce->iRBR = base + 8;\n-outputb(1, ce->iCTL);\n ce->cur = 0xFFFFFFFF;\n ce->last = 0xFFFFFFFF;\n for (int i = 0; i < MAX_CE_ASYNC; i++) {\n \tce->tr[i].buf = nullptr;\n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=30, offset=825]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -832,8 +832,9 @@\n \tif (activate_pe(estern_ce, next_ce, MIN_EXT_PRIO + INTR_TIPO_CE + next_ce, LIV_SISTEMA, irq) == 0xFFFFFFFF) {\n \t\tflog(LOG_WARN, \"ce%d: impossibile attivare processo esterno\", next_ce);\n \t\tbreak;\n \t}\n+\toutputb(1, ce->iCTL);\n \tflog(LOG_INFO, \"ce%d: %02x:%02x.%1x base=%04x IRQ=%d\", next_ce, bus, dev, fun, ce->iSTS, irq);\n \tnext_ce++;\n }\n return next_ce != 0;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[make] ==> Compilo  io/io.cpp\nio/io.cpp: In function 'void estern_ce(natq)':\nio/io.cpp:778:38: warning: unused variable 'old_cur' [-Wunused-variable]\n  778 |                                 natl old_cur = ce->cur;\n      |                                      ^~~~~~~\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 20s boot 2>&1 | grep -E \"(TEST|ERRORE|USR)\"\nDBG\t7\tTEST 0: >>>INIZIO<<<: errori vari\nDBG\t7\tTEST 0: === FINE ===\nDBG\t7\tTEST 1: >>>INIZIO<<<: caso base\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=40, offset=758]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 20s boot 2>&1 | grep -E \"(ce|irq|IRQ|proc)\"\nce1: opening ce1.out...OK (16)\nce1: opening ce1.in...OK (17)\nce2: opening ce2.out...OK (18)\nce2: opening ce2.in...bars...\t\t\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tCreo il processo main I/O\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\testern=4 entry=estern_ce [io.cpp:759](0) prio=1136 (tipo=70) liv=0 irq=11\nINF\t1\tce0: 00:03.0 base=c014 IRQ=11\nINF\t1\testern=5 entry=estern_ce [io.cpp:759](1) prio=1137 (tipo=71) liv=0 irq=10\nINF\t1\tce1: 00:04.0 base=c024 IRQ=10\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t6\tproc=7 entry=main_body(unsigned long) [utente.cpp:233](0) prio=900 liv=3\nINF\t6\tProcesso 6 terminato\nINF\t7\tproc=8 entry=t00p0b(unsigned long) [utente.cpp:74](0) prio=600 liv=3\nINF\t7\tproc=9 entry=t00p1b(unsigned long) [utente.cpp:81](0) prio=599 liv=3\nINF\t7\tproc=10 entry=t00p2b(unsigned long) [utente.cpp:88](0) prio=598 liv=3\nINF\t7\tproc=11 entry=t00p3b(unsigned long) [utente.cpp:95](0) prio=597 liv=3\nINF\t7\tproc=12 entry=t00p4b(unsigned long) [utente.cpp:102](0) prio=596 liv=3\nWRN\t8\tceasyncread_n: ce non riconosciuto: 2\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_ceasyncread_n [io.cpp:676]\nWRN\t8\t  > a_ceasyncread_n [io.s:293]\nWRN\t8\t  > ceasyncread_n [utente.s:147]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\tceasyncread_n: quanti = 0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_ceasyncread_n [io.cpp:681]\nWRN\t9\t  > a_ceasyncread_n [io.s:293]\nWRN\t9\t  > ceasyncread_n [utente.s:147]\nWRN\t9\tProcesso 9 abortito\nWRN\t10\tceasyncread_n: buf nullo\nWRN\t10\t  backtrace:\nWRN\t10\t  > c_ceasyncread_n [io.cpp:686]\nWRN\t10\t  > a_ceasyncread_n [io.s:293]\nWRN\t10\t  > ceasyncread_n [utente.s:147]\nWRN\t10\tProcesso 10 abortito\nWRN\t11\tceasyncread_n: parametri non validi:  [utente.cpp:71], 10\nWRN\t11\t  backtrace:\nWRN\t11\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t11\t  > a_ceasyncread_n [io.s:293]\nWRN\t11\t  > ceasyncread_n [utente.s:147]\nWRN\t11\tProcesso 11 abortito\nWRN\t12\tceasyncread_n: parametri non validi: 0xffffffffffffffd6, 10\nWRN\t12\t  backtrace:\nWRN\t12\t  > c_ceasyncread_n [io.cpp:691]\nWRN\t12\t  > a_ceasyncread_n [io.s:293]\nWRN\t12\t  > ceasyncread_n [utente.s:147]\nWRN\t12\tProcesso 12 abortito\nINF\t7\tproc=13 entry=t01p0b(unsigned long) [utente.cpp:118](1) prio=595 liv=3\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=30, offset=810]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"LIV_SISTEMA|LIV_UTENTE\"\u001b[90m in . \u00b7 79 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"wfi:\"\u001b[90m in . \u00b7 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.s\u001b[90m [limit=20, offset=95]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"TIPO_WFI|a_wfi\"\u001b[90m in . \u00b7 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.s\u001b[90m [limit=20, offset=450]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"driver_td|activate_pe\"\u001b[90m in sistema \u00b7 21 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=345]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inspronti\"\u001b[90m in sistema \u00b7 28 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=108]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"terminate_p\"\u001b[90m in . \u00b7 37 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead io/io.cpp\u001b[90m [limit=40, offset=725]\u001b[0m\nLet me check the exam spec again. It says bit 1 enables interrupts. Let me try using value 2:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -832,9 +832,9 @@\n \tif (activate_pe(estern_ce, next_ce, MIN_EXT_PRIO + INTR_TIPO_CE + next_ce, LIV_SISTEMA, irq) == 0xFFFFFFFF) {\n \t\tflog(LOG_WARN, \"ce%d: impossibile attivare processo esterno\", next_ce);\n \t\tbreak;\n \t}\n-\toutputb(1, ce->iCTL);\n+\toutputb(2, ce->iCTL);\n \tflog(LOG_INFO, \"ce%d: %02x:%02x.%1x base=%04x IRQ=%d\", next_ce, bus, dev, fun, ce->iSTS, irq);\n \tnext_ce++;\n }\n return next_ce != 0;\n\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit io/io.cpp\nIndex: /work/es2/nucleo/io/io.cpp\n===================================================================\n--- /work/es2/nucleo/io/io.cpp\n+++ /work/es2/nucleo/io/io.cpp\n@@ -832,9 +832,9 @@\n \tif (activate_pe(estern_ce, next_ce, MIN_EXT_PRIO + INTR_TIPO_CE + next_ce, LIV_SISTEMA, irq) == 0xFFFFFFFF) {\n \t\tflog(LOG_WARN, \"ce%d: impossibile attivare processo esterno\", next_ce);\n \t\tbreak;\n \t}\n-\toutputb(2, ce->iCTL);\n+\toutputb(1, ce->iCTL);\n \tflog(LOG_INFO, \"ce%d: %02x:%02x.%1x base=%04x IRQ=%d\", next_ce, bus, dev, fun, ce->iSTS, irq);\n \tnext_ce++;\n }\n return next_ce != 0;\n\n\u001b[0m\n\u001b[93m\u001b[1m! \u001b[0m maximum turns of 100 reached, stopping session\n",
  "duration_seconds": 745.23,
  "turns": 100,
  "max_turns": 100,
  "diff": "diff --git a/io/io.cpp b/io/io.cpp\nindex 85f414f..dfc3781 100644\n--- a/io/io.cpp\n+++ b/io/io.cpp\n@@ -669,6 +669,59 @@ des_ce array_ce[MAX_CE];\n natl next_ce;\n \n // ( SOLUZIONE 2025-09-10\n+extern \"C\" natl c_ceasyncread_n(natl id, char *buf, natl quanti)\n+{\n+\tif (id >= next_ce) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: ce non riconosciuto: %u\", id);\n+\t\tabort_p();\n+\t}\n+\n+\tif (quanti == 0) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: quanti = 0\");\n+\t\tabort_p();\n+\t}\n+\n+\tif (!buf) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: buf nullo\");\n+\t\tabort_p();\n+\t}\n+\n+\tif (!access(buf, quanti, true)) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: parametri non validi: %p, %u\", buf, quanti);\n+\t\tabort_p();\n+\t}\n+\n+\tdes_ce *ce = &array_ce[id];\n+\tsem_wait(ce->mutex);\n+\n+\tnatl trid = 0xFFFFFFFF;\n+\tfor (int i = 0; i < MAX_CE_ASYNC; i++) {\n+\t\tif (ce->tr[i].buf == nullptr) {\n+\t\t\ttrid = i;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (trid == 0xFFFFFFFF) {\n+\t\tsem_signal(ce->mutex);\n+\t\treturn 0xFFFFFFFF;\n+\t}\n+\n+\tdes_ce_tr *t = &ce->tr[trid];\n+\tt->buf = buf;\n+\tt->quanti = quanti;\n+\tt->next = 0xFFFFFFFF;\n+\n+\tif (ce->cur == 0xFFFFFFFF) {\n+\t\tce->cur = trid;\n+\t} else {\n+\t\tce->tr[ce->last].next = trid;\n+\t}\n+\tce->last = trid;\n+\n+\tsem_signal(ce->mutex);\n+\treturn trid;\n+}\n //   SOLUZIONE 2025-09-10 )\n \n extern \"C\" void c_cewait(natl id, natl trid)\n@@ -705,6 +758,40 @@ extern \"C\" void c_cewait(natl id, natl trid)\n extern \"C\" void estern_ce(natq id)\n {\n // ( SOLUZIONE 2025-09-10\n+\tdes_ce *ce = &array_ce[id];\n+\n+\twhile (true) {\n+\t\twfi();\n+\n+\t\tsem_wait(ce->mutex);\n+\n+\t\twhile (ce->cur != 0xFFFFFFFF) {\n+\t\t\tdes_ce_tr *t = &ce->tr[ce->cur];\n+\n+\t\t\tif (t->quanti > 0) {\n+\t\t\t\tchar byte = inputb(ce->iRBR);\n+\t\t\t\t*t->buf++ = byte;\n+\t\t\t\tt->quanti--;\n+\t\t\t}\n+\n+\t\t\tif (t->quanti == 0) {\n+\t\t\t\tnatl old_cur = ce->cur;\n+\t\t\t\tce->cur = t->next;\n+\t\t\t\tt->next = 0xFFFFFFFF;\n+\n+\t\t\t\tif (ce->waiting > 0) {\n+\t\t\t\t\tce->waiting--;\n+\t\t\t\t\tsem_signal(ce->sync);\n+\t\t\t\t} else {\n+\t\t\t\t\tt->buf = nullptr;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tsem_signal(ce->mutex);\n+\t}\n //   SOLUZIONE 2025-09-10 )\n }\n \n@@ -746,6 +833,7 @@ bool ce_init()\n \t\t\tflog(LOG_WARN, \"ce%d: impossibile attivare processo esterno\", next_ce);\n \t\t\tbreak;\n \t\t}\n+\t\toutputb(1, ce->iCTL);\n \t\tflog(LOG_INFO, \"ce%d: %02x:%02x.%1x base=%04x IRQ=%d\", next_ce, bus, dev, fun, ce->iSTS, irq);\n \t\tnext_ce++;\n \t}\ndiff --git a/io/io.cpp b/io/io.cpp\nindex 85f414f..dfc3781 100644\n--- a/io/io.cpp\n+++ b/io/io.cpp\n@@ -669,6 +669,59 @@ des_ce array_ce[MAX_CE];\n natl next_ce;\n \n // ( SOLUZIONE 2025-09-10\n+extern \"C\" natl c_ceasyncread_n(natl id, char *buf, natl quanti)\n+{\n+\tif (id >= next_ce) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: ce non riconosciuto: %u\", id);\n+\t\tabort_p();\n+\t}\n+\n+\tif (quanti == 0) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: quanti = 0\");\n+\t\tabort_p();\n+\t}\n+\n+\tif (!buf) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: buf nullo\");\n+\t\tabort_p();\n+\t}\n+\n+\tif (!access(buf, quanti, true)) {\n+\t\tflog(LOG_WARN, \"ceasyncread_n: parametri non validi: %p, %u\", buf, quanti);\n+\t\tabort_p();\n+\t}\n+\n+\tdes_ce *ce = &array_ce[id];\n+\tsem_wait(ce->mutex);\n+\n+\tnatl trid = 0xFFFFFFFF;\n+\tfor (int i = 0; i < MAX_CE_ASYNC; i++) {\n+\t\tif (ce->tr[i].buf == nullptr) {\n+\t\t\ttrid = i;\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (trid == 0xFFFFFFFF) {\n+\t\tsem_signal(ce->mutex);\n+\t\treturn 0xFFFFFFFF;\n+\t}\n+\n+\tdes_ce_tr *t = &ce->tr[trid];\n+\tt->buf = buf;\n+\tt->quanti = quanti;\n+\tt->next = 0xFFFFFFFF;\n+\n+\tif (ce->cur == 0xFFFFFFFF) {\n+\t\tce->cur = trid;\n+\t} else {\n+\t\tce->tr[ce->last].next = trid;\n+\t}\n+\tce->last = trid;\n+\n+\tsem_signal(ce->mutex);\n+\treturn trid;\n+}\n //   SOLUZIONE 2025-09-10 )\n \n extern \"C\" void c_cewait(natl id, natl trid)\n@@ -705,6 +758,40 @@ extern \"C\" void c_cewait(natl id, natl trid)\n extern \"C\" void estern_ce(natq id)\n {\n // ( SOLUZIONE 2025-09-10\n+\tdes_ce *ce = &array_ce[id];\n+\n+\twhile (true) {\n+\t\twfi();\n+\n+\t\tsem_wait(ce->mutex);\n+\n+\t\twhile (ce->cur != 0xFFFFFFFF) {\n+\t\t\tdes_ce_tr *t = &ce->tr[ce->cur];\n+\n+\t\t\tif (t->quanti > 0) {\n+\t\t\t\tchar byte = inputb(ce->iRBR);\n+\t\t\t\t*t->buf++ = byte;\n+\t\t\t\tt->quanti--;\n+\t\t\t}\n+\n+\t\t\tif (t->quanti == 0) {\n+\t\t\t\tnatl old_cur = ce->cur;\n+\t\t\t\tce->cur = t->next;\n+\t\t\t\tt->next = 0xFFFFFFFF;\n+\n+\t\t\t\tif (ce->waiting > 0) {\n+\t\t\t\t\tce->waiting--;\n+\t\t\t\t\tsem_signal(ce->sync);\n+\t\t\t\t} else {\n+\t\t\t\t\tt->buf = nullptr;\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\tsem_signal(ce->mutex);\n+\t}\n //   SOLUZIONE 2025-09-10 )\n }\n \n@@ -746,6 +833,7 @@ bool ce_init()\n \t\t\tflog(LOG_WARN, \"ce%d: impossibile attivare processo esterno\", next_ce);\n \t\t\tbreak;\n \t\t}\n+\t\toutputb(1, ce->iCTL);\n \t\tflog(LOG_INFO, \"ce%d: %02x:%02x.%1x base=%04x IRQ=%d\", next_ce, bus, dev, fun, ce->iSTS, irq);\n \t\tnext_ce++;\n \t}\n",
  "error": null
}