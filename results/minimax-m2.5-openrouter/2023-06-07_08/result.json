{
  "passed": false,
  "output": [
    "TEST 1: PROC 5: OK"
  ],
  "expected": [
    "TEST 1: PROC 5: OK",
    "TEST 2: PROC 5: OK",
    "TEST 3: PROC 5: OK",
    "TEST 4: PROC 5: OK",
    "TEST 5: PROC 5: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6da8 memsize   6da8\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   3074 memsize   3074\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6da8 byte da   10c000 a   200000\nINF\t-\t- copiati   3074 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 205bcd\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 7095 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000010000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1: PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nERR\t9\tPANIC: PAGE FAULT NON RISOLTO\nERR\t9\t  processi: 2\nERR\t9\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t9\tcorpo t02p0b(unsigned long) [utente.cpp:99](2), livello UTENTE, precedenza 597\nERR\t9\t  RIP=panic [sistema.cpp:1897] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=16 [-- -- -- -- -- -- -- AF PF --, IOPL=SISTEMA]\nERR\t9\t  RAX=               a RBX=               7 RCX=               0 RDX=      ffffff03f8\nERR\t9\t  RDI=               3 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nERR\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nERR\t9\t  R12=               e R13=ffff80000000034a R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > gestore_eccezioni [sistema.cpp:460]\nERR\t9\t  > exc_page_fault [sistema.s:812]\nERR\t9\t  > t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\nERR\t9\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t9\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1567](0), livello SISTEMA, precedenza 0\nERR\t9\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=          2029f2 RBX=            13a0 RCX=               0 RDX=          2203f8\nERR\t9\t  RDI=            13a0 RSI=          222230 RBP=          222300 RSP=          222220\nERR\t9\t  R8 =              30 R9 =          22205f R10=               0 R11=               0\nERR\t9\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > main [sistema.cpp:1700]\nERR\t9\t  > _start [start64.s:33]\nERR\t9\tproc 2: corpo estern_kbd(unsigned long) [io.cpp:197](0), livello SISTEMA, precedenza 1104\nERR\t9\t  RIP=estern_kbd(unsigned long) [io.cpp:197] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t9\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t9\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\tproc 3: corpo estern_hd(unsigned long) [io.cpp:557](0), livello SISTEMA, precedenza 1120\nERR\t9\t  RIP=estern_hd(unsigned long) [io.cpp:557] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t9\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t9\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\tproc 5: corpo main_body(unsigned long) [utente.cpp:170](0), livello UTENTE, precedenza 900\nERR\t9\t  RIP=sem_wait [utente.s:49] CPL=LIV_UTENTE\nERR\t9\t  RFLAGS=202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=ffff800000004188 RBX=ffff800000004180 RCX=               3 RDX=ffff800000004160\nERR\t9\t  RDI=               1 RSI=               2 RBP=fffffffffffffff0 RSP=ffffffffffffffc8\nERR\t9\t  R8 =              65 R9 =fffffffffffffe92 R10=               0 R11=               0\nERR\t9\t  R12=            1b95 R13=ffff800000004188 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > main_body(unsigned long) [utente.cpp:196]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5:nitro\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 93 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"SOLUZIONE|ESAME\"\u001b[90m 38 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/cc.h\"\u001b[90m 0 matches\u001b[0m\nLet me read the relevant sections of sistema.cpp and costanti.h:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=820]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=50, offset=105]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"DIM_USR_COW|ini_utn_w|fin_utn_w\"\u001b[90m 27 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=650]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"struct st1|class cl\"\u001b[90m in sistema \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"elab1\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.s\u001b[90m [limit=100]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"ESAME|SOLUZIONE\"\u001b[90m in sistema \u00b7 28 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"st1|cl\\(|elab\"\u001b[90m in sistema \u00b7 0 matches\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mwc -l /work/es2/nucleo/sistema/sistema.s\n1442 /work/es2/nucleo/sistema/sistema.s\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.s\u001b[90m [limit=100, offset=1340]\u001b[0m\nLet me read more of the sistema.cpp file to find all the parts needing implementation:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=380]\u001b[0m\nLet me find the cow_root and understand the memory mapping functions:\n\u001b[0m\u2731 \u001b[0mGrep \"cow_root\"\u001b[90m in . \u00b7 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=800]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\"\u001b[90m in . \u00b7 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"void copy_des\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\\(\"\u001b[90m in . \u00b7 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/libce.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"\\.h\"\u001b[90m in . \u00b7 48 matches\u001b[0m\nLet me look at the vm.h file:\n\u001b[0m\u2731 \u001b[0mGlob \"**/vm.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=80, offset=940]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"map\\(\"\u001b[90m in . \u00b7 9 matches\u001b[0m\nLet me look at the process creation to see how user memory is set up:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=80, offset=1700]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"set_des\\(|alloca_frame\"\u001b[90m in . \u00b7 10 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"trasforma\\(\"\u001b[90m in . \u00b7 13 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"BIT_RW|BIT_P|BIT_US\"\u001b[90m in . \u00b7 11 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=50, offset=1]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#define BIT_\"\u001b[90m in . \u00b7 0 matches\u001b[0m\nLet me search for how page table entries are built:\n\u001b[0m\u2731 \u001b[0mGrep \"extr_IND_FISICO|BIT_P\"\u001b[90m in . \u00b7 3 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"tab_iter|get_e\"\u001b[90m in . \u00b7 6 matches\u001b[0m\nLet me read the full distruggi_cow_privata function:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=855]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"init_root_tab|crea_pila\"\u001b[90m in . \u00b7 7 matches\u001b[0m\nLet me search for functions that add page table entries:\n\u001b[0m\u2731 \u001b[0mGrep \"map_cont|paddr alloca_tab\"\u001b[90m in . \u00b7 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=770]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"in_utn_w|in_utn_c\"\u001b[90m in . \u00b7 7 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"make_des|tab_entry\"\u001b[90m in . \u00b7 2 matches\u001b[0m\nLet me look at how entries are set up in the map function:\n\u001b[0m\u2731 \u001b[0mGrep \"set_entry|insert_tab\"\u001b[90m in . \u00b7 0 matches\u001b[0m\nLet me see how the entries are built in the code. Let me search for how entries are assigned:\n\u001b[0m\u2731 \u001b[0mGrep \"=.*BIT_P|=.*BIT_RW\"\u001b[90m in . \u00b7 1 match\u001b[0m\nLet me look at the include files for the libce definitions:\n\u001b[0m\n\u001b[0m$ \u001b[0mls -la /work/es2/nucleo/include/\ntotal 20\ndrwxr-xr-x. 1 vscode vscode   52 Feb 23  2025 .\ndrwxr-xr-x. 1 vscode vscode  228 Feb 15 17:25 ..\n-rw-r--r--. 1 vscode vscode 5404 Mar 24  2025 costanti.h\n-rw-r--r--. 1 vscode vscode 2943 Mar 24  2025 io.h\n-rw-r--r--. 1 vscode vscode 2911 Mar 24  2025 sys.h\n-rw-r--r--. 1 vscode vscode 3016 Mar 24  2025 sysio.h\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead Makefile\u001b[90m [limit=100]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"void set_des\"\u001b[90m in . \u00b7 0 matches\u001b[0m\nNow I have enough context. Let me implement the solution:\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[ ] Implement crea_cow_condivisa() function\n[ ] Implement aggiorna_cow_privata() function\n[ ] Compile and test the solution\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=575]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -826,11 +826,26 @@\n  * @return false in caso di errore, true altrimenti\n  */\n bool crea_cow_condivisa()\n {\n-/// @todo creare la prima copia della zona cow\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tcow_root = alloca_tab();\n+\tif (cow_root == 0)\n+\t\treturn false;\n+\n+\tvaddr v = ini_utn_w;\n+\tfor (natq i = 0; i < DIM_USR_COW; i += DIM_PAGINA) {\n+\t\tpaddr frame = alloca_frame();\n+\t\tif (frame == 0) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tmemset(voidptr_cast(frame), 0, DIM_PAGINA);\n+\t\t\n+\t\ttab_entry e = frame | BIT_P | BIT_US;\n+\t\tset_des(cow_root, (v + i) >> 30 & 0x1FF, 1, e);\n+\t\tset_des(cow_root, (v + i) >> 21 & 0x1FF, 1, e);\n+\t\tset_des(cow_root, (v + i) >> 12 & 0x1FF, 1, e);\n+\t}\n+\treturn true;\n }\n \n /**\n  * @brief copia la zona cow originaria\n\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement crea_cow_condivisa() function\n[ ] Implement aggiorna_cow_privata() function\n[ ] Compile and test the solution\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=845]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -862,10 +862,32 @@\n // aggiorna la cow privata in modo che l'indirizzo v sia scrivibile\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tif (v < ini_utn_w || v >= fin_utn_w)\n+\t\treturn false;\n+\n+\ttab_iter it(esecuzione->cr3, v, DIM_PAGINA);\n+\tif (!it)\n+\t\treturn false;\n+\n+\ttab_entry& e = it.get_e();\n+\tif (!(e & BIT_P))\n+\t\treturn false;\n+\n+\tif (e & BIT_RW)\n+\t\treturn true;\n+\n+\tpaddr old_frame = extr_IND_FISICO(e);\n+\tpaddr new_frame = alloca_frame();\n+\tif (new_frame == 0)\n+\t\treturn false;\n+\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\n+\te = new_frame | BIT_P | BIT_US | BIT_RW;\n+\n+\treturn true;\n }\n \n /**\n  * @brief  disfa le azioni di copia_cow_condivisa() e aggiorna_cow_condivisa()\n\n\u001b[0m\n\u001b[0m# \u001b[0mTodos\n[x] Implement crea_cow_condivisa() function\n[x] Implement aggiorna_cow_privata() function\n[ ] Compile and test the solution\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=116b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6b8a memsize   6b8a\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   2ffc memsize   2ffc\nINF\t-\t  . seg[3]: off   a000 vaddr           20a000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=117000 end=11d578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11e000 end=122520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6b8a byte da   10c000 a   200000\nINF\t-\t- copiati   2ffc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   116000 a   20a000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 2059af\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 546 (M1) 7646 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 7099 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000010000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nWRN\t8\tEccezione 14 (page fault), errore 4, RIP t01p0b(unsigned long) [utente.cpp:86 (discriminator 1)]\nWRN\t8\t  indirizzo virtuale: ffffc00000008000 \nWRN\t8\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t8\tproc 8: corpo t01p0b(unsigned long) [utente.cpp:85](1), livello UTENTE, precedenza 598\nWRN\t8\t  RIP=t01p0b(unsigned long) [utente.cpp:86 (discriminator 1)] CPL=LIV_UTENTE\nWRN\t8\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=ffffc00000000000 RBX=               2 RCX=               0 RDX=       200000008\nWRN\t8\t  RDI=               1 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffd0\nWRN\t8\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t8\t  R12=               1 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t8\tProcesso 8 abortito\nqemu-system-x86_64: terminating on signal 15 from pid 1149 (timeout)\n\u001b[0m\nI see the issue - the page tables aren't being set up correctly. Let me fix the implementation:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=828]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"crea_pila|init_root_tab\"\u001b[90m in . \u00b7 7 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"carica_modulo\"\u001b[90m in . \u00b7 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"vaddr map\\(|unmap\\(\"\u001b[90m in . \u00b7 4 matches\u001b[0m\nLet me look at the map function usage:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=1020]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -824,28 +824,26 @@\n  * Inizialmente la zona deve contenere solo byte nulli.\n  *\n  * @return false in caso di errore, true altrimenti\n  */\n-bool crea_cow_condivisa()\n+bool crea_cow_condavisa()\n {\n \tcow_root = alloca_tab();\n \tif (cow_root == 0)\n \t\treturn false;\n \n-\tvaddr v = ini_utn_w;\n-\tfor (natq i = 0; i < DIM_USR_COW; i += DIM_PAGINA) {\n-\t\tpaddr frame = alloca_frame();\n-\t\tif (frame == 0) {\n-\t\t\treturn false;\n-\t\t}\n-\t\tmemset(voidptr_cast(frame), 0, DIM_PAGINA);\n-\t\t\n-\t\ttab_entry e = frame | BIT_P | BIT_US;\n-\t\tset_des(cow_root, (v + i) >> 30 & 0x1FF, 1, e);\n-\t\tset_des(cow_root, (v + i) >> 21 & 0x1FF, 1, e);\n-\t\tset_des(cow_root, (v + i) >> 12 & 0x1FF, 1, e);\n-\t}\n-\treturn true;\n+\tvaddr v = map(cow_root,\n+\t\tini_utn_w,\n+\t\tini_utn_w + DIM_USR_COW,\n+\t\tBIT_US,\n+\t\t[](vaddr) {\n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f != 0)\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\treturn f;\n+\t\t});\n+\n+\treturn v == ini_utn_w + DIM_USR_COW;\n }\n \n /**\n  * @brief copia la zona cow originaria\n\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -824,9 +824,9 @@\n  * Inizialmente la zona deve contenere solo byte nulli.\n  *\n  * @return false in caso di errore, true altrimenti\n  */\n-bool crea_cow_condavisa()\n+bool crea_cow_condivisa()\n {\n \tcow_root = alloca_tab();\n \tif (cow_root == 0)\n \t\treturn false;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6db0 memsize   6db0\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   3074 memsize   3074\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6db0 byte da   10c000 a   200000\nINF\t-\t- copiati   3074 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 205bd5\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 7095 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nERR\t6\tPANIC: PAGE FAULT NON RISOLTO\nERR\t6\t  processi: 2\nERR\t6\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t6\tcorpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nERR\t6\t  RIP=panic [sistema.cpp:1897] CPL=LIV_SISTEMA\nERR\t6\t  RFLAGS=6 [-- -- -- -- -- -- -- -- PF --, IOPL=SISTEMA]\nERR\t6\t  RAX=               a RBX=               4 RCX=               0 RDX=      ffffff03f8\nERR\t6\t  RDI=               3 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nERR\t6\t  R8 =              36 R9 =      fffffffdb7 R10=               0 R11=               0\nERR\t6\t  R12=               e R13=ffff8000000001bb R14=               0 R15=               0\nERR\t6\t  backtrace:\nERR\t6\t  > gestore_eccezioni [sistema.cpp:460]\nERR\t6\t  > exc_page_fault [sistema.s:812]\nERR\t6\t  > t00p0b(unsigned long) [utente.cpp:65]\nERR\t6\t  > 0xaaaaaaaaaaaaaaa9\nERR\t6\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t6\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1567](0), livello SISTEMA, precedenza 0\nERR\t6\t  RIP=main [sistema.cpp:1699] CPL=LIV_SISTEMA\nERR\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t6\t  RAX=          2029fa RBX=            13a0 RCX=               0 RDX=          2203f8\nERR\t6\t  RDI=            13a0 RSI=          222230 RBP=          222300 RSP=          222230\nERR\t6\t  R8 =              30 R9 =          22205f R10=               0 R11=               0\nERR\t6\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t6\t  backtrace:\nERR\t6\t  > _start [start64.s:33]\nERR\t6\tproc 2: corpo estern_kbd(unsigned long) [io.cpp:197](0), livello SISTEMA, precedenza 1104\nERR\t6\t  RIP=estern_kbd(unsigned long) [io.cpp:197] CPL=LIV_SISTEMA\nERR\t6\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t6\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t6\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t6\t  backtrace:\nERR\t6\tproc 3: corpo estern_hd(unsigned long) [io.cpp:557](0), livello SISTEMA, precedenza 1120\nERR\t6\t  RIP=estern_hd(unsigned long) [io.cpp:557] CPL=LIV_SISTEMA\nERR\t6\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t6\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t6\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t6\t  backtrace:\nERR\t6\tproc 5: corpo main_body(unsigned long) [utente.cpp:170](0), livello UTENTE, precedenza 900\nERR\t6\t  RIP=delay [utente.s:63] CPL=LIV_UTENTE\nERR\t6\t  RFLAGS=206 [-- -- -- IF -- -- -- -- PF --, IOPL=SISTEMA]\nERR\t6\t  RAX=               6 RBX=ffff800000004180 RCX=               3 RDX=ffff800000004174\nERR\t6\t  RDI=               1 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffc8\nERR\t6\t  R8 =              69 R9 =fffffffffffffe89 R10=               0 R11=               0\nERR\t6\t  R12=            1b95 R13=ffff800000004188 R14=               0 R15=               0\nERR\t6\t  backtrace:\nERR\t6\t  > main_body(unsigned long) [utente.cpp:179]\nERR\t6\t  > 0xaaaaaaaaaaaaaaa9\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"crea_cow_condivisa\\(\\)\"\u001b[90m in . \u00b7 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=1640]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=828]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"MAX_LIV|dim_region\"\u001b[90m in . \u00b7 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#define MAX_LIV\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=945]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=983]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"init\\.cr3\"\u001b[90m in . \u00b7 3 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"I_UTN_W.*384\"\u001b[90m in . \u00b7 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=40, offset=60]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"extern.*cow\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"cow\\[\"\u001b[90m in utente \u00b7 25 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"char cow|cow\\s*=\"\u001b[90m in utente \u00b7 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=860]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=448]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=668]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=25, offset=60]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mpython3 -c \"print(hex(0xffffc00000000000 + 0x2000000000))\"\n0xffffc02000000000\n\u001b[0m\n\u001b[0m$ \u001b[0mpython3 -c \"print(hex(0xffffe00000000000 - 0xffffc00000000000))\"\n0x200000000000\n\u001b[0m\n\u001b[0m$ \u001b[0mpython3 -c \"print(0x200000000000 / (1024**4))\"\n32.0\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"PF_W|errore.*14\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"errore &\"\u001b[90m in . \u00b7 3 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#define PF_\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"SE_EXT|PF_RES\"\u001b[90m in . \u00b7 2 matches\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -860,9 +860,9 @@\n // aggiorna la cow privata in modo che l'indirizzo v sia scrivibile\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n-\tif (v < ini_utn_w || v >= fin_utn_w)\n+\tif (v < ini_utn_w || v >= ini_utn_w + DIM_USR_COW)\n \t\treturn false;\n \n \ttab_iter it(esecuzione->cr3, v, DIM_PAGINA);\n \tif (!it)\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6da8 memsize   6da8\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   3074 memsize   3074\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17424\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123520 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2871 memsize   2871\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    d04 memsize    d04\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    130 memsize    1a0\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6da8 byte da   10c000 a   200000\nINF\t-\t- copiati   3074 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 172a4 byte\nINF\t-\t- entry point 205bcd\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 7095 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff8000000041a0, 0xffff8000001041a0)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:170](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000011000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000010000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1: PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000008000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nERR\t9\tPANIC: PAGE FAULT NON RISOLTO\nERR\t9\t  processi: 2\nERR\t9\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t9\tcorpo t02p0b(unsigned long) [utente.cpp:99](2), livello UTENTE, precedenza 597\nERR\t9\t  RIP=panic [sistema.cpp:1897] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=16 [-- -- -- -- -- -- -- AF PF --, IOPL=SISTEMA]\nERR\t9\t  RAX=               a RBX=               7 RCX=               0 RDX=      ffffff03f8\nERR\t9\t  RDI=               3 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nERR\t9\t  R8 =              39 R9 =      fffffffdb7 R10=               0 R11=               0\nERR\t9\t  R12=               e R13=ffff80000000034a R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > gestore_eccezioni [sistema.cpp:460]\nERR\t9\t  > exc_page_fault [sistema.s:812]\nERR\t9\t  > t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\nERR\t9\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t9\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1567](0), livello SISTEMA, precedenza 0\nERR\t9\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=          2029f2 RBX=            13a0 RCX=               0 RDX=          2203f8\nERR\t9\t  RDI=            13a0 RSI=          222230 RBP=          222300 RSP=          222220\nERR\t9\t  R8 =              30 R9 =          22205f R10=               0 R11=               0\nERR\t9\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > main [sistema.cpp:1700]\nERR\t9\t  > _start [start64.s:33]\nERR\t9\tproc 2: corpo estern_kbd(unsigned long) [io.cpp:197](0), livello SISTEMA, precedenza 1104\nERR\t9\t  RIP=estern_kbd(unsigned long) [io.cpp:197] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t9\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t9\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\tproc 3: corpo estern_hd(unsigned long) [io.cpp:557](0), livello SISTEMA, precedenza 1120\nERR\t9\t  RIP=estern_hd(unsigned long) [io.cpp:557] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=200 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t9\t  RDI=               0 RSI=               0 RBP=               0 RSP=      fffffffff8\nERR\t9\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\tproc 5: corpo main_body(unsigned long) [utente.cpp:170](0), livello UTENTE, precedenza 900\nERR\t9\t  RIP=sem_wait [utente.s:49] CPL=LIV_UTENTE\nERR\t9\t  RFLAGS=202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=ffff800000004188 RBX=ffff800000004180 RCX=               3 RDX=ffff800000004160\nERR\t9\t  RDI=               1 RSI=               2 RBP=fffffffffffffff0 RSP=ffffffffffffffc8\nERR\t9\t  R8 =              65 R9 =fffffffffffffe92 R10=               0 R11=               0\nERR\t9\t  R12=            1b95 R13=ffff800000004188 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > main_body(unsigned long) [utente.cpp:196]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"execuzione->cr3\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"cr3\"\u001b[90m in . \u00b7 27 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inc_ref|dec_ref\"\u001b[90m in . \u00b7 3 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=718]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"MAX_LIV\"\u001b[90m in . \u00b7 4 matches\u001b[0m\nLet me look at what copy_des does:\n\u001b[0m\u2731 \u001b[0mGrep \"void copy_des\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"invlpg|TLB\"\u001b[90m in . \u00b7 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=785]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"traduci|walk_page\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"flush_tlb|invlpg\"\u001b[90m in . \u00b7 0 matches\u001b[0m\nLet me check for TLB invalidation functions:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=860]\u001b[0m\nLet me add TLB invalidation to my code:\n\u001b[93m\u001b[1m! \u001b[0m maximum turns of 100 reached, stopping session\n",
  "duration_seconds": 804.26,
  "turns": 100,
  "max_turns": 100,
  "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 59d0e91..9c88ac0 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -827,9 +827,22 @@ paddr cow_root;\n  */\n bool crea_cow_condivisa()\n {\n-/// @todo creare la prima copia della zona cow\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tcow_root = alloca_tab();\n+\tif (cow_root == 0)\n+\t\treturn false;\n+\n+\tvaddr v = map(cow_root,\n+\t\tini_utn_w,\n+\t\tini_utn_w + DIM_USR_COW,\n+\t\tBIT_US,\n+\t\t[](vaddr) {\n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f != 0)\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\treturn f;\n+\t\t});\n+\n+\treturn v == ini_utn_w + DIM_USR_COW;\n }\n \n /**\n@@ -848,8 +861,30 @@ void copia_cow_condivisa(paddr dest)\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tif (v < ini_utn_w || v >= ini_utn_w + DIM_USR_COW)\n+\t\treturn false;\n+\n+\ttab_iter it(esecuzione->cr3, v, DIM_PAGINA);\n+\tif (!it)\n+\t\treturn false;\n+\n+\ttab_entry& e = it.get_e();\n+\tif (!(e & BIT_P))\n+\t\treturn false;\n+\n+\tif (e & BIT_RW)\n+\t\treturn true;\n+\n+\tpaddr old_frame = extr_IND_FISICO(e);\n+\tpaddr new_frame = alloca_frame();\n+\tif (new_frame == 0)\n+\t\treturn false;\n+\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\n+\te = new_frame | BIT_P | BIT_US | BIT_RW;\n+\n+\treturn true;\n }\n \n /**\ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 59d0e91..9c88ac0 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -827,9 +827,22 @@ paddr cow_root;\n  */\n bool crea_cow_condivisa()\n {\n-/// @todo creare la prima copia della zona cow\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tcow_root = alloca_tab();\n+\tif (cow_root == 0)\n+\t\treturn false;\n+\n+\tvaddr v = map(cow_root,\n+\t\tini_utn_w,\n+\t\tini_utn_w + DIM_USR_COW,\n+\t\tBIT_US,\n+\t\t[](vaddr) {\n+\t\t\tpaddr f = alloca_frame();\n+\t\t\tif (f != 0)\n+\t\t\t\tmemset(voidptr_cast(f), 0, DIM_PAGINA);\n+\t\t\treturn f;\n+\t\t});\n+\n+\treturn v == ini_utn_w + DIM_USR_COW;\n }\n \n /**\n@@ -848,8 +861,30 @@ void copia_cow_condivisa(paddr dest)\n // dal processo corrente\n bool aggiorna_cow_privata(vaddr v)\n {\n-// ( SOLUZIONE 2023-06-07\n-//   SOLUZIONE 2023-06-07 )\n+\tif (v < ini_utn_w || v >= ini_utn_w + DIM_USR_COW)\n+\t\treturn false;\n+\n+\ttab_iter it(esecuzione->cr3, v, DIM_PAGINA);\n+\tif (!it)\n+\t\treturn false;\n+\n+\ttab_entry& e = it.get_e();\n+\tif (!(e & BIT_P))\n+\t\treturn false;\n+\n+\tif (e & BIT_RW)\n+\t\treturn true;\n+\n+\tpaddr old_frame = extr_IND_FISICO(e);\n+\tpaddr new_frame = alloca_frame();\n+\tif (new_frame == 0)\n+\t\treturn false;\n+\n+\tmemcpy(voidptr_cast(new_frame), voidptr_cast(old_frame), DIM_PAGINA);\n+\n+\te = new_frame | BIT_P | BIT_US | BIT_RW;\n+\n+\treturn true;\n }\n \n /**\n",
  "error": null
}