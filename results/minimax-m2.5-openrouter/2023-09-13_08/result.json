{
  "passed": false,
  "output": [],
  "expected": [
    "TEST 1 PROC 5: OK",
    "TEST 2 PROC 5: OK",
    "TEST 3 PROC 5: OK",
    "TEST 4 PROC 5: OK",
    "TEST 5 PROC 5: OK",
    "TEST 6 PROC 5: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   710c memsize   710c\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   315c memsize   315c\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=124590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   710c byte da   10c000 a   200000\nINF\t-\t- copiati   315c byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205f31\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 541 (M1) 995 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 460 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nWRN\t1\tEccezione 13 (errore di protezione), errore 0, RIP copia_cow(unsigned long, unsigned long) [sistema.cpp:894]\nERR\t1\tPANIC: ERRORE DI SISTEMA\nERR\t1\t  processi: 1\nERR\t1\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t1\tcorpo _start [io.s:17](2214460), livello SISTEMA, precedenza 1278\nERR\t1\t  RIP=panic [sistema.cpp:1938] CPL=LIV_SISTEMA\nERR\t1\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t1\t  RAX=               a RBX=               0 RCX=               0 RDX=      ffffff03f8\nERR\t1\t  RDI=               3 RSI=             3f8 RBP=      fffffffe08 RSP=      fffffffe00\nERR\t1\t  R8 =              31 R9 =      fffffffc27 R10=               0 R11=               0\nERR\t1\t  R12=               d R13=          2008cf R14=4300050000430000 R15=4300050000430000\nERR\t1\t  backtrace:\nERR\t1\t  > gestore_eccezioni [sistema.cpp:454]\nERR\t1\t  > exc_prot_fault [sistema.s:792]\nERR\t1\t  > copia_cow(unsigned long, unsigned long) [sistema.cpp:894]\nERR\t1\t  > crea_processo(void (*)(unsigned long), unsigned long, int, char) [sistema.cpp:1148 (discriminator 1)]\nERR\t1\t  > c_activate_pe [sistema.cpp:1497]\nERR\t1\t  > a_activate_pe [sistema.s:448]\nERR\t1\t  > activate_pe [io.s:94]\nERR\t1\t  > kbd_init() [io.cpp:268]\nERR\t1\t  > console_init() [io.cpp:301]\nERR\t1\t  > main_io [io.cpp:666]\nERR\t1\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t1\tproc 0: corpo main [sistema.cpp:1611](0), livello SISTEMA, precedenza 0\nERR\t1\t  RIP=main [sistema.cpp:1723] CPL=LIV_SISTEMA\nERR\t1\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t1\t  RAX=          202cab RBX=ffff8000000019cf RCX=               0 RDX=          2103f8\nERR\t1\t  RDI=            13a0 RSI=          21ca30 RBP=          21cb00 RSP=          21ca30\nERR\t1\t  R8 =              30 R9 =          21c85f R10=               0 R11=               0\nERR\t1\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t1\t  backtrace:\nERR\t1\t  > _start [start64.s:33]\nERR\t1\tproc 2: corpo 0x0(0), livello SISTEMA, precedenza 1104\nERR\t1\t  impossibile leggere la pila del processo\nERR\t1\t  RIP=0x0 CPL=LIV_SISTEMA\nERR\t1\t  RFLAGS=0 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t1\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t1\t  RDI=               0 RSI=               0 RBP=               0 RSP=               0\nERR\t1\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t1\t  R12=               0 R13=               0 R14=               0 R15=               0\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5:nitro\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 93 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"ESAME|SOLUZIONE\"\u001b[90m 42 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=860]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=390]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"crea_cow|DIM_USR_COW|ini_utn_w\"\u001b[90m 17 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=830]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=60, offset=25]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"des_frame|nshared\"\u001b[90m 5 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=493]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inc_ref|dec_ref|copy_des|set_des\"\u001b[90m 9 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=720]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"void copy_des|void set_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\\(\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"^void copy_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/sys.h\u001b[90m [limit=50, offset=95]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\"\u001b[90m in . \u00b7 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.cpp\"\u001b[90m 10 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*.s\"\u001b[90m 3 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des\"\u001b[90m in sistema \u00b7 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=985]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"include/**/*.h\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"copy_des|set_des\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=1]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/libce*\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead Makefile\u001b[90m [limit=100]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead include/costanti.h\u001b[90m [limit=50, offset=85]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"class tab_iter\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=874]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"BIT_RW\"\u001b[90m 7 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#define BIT_RW\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"#define BIT_RW\"\u001b[90m in . \u00b7 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/boot.h\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"activate_p\\(|activate_pe\\(\"\u001b[90m 27 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=80, offset=1275]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"crea_processo\"\u001b[90m 12 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=90, offset=1061]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"alloca_tab|rilascia_tab|alloca_frame|rilascia_frame\"\u001b[90m 20 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"^vaddr map\\(\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"vaddr map\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"map\\(dest\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=695]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"tab_iter\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"distruggi_processo\"\u001b[90m 6 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=1192]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=665]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"extr_IND_FISICO|set_IND_FISICO\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"BIT_P|BIT_US\"\u001b[90m 7 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=780]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=120]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1 | head -100\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6ebe memsize   6ebe\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   3124 memsize   3124\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=123590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6ebe byte da   10c000 a   200000\nINF\t-\t- copiati   3124 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205ce3\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 540 (M1) 996 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 461 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004248, 0xffff800000104248)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:246](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000003000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000002000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nWRN\t8\tEccezione 14 (page fault), errore 4, RIP t01p0b(unsigned long) [utente.cpp:86 (discriminator 1)]\nWRN\t8\t  indirizzo virtuale: ffffc00000001000 \nWRN\t8\t  dettagli: pag o tab assente, lettura, da utente, \nERR\t8\tPANIC: indirizzo cow ffffc00000001000 non mappato\nERR\t8\t  processi: 2\nERR\t8\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t8\tcorpo t01p0b(unsigned long) [utente.cpp:85](1), livello UTENTE, precedenza 598\nERR\t8\t  RIP=panic [sistema.cpp:1885] CPL=LIV_SISTEMA\nERR\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t8\t  RAX=               a RBX=      fffffffa90 RCX=               0 RDX=      ffffff03f8\nERR\t8\t  RDI=               3 RSI=             3f8 RBP=      fffffffa78 RSP=      fffffffa70\nERR\t8\t  R8 =              38 R9 =      fffffff897 R10=               0 R11=               0\nERR\t8\t  R12=               e R13=ffffc00000001000 R14=               0 R15=               0\nERR\t8\t  backtrace:\nERR\t8\t  > fpanic(char const*, ...) [fpanic.cpp:13]\nERR\t8\t  > aggiorna_cow(unsigned long) [sistema.cpp:883]\nERR\t8\t  > gestore_eccezioni [sistema.cpp:472]\nERR\t8\t  > exc_page_fault [sistema.s:812]\nERR\t8\t  > t01p0b(unsigned long) [utente.cpp:86 (discriminator 1)]\nERR\t8\t  > 0xaaaaaaaaaaaaaaa9\nERR\t8\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t8\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1552](0), livello SISTEMA, precedenza 0\nERR\t8\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t8\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t8\t  RAX=          202b04 RBX=            13a0 RCX=               0 RDX=          2103f8\nERR\t8\t  RDI=            13a0 RSI=          21ba30 RBP=          21bb00 RSP=          21ba20\nERR\t8\t  R8 =              30 R9 =          21b85f R10=               0 R11=               0\nERR\t8\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t8\t  backtrace:\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"class.*tab_iter|tab_iter::\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=863]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -862,11 +862,21 @@\n  * @param dest\tindirizzo della tabelal radice del TRIE destinatario\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-/// @todo Realizzare la copia.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\tfor (tab_iter it(src, ini_utn_w, DIM_USR_COW); it; it.next()) {\n+\t\ttab_entry e = it.get_e();\n+\t\tif (!(e & BIT_P))\n+\t\t\tcontinue;\n+\t\te &= ~BIT_RW;\n+\t\tit.get_e() = e;\n+\t\t\n+\t\tpaddr f = extr_IND_FISICO(e);\n+\t\tvdf[f / DIM_PAGINA].nshared += 2;\n+\t\t\n+\t\ttab_entry* dest_ptr = reinterpret_cast<tab_entry*>(dest * DIM_PAGINA);\n+\t\tdest_ptr[it.get_idx()] = e;\n+\t}\n }\n \n // ( SOLUZIONE 2023-09-13\n //   SOLUZIONE 2023-09-13 )\n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=890]\u001b[0m\nNow let me implement the `aggiorna_cow` TODO part:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -909,11 +909,18 @@\n \t\t\tinvalida_entrata_TLB(it.get_v());\n \t\t}\n \t\tset_IND_FISICO(e, new_frame);\n \t\te |= BIT_RW;\n-/// @todo Completare l'aggiornamento dello stato.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\t\t\n+\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\n+\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\tif (vdf[old_frame / DIM_PAGINA].nshared == 0) {\n+\t\t\tif (it.get_l() > 1)\n+\t\t\t\trilascia_tab(old_frame);\n+\t\t\telse\n+\t\t\t\trilascia_frame(old_frame);\n+\t\t}\n \t}\n \treturn true;\n }\n \n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=15, offset=928]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -928,11 +928,21 @@\n  * @brief Disfa le azioni di copia_cow() e aggiorna_cow() per il processo corrente.\n  */\n void distruggi_cow()\n {\n-//// @todo Realizzare la funzione.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\tfor (tab_iter it(esecuzione->cr3, ini_utn_w, DIM_USR_COW); it; it.next()) {\n+\t\ttab_entry e = it.get_e();\n+\t\tif (!(e & BIT_P))\n+\t\t\tcontinue;\n+\t\tpaddr f = extr_IND_FISICO(e);\n+\t\tvdf[f / DIM_PAGINA].nshared--;\n+\t\tif (vdf[f / DIM_PAGINA].nshared == 0) {\n+\t\t\tif (it.get_l() > 1)\n+\t\t\t\trilascia_tab(f);\n+\t\t\telse\n+\t\t\t\trilascia_frame(f);\n+\t\t}\n+\t}\n }\n //   ESAME 2023-09-13 )\n \n /////////////////////////////////////////////////////////////////////////////////\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\nsistema/sistema.cpp: In function 'void copia_cow(paddr, paddr)':\nsistema/sistema.cpp:877:29: error: 'class tab_iter' has no member named 'get_idx'; did you mean 'get_l'?\n  877 |                 dest_ptr[it.get_idx()] = e;\n      |                             ^~~~~~~\n      |                             get_l\nmake: *** [Makefile:130: boot/0-sistema] Error 1\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"tab_iter.*idx|tab_iter.*index\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"I_UTN_W.*PART\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=785]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=864]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -862,20 +862,21 @@\n  * @param dest\tindirizzo della tabelal radice del TRIE destinatario\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-\tfor (tab_iter it(src, ini_utn_w, DIM_USR_COW); it; it.next()) {\n-\t\ttab_entry e = it.get_e();\n+\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(src * DIM_PAGINA);\n+\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(dest * DIM_PAGINA);\n+\t\n+\tfor (natl i = I_UTN_W; i < I_UTN_W + N_UTN_W; i++) {\n+\t\ttab_entry e = src_tab[i];\n \t\tif (!(e & BIT_P))\n \t\t\tcontinue;\n \t\te &= ~BIT_RW;\n-\t\tit.get_e() = e;\n+\t\tsrc_tab[i] = e;\n+\t\tdest_tab[i] = e;\n \t\t\n \t\tpaddr f = extr_IND_FISICO(e);\n \t\tvdf[f / DIM_PAGINA].nshared += 2;\n-\t\t\n-\t\ttab_entry* dest_ptr = reinterpret_cast<tab_entry*>(dest * DIM_PAGINA);\n-\t\tdest_ptr[it.get_idx()] = e;\n \t}\n }\n \n // ( SOLUZIONE 2023-09-13\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   7062 memsize   7062\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   314c memsize   314c\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=124590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   7062 byte da   10c000 a   200000\nINF\t-\t- copiati   314c byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205e87\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 541 (M1) 995 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 460 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nWRN\t1\tEccezione 14 (page fault), errore 0, RIP copia_cow(unsigned long, unsigned long) [sistema.cpp:870]\nWRN\t1\t  indirizzo virtuale: 434000c00 \nWRN\t1\t  dettagli: pag o tab assente, lettura, da sistema, \nERR\t1\tPANIC: ERRORE DI SISTEMA\nERR\t1\t  processi: 1\nERR\t1\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t1\tcorpo _start [io.s:17](2214460), livello SISTEMA, precedenza 1278\nERR\t1\t  RIP=panic [sistema.cpp:1913] CPL=LIV_SISTEMA\nERR\t1\t  RFLAGS=12 [-- -- -- -- -- -- -- AF -- --, IOPL=SISTEMA]\nERR\t1\t  RAX=               a RBX=               0 RCX=               0 RDX=      ffffff03f8\nERR\t1\t  RDI=               3 RSI=             3f8 RBP=      fffffffe48 RSP=      fffffffe40\nERR\t1\t  R8 =              31 R9 =      fffffffc67 R10=               0 R11=               0\nERR\t1\t  R12=               e R13=          2008c9 R14=               0 R15=          439000\nERR\t1\t  backtrace:\nERR\t1\t  > gestore_eccezioni [sistema.cpp:454]\nERR\t1\t  > exc_page_fault [sistema.s:812]\nERR\t1\t  > copia_cow(unsigned long, unsigned long) [sistema.cpp:870]\nERR\t1\t  > crea_processo(void (*)(unsigned long), unsigned long, int, char) [sistema.cpp:1123 (discriminator 1)]\nERR\t1\t  > c_activate_pe [sistema.cpp:1472]\nERR\t1\t  > a_activate_pe [sistema.s:448]\nERR\t1\t  > activate_pe [io.s:94]\nERR\t1\t  > kbd_init() [io.cpp:268]\nERR\t1\t  > console_init() [io.cpp:301]\nERR\t1\t  > main_io [io.cpp:666]\nERR\t1\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t1\tproc 0: corpo main [sistema.cpp:1586](0), livello SISTEMA, precedenza 0\nERR\t1\t  RIP=main [sistema.cpp:1698] CPL=LIV_SISTEMA\nERR\t1\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t1\t  RAX=          202c01 RBX=ffff8000000019cf RCX=               0 RDX=          2103f8\nERR\t1\t  RDI=            13a0 RSI=          21ca30 RBP=          21cb00 RSP=          21ca30\nERR\t1\t  R8 =              30 R9 =          21c85f R10=               0 R11=               0\nERR\t1\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t1\t  backtrace:\nERR\t1\t  > _start [start64.s:33]\nERR\t1\tproc 2: corpo 0x0(0), livello SISTEMA, precedenza 1104\nERR\t1\t  impossibile leggere la pila del processo\nERR\t1\t  RIP=0x0 CPL=LIV_SISTEMA\nERR\t1\t  RFLAGS=0 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t1\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t1\t  RDI=               0 RSI=               0 RBP=               0 RSP=               0\nERR\t1\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t1\t  R12=               0 R13=               0 R14=               0 R15=               0\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"voidptr_cast|FM|finestra\"\u001b[90m 14 matches\u001b[0m\nI see the issue - when the I/O process is created, the COW zone doesn't exist yet in the parent process. Let me check the order of operations:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=1655]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"paddr|typedef.*natq\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"natq|natl|using.*natq\"\u001b[90m 21 matches\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -862,10 +862,10 @@\n  * @param dest\tindirizzo della tabelal radice del TRIE destinatario\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(src * DIM_PAGINA);\n-\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(dest * DIM_PAGINA);\n+\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(voidptr_cast(src));\n+\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n \t\n \tfor (natl i = I_UTN_W; i < I_UTN_W + N_UTN_W; i++) {\n \t\ttab_entry e = src_tab[i];\n \t\tif (!(e & BIT_P))\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   705a memsize   705a\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   314c memsize   314c\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=124590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   705a byte da   10c000 a   200000\nINF\t-\t- copiati   314c byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205e7f\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 541 (M1) 995 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 460 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004248, 0xffff800000104248)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:246](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000003000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000002000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000001000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: lettura di un byte ereditato\nINF\t5\tproc=10 entry=t03p0b(unsigned long) [utente.cpp:126](3) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nERR\t9\tPANIC: tentativo di deallocare la tabella 434000 con 1 entrate valide\nERR\t9\t  processi: 3\nERR\t9\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t9\tcorpo t02p0b(unsigned long) [utente.cpp:99](2), livello UTENTE, precedenza 597\nERR\t9\t  RIP=panic [sistema.cpp:1913] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=6 [-- -- -- -- -- -- -- -- PF --, IOPL=SISTEMA]\nERR\t9\t  RAX=               a RBX=      fffffffa70 RCX=               0 RDX=      ffffff03f8\nERR\t9\t  RDI=               3 RSI=             3f8 RBP=      fffffffa58 RSP=      fffffffa50\nERR\t9\t  R8 =              39 R9 =      fffffff877 R10=               0 R11=               0\nERR\t9\t  R12=          46e000 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\nERR\t9\t  > fpanic(char const*, ...) [fpanic.cpp:13]\nERR\t9\t  > rilascia_tab(unsigned long) [sistema.cpp:720]\nERR\t9\t  > distruggi_cow() [sistema.cpp:941]\nERR\t9\t  > distruggi_processo(des_proc*) [sistema.cpp:1232]\nERR\t9\t  > c_terminate_p [sistema.cpp:1368]\nERR\t9\t  > a_terminate_p [sistema.s:297]\nERR\t9\t  > terminate_p [utente.s:35]\nERR\t9\t  > t02p0b(unsigned long) [utente.cpp:105 (discriminator 1)]\nERR\t9\t  > 0xaaaaaaaaaaaaaaa9\nERR\t9\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t9\tproc 0: corpo dummy(unsigned long) [sistema.cpp:1580](0), livello SISTEMA, precedenza 0\nERR\t9\t  RIP=halt [halt.s:9] CPL=LIV_SISTEMA\nERR\t9\t  RFLAGS=10202 [-- -- -- IF -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t9\t  RAX=          202c9f RBX=            13a0 RCX=               0 RDX=          2103f8\nERR\t9\t  RDI=            13a0 RSI=          21ca30 RBP=          21cb00 RSP=          21ca20\nERR\t9\t  R8 =              30 R9 =          21c85f R10=               0 R11=               0\nERR\t9\t  R12=            13a0 R13=               0 R14=               0 R15=               0\nERR\t9\t  backtrace:\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=930]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -933,15 +933,14 @@\n \tfor (tab_iter it(esecuzione->cr3, ini_utn_w, DIM_USR_COW); it; it.next()) {\n \t\ttab_entry e = it.get_e();\n \t\tif (!(e & BIT_P))\n \t\t\tcontinue;\n+\t\tif (it.get_l() > 1)\n+\t\t\tcontinue;\n \t\tpaddr f = extr_IND_FISICO(e);\n \t\tvdf[f / DIM_PAGINA].nshared--;\n \t\tif (vdf[f / DIM_PAGINA].nshared == 0) {\n-\t\t\tif (it.get_l() > 1)\n-\t\t\t\trilascia_tab(f);\n-\t\t\telse\n-\t\t\t\trilascia_frame(f);\n+\t\t\trilascia_frame(f);\n \t\t}\n \t}\n }\n //   ESAME 2023-09-13 )\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   7050 memsize   7050\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   314c memsize   314c\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=124590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   7050 byte da   10c000 a   200000\nINF\t-\t- copiati   314c byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205e75\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 541 (M1) 995 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 460 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000004248, 0xffff800000104248)\nINF\t4\tproc=5 entry=main_body(unsigned long) [utente.cpp:246](0) prio=900 liv=3\nINF\t4\tProcesso 4 terminato\nDBG\t5\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t5\tproc=6 entry=t00p0b(unsigned long) [utente.cpp:64](0) prio=600 liv=3\nWRN\t6\tEccezione 14 (page fault), errore 4, RIP t00p0b(unsigned long) [utente.cpp:65]\nWRN\t6\t  indirizzo virtuale: ffffc00000003000 \nWRN\t6\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t6\tproc 6: corpo t00p0b(unsigned long) [utente.cpp:64](0), livello UTENTE, precedenza 600\nWRN\t6\t  RIP=t00p0b(unsigned long) [utente.cpp:65] CPL=LIV_UTENTE\nWRN\t6\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t6\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t6\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t6\tProcesso 6 abortito\nINF\t5\tproc=7 entry=t00p1b(unsigned long) [utente.cpp:71](0) prio=599 liv=3\nWRN\t7\tEccezione 14 (page fault), errore 4, RIP t00p1b(unsigned long) [utente.cpp:72]\nWRN\t7\t  indirizzo virtuale: ffffc00000002000 \nWRN\t7\t  dettagli: pag o tab assente, lettura, da utente, \nWRN\t7\tproc 7: corpo t00p1b(unsigned long) [utente.cpp:71](0), livello UTENTE, precedenza 599\nWRN\t7\t  RIP=t00p1b(unsigned long) [utente.cpp:72] CPL=LIV_UTENTE\nWRN\t7\t  RFLAGS=10282 [-- -- -- IF -- SF -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=ffffc00000000000 RBX=               0 RCX=               0 RDX=               0\nWRN\t7\t  RDI=               0 RSI=               0 RBP=fffffffffffffff0 RSP=ffffffffffffffe0\nWRN\t7\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > 0xaaaaaaaaaaaaaaa9\nWRN\t7\tProcesso 7 abortito\nDBG\t5\tTEST 0: === FINE ===\nDBG\t5\tTEST 1: >>>INIZIO<<<: lettura di un byte\nINF\t5\tproc=8 entry=t01p0b(unsigned long) [utente.cpp:85](1) prio=598 liv=3\nUSR\t5\tTEST 1 PROC 5: OK\nDBG\t5\tTEST 1: === FINE ===\nDBG\t5\tTEST 2: >>>INIZIO<<<: scrittura di un byte\nINF\t5\tproc=9 entry=t02p0b(unsigned long) [utente.cpp:99](2) prio=597 liv=3\nINF\t8\tProcesso 8 terminato\nWRN\t9\tEccezione 14 (page fault), errore 7, RIP t02p0b(unsigned long) [utente.cpp:101 (discriminator 1)]\nWRN\t9\t  indirizzo virtuale: ffffc00000001000 \nWRN\t9\t  dettagli: protezione, scrittura, da utente, \nUSR\t5\tTEST 2 PROC 5: OK\nDBG\t5\tTEST 2: === FINE ===\nDBG\t5\tTEST 3: >>>INIZIO<<<: lettura di un byte ereditato\nINF\t5\tproc=10 entry=t03p0b(unsigned long) [utente.cpp:126](3) prio=596 liv=3\nINF\t9\tProcesso 9 terminato\nWRN\t10\tEccezione 14 (page fault), errore 7, RIP t03p0b(unsigned long) [utente.cpp:128 (discriminator 1)]\nWRN\t10\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t10\t  dettagli: protezione, scrittura, da utente, \nINF\t10\tproc=11 entry=t03p1b(unsigned long) [utente.cpp:118](3) prio=300 liv=3\nINF\t10\tProcesso 10 terminato\nUSR\t5\tTEST 3 PROC 5: OK\nDBG\t5\tTEST 3: === FINE ===\nDBG\t5\tTEST 4: >>>INIZIO<<<: scrittura dopo la copia\nINF\t5\tproc=12 entry=t04p0b(unsigned long) [utente.cpp:155](4) prio=595 liv=3\nINF\t12\tproc=13 entry=t04p1b(unsigned long) [utente.cpp:146](4) prio=299 liv=3\nWRN\t12\tEccezione 14 (page fault), errore 7, RIP t04p0b(unsigned long) [utente.cpp:158 (discriminator 1)]\nWRN\t12\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t12\t  dettagli: protezione, scrittura, da utente, \nINF\t11\tProcesso 11 terminato\nWRN\t13\tEccezione 14 (page fault), errore 7, RIP t04p1b(unsigned long) [utente.cpp:148 (discriminator 1)]\nWRN\t13\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t13\t  dettagli: protezione, scrittura, da utente, \nINF\t12\tProcesso 12 terminato\nUSR\t5\tTEST 4 PROC 5: OK\nDBG\t5\tTEST 4: === FINE ===\nDBG\t5\tTEST 5: >>>INIZIO<<<: scrittura prima e dopo la copia\nINF\t5\tproc=14 entry=t05p0b(unsigned long) [utente.cpp:184](5) prio=594 liv=3\nWRN\t14\tEccezione 14 (page fault), errore 7, RIP t05p0b(unsigned long) [utente.cpp:186 (discriminator 1)]\nWRN\t14\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t14\t  dettagli: protezione, scrittura, da utente, \nINF\t14\tproc=15 entry=t05p1b(unsigned long) [utente.cpp:175](5) prio=298 liv=3\nUSR\t14\tTEST 5 PROC 14: ERRORE: generati 0 page fault invece di 1\nINF\t14\tProcesso 14 terminato\nINF\t13\tProcesso 13 terminato\nUSR\t15\tTEST 5 PROC 15: ERRORE: letto 79 invece di 78\nDBG\t5\tTEST 5: === FINE ===\nDBG\t5\tTEST 6: >>>INIZIO<<<: copia della copia\nINF\t5\tproc=16 entry=t06p0b(unsigned long) [utente.cpp:229](6) prio=593 liv=3\nWRN\t16\tEccezione 14 (page fault), errore 7, RIP t06p0b(unsigned long) [utente.cpp:231 (discriminator 1)]\nWRN\t16\t  indirizzo virtuale: ffffc000000004d2 \nWRN\t16\t  dettagli: protezione, scrittura, da utente, \nINF\t16\tproc=17 entry=t06p1b(unsigned long) [utente.cpp:216](6) prio=297 liv=3\nUSR\t16\tTEST 6 PROC 16: ERRORE: generati 0 page fault invece di 1\nINF\t16\tProcesso 16 terminato\nINF\t15\tProcesso 15 terminato\nUSR\t17\tTEST 6 PROC 17: ERRORE: letto 59 invece di 58\nINF\t17\tProcesso 17 terminato\nqemu-system-x86_64: terminating on signal 15 from pid 1939 (timeout)\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=25, offset=864]\u001b[0m\nI see the issue - `copia_cow` needs to handle pages at all levels, not just the root table. Let me fix this:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=35, offset=885]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"PART_SIZE\"\u001b[90m 17 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"dim_region\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -862,19 +862,18 @@\n  * @param dest\tindirizzo della tabelal radice del TRIE destinatario\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(voidptr_cast(src));\n-\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n-\t\n-\tfor (natl i = I_UTN_W; i < I_UTN_W + N_UTN_W; i++) {\n-\t\ttab_entry e = src_tab[i];\n+\tfor (tab_iter it(src, ini_utn_w, DIM_USR_COW); it; it.next()) {\n+\t\ttab_entry e = it.get_e();\n \t\tif (!(e & BIT_P))\n \t\t\tcontinue;\n \t\te &= ~BIT_RW;\n-\t\tsrc_tab[i] = e;\n-\t\tdest_tab[i] = e;\n+\t\tit.get_e() = e;\n \t\t\n+\t\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n+\t\tdest_tab[it.get_idx()] = e;\n+\t\t\n \t\tpaddr f = extr_IND_FISICO(e);\n \t\tvdf[f / DIM_PAGINA].nshared += 2;\n \t}\n }\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\nsistema/sistema.cpp: In function 'void copia_cow(paddr, paddr)':\nsistema/sistema.cpp:874:29: error: 'class tab_iter' has no member named 'get_idx'; did you mean 'get_l'?\n  874 |                 dest_tab[it.get_idx()] = e;\n      |                             ^~~~~~~\n      |                             get_l\nmake: *** [Makefile:130: boot/0-sistema] Error 1\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"vaddr map\\(|bool map\\(\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"base\\(|idx\\(\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"^vaddr base|^natq base\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -862,20 +862,45 @@\n  * @param dest\tindirizzo della tabelal radice del TRIE destinatario\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-\tfor (tab_iter it(src, ini_utn_w, DIM_USR_COW); it; it.next()) {\n-\t\ttab_entry e = it.get_e();\n-\t\tif (!(e & BIT_P))\n+\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(voidptr_cast(src));\n+\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n+\t\n+\tfor (natl i = I_UTN_W; i < I_UTN_W + N_UTN_W; i++) {\n+\t\tif (!(src_tab[i] & BIT_P))\n \t\t\tcontinue;\n-\t\te &= ~BIT_RW;\n-\t\tit.get_e() = e;\n \t\t\n-\t\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n-\t\tdest_tab[it.get_idx()] = e;\n+\t\tpaddr l3 = extr_IND_FISICO(src_tab[i]);\n+\t\ttab_entry* l3_src = reinterpret_cast<tab_entry*>(voidptr_cast(l3));\n+\t\ttab_entry* l3_dest = reinterpret_cast<tab_entry*>(voidptr_cast(dest_tab[i]));\n \t\t\n-\t\tpaddr f = extr_IND_FISICO(e);\n-\t\tvdf[f / DIM_PAGINA].nshared += 2;\n+\t\tsrc_tab[i] &= ~BIT_RW;\n+\t\tdest_tab[i] = src_tab[i];\n+\t\t\n+\t\tfor (natl j = 0; j < 512; j++) {\n+\t\t\tif (!(l3_src[j] & BIT_P))\n+\t\t\t\tcontinue;\n+\t\t\t\n+\t\t\tpaddr l2 = extr_IND_FISICO(l3_src[j]);\n+\t\t\ttab_entry* l2_src = reinterpret_cast<tab_entry*>(voidptr_cast(l2));\n+\t\t\ttab_entry* l2_dest = reinterpret_cast<tab_entry*>(voidptr_cast(l3_dest[j]));\n+\t\t\t\n+\t\t\tl3_src[j] &= ~BIT_RW;\n+\t\t\tl3_dest[j] = l3_src[j];\n+\t\t\t\n+\t\t\tfor (natl k = 0; k < 512; k++) {\n+\t\t\t\tif (!(l2_src[k] & BIT_P))\n+\t\t\t\t\tcontinue;\n+\t\t\t\t\n+\t\t\t\tpaddr l1 = extr_IND_FISICO(l2_src[k]);\n+\t\t\t\t\n+\t\t\t\tl2_src[k] &= ~BIT_RW;\n+\t\t\t\tl2_dest[k] = l2_src[k];\n+\t\t\t\t\n+\t\t\t\tvdf[l1 / DIM_PAGINA].nshared += 2;\n+\t\t\t}\n+\t\t}\n \t}\n }\n \n // ( SOLUZIONE 2023-09-13\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 6 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   7118 memsize   7118\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   315c memsize   315c\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  10c24\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=124590 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   2f30 memsize   2f30\nINF\t-\t  . seg[2]: off   3000 vaddr ffff800000003000 size    de4 memsize    de4\nINF\t-\t  . seg[3]: off   4000 vaddr ffff800000004000 size    1a0 memsize    248\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   7118 byte da   10c000 a   200000\nINF\t-\t- copiati   315c byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 10aa4 byte\nINF\t-\t- entry point 205f3d\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,           600000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [          600000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 541 (M1) 995 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/cow  [ffffc00000000000, ffffe00000000000)\nINF\t0\t- usr/priv [ffffe00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000003000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000003000, ffff800000004000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000004000, ffff800000005000)\nINF\t0\t - heap:                                 [ffff800000005000, ffff800000105000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tCreata la zona utente copy-on-write\nINF\t0\tFrame liberi: 460 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nWRN\t0\tEccezione 14 (page fault), errore 0, RIP copia_cow(unsigned long, unsigned long) [sistema.cpp:886]\nWRN\t0\t  indirizzo virtuale: 0 (probabile puntatore NULL)\nWRN\t0\t  dettagli: pag o tab assente, lettura, da sistema, \nERR\t0\tPANIC: ERRORE DI SISTEMA\nERR\t0\t  processi: 0\nERR\t0\t------------------------------ PROCESSO IN ESECUZIONE -------------------------------\nERR\t0\tcorpo main [sistema.cpp:1609](0), livello SISTEMA, precedenza 0\nERR\t0\t  RIP=panic [sistema.cpp:1936] CPL=LIV_SISTEMA\nERR\t0\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t0\t  RAX=               a RBX=               0 RCX=               0 RDX=          2103f8\nERR\t0\t  RDI=               3 RSI=             3f8 RBP=          21c918 RSP=          21c910\nERR\t0\t  R8 =              30 R9 =          21c737 R10=               0 R11=               0\nERR\t0\t  R12=               e R13=          20093f R14=               0 R15=          430000\nERR\t0\t  backtrace:\nERR\t0\t  > gestore_eccezioni [sistema.cpp:454]\nERR\t0\t  > exc_page_fault [sistema.s:812]\nERR\t0\t  > copia_cow(unsigned long, unsigned long) [sistema.cpp:886]\nERR\t0\t  > crea_processo(void (*)(unsigned long), unsigned long, int, char) [sistema.cpp:1146 (discriminator 1)]\nERR\t0\t  > main [sistema.cpp:1711 (discriminator 1)]\nERR\t0\t  > _start [start64.s:33]\nERR\t0\t---------------------------------- ALTRI PROCESSI -----------------------------------\nERR\t0\tproc 1: corpo 0x0(0), livello SISTEMA, precedenza 1278\nERR\t0\t  impossibile leggere la pila del processo\nERR\t0\t  RIP=0x0 CPL=LIV_SISTEMA\nERR\t0\t  RFLAGS=0 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nERR\t0\t  RAX=               0 RBX=               0 RCX=               0 RDX=               0\nERR\t0\t  RDI=          21ca3c RSI=               0 RBP=               0 RSP=               0\nERR\t0\t  R8 =               0 R9 =               0 R10=               0 R11=               0\nERR\t0\t  R12=               0 R13=               0 R14=               0 R15=               0\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=60, offset=1680]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mpython3 -c \"print(hex(384 * (512 * 512 * 512 * 4096) // 512))\"\n0x6000000000\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"primi_frame_libero|primo_frame\"\u001b[90m 12 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=35, offset=875]\u001b[0m\nI see the issue now. When `copia_cow` is called during the creation of the init process, the source process doesn't have the COW zone mapped yet. I need to check if the source has the COW zone before trying to copy:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -871,24 +871,26 @@\n \tcontinue;\n \n paddr l3 = extr_IND_FISICO(src_tab[i]);\n tab_entry* l3_src = reinterpret_cast<tab_entry*>(voidptr_cast(l3));\n-tab_entry* l3_dest = reinterpret_cast<tab_entry*>(voidptr_cast(dest_tab[i]));\n \n src_tab[i] &= ~BIT_RW;\n dest_tab[i] = src_tab[i];\n \n+tab_entry* l3_dest = reinterpret_cast<tab_entry*>(voidptr_cast(dest_tab[i]));\n+\n for (natl j = 0; j < 512; j++) {\n \tif (!(l3_src[j] & BIT_P))\n \t\tcontinue;\n \t\n \tpaddr l2 = extr_IND_FISICO(l3_src[j]);\n \ttab_entry* l2_src = reinterpret_cast<tab_entry*>(voidptr_cast(l2));\n-\ttab_entry* l2_dest = reinterpret_cast<tab_entry*>(voidptr_cast(l3_dest[j]));\n \t\n \tl3_src[j] &= ~BIT_RW;\n \tl3_dest[j] = l3_src[j];\n \t\n+\ttab_entry* l2_dest = reinterpret_cast<tab_entry*>(voidptr_cast(l3_dest[j]));\n+\t\n \tfor (natl k = 0; k < 512; k++) {\n \t\tif (!(l2_src[k] & BIT_P))\n \t\t\tcontinue;\n \t\t\n\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"init.cr3|crea_processo.*init\"\u001b[90m 5 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"crea_processo.*init|init = crea_processo\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"init\\s*=\"\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"des_proc init\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=1605]\u001b[0m\n\u001b[93m\u001b[1m! \u001b[0m maximum turns of 100 reached, stopping session\n",
  "duration_seconds": 637.16,
  "turns": 100,
  "max_turns": 100,
  "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex b7626da..dc591b2 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -863,9 +863,46 @@ bool crea_cow(paddr dest)\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-/// @todo Realizzare la copia.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(voidptr_cast(src));\n+\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n+\t\n+\tfor (natl i = I_UTN_W; i < I_UTN_W + N_UTN_W; i++) {\n+\t\tif (!(src_tab[i] & BIT_P))\n+\t\t\tcontinue;\n+\t\t\n+\t\tpaddr l3 = extr_IND_FISICO(src_tab[i]);\n+\t\ttab_entry* l3_src = reinterpret_cast<tab_entry*>(voidptr_cast(l3));\n+\t\t\n+\t\tsrc_tab[i] &= ~BIT_RW;\n+\t\tdest_tab[i] = src_tab[i];\n+\t\t\n+\t\ttab_entry* l3_dest = reinterpret_cast<tab_entry*>(voidptr_cast(dest_tab[i]));\n+\t\t\n+\t\tfor (natl j = 0; j < 512; j++) {\n+\t\t\tif (!(l3_src[j] & BIT_P))\n+\t\t\t\tcontinue;\n+\t\t\t\n+\t\t\tpaddr l2 = extr_IND_FISICO(l3_src[j]);\n+\t\t\ttab_entry* l2_src = reinterpret_cast<tab_entry*>(voidptr_cast(l2));\n+\t\t\t\n+\t\t\tl3_src[j] &= ~BIT_RW;\n+\t\t\tl3_dest[j] = l3_src[j];\n+\t\t\t\n+\t\t\ttab_entry* l2_dest = reinterpret_cast<tab_entry*>(voidptr_cast(l3_dest[j]));\n+\t\t\t\n+\t\t\tfor (natl k = 0; k < 512; k++) {\n+\t\t\t\tif (!(l2_src[k] & BIT_P))\n+\t\t\t\t\tcontinue;\n+\t\t\t\t\n+\t\t\t\tpaddr l1 = extr_IND_FISICO(l2_src[k]);\n+\t\t\t\t\n+\t\t\t\tl2_src[k] &= ~BIT_RW;\n+\t\t\t\tl2_dest[k] = l2_src[k];\n+\t\t\t\t\n+\t\t\t\tvdf[l1 / DIM_PAGINA].nshared += 2;\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n // ( SOLUZIONE 2023-09-13\n@@ -900,9 +937,16 @@ bool aggiorna_cow(vaddr v)\n \t\t}\n \t\tset_IND_FISICO(e, new_frame);\n \t\te |= BIT_RW;\n-/// @todo Completare l'aggiornamento dello stato.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\t\t\n+\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\n+\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\tif (vdf[old_frame / DIM_PAGINA].nshared == 0) {\n+\t\t\tif (it.get_l() > 1)\n+\t\t\t\trilascia_tab(old_frame);\n+\t\t\telse\n+\t\t\t\trilascia_frame(old_frame);\n+\t\t}\n \t}\n \treturn true;\n }\n@@ -912,9 +956,18 @@ bool aggiorna_cow(vaddr v)\n  */\n void distruggi_cow()\n {\n-//// @todo Realizzare la funzione.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\tfor (tab_iter it(esecuzione->cr3, ini_utn_w, DIM_USR_COW); it; it.next()) {\n+\t\ttab_entry e = it.get_e();\n+\t\tif (!(e & BIT_P))\n+\t\t\tcontinue;\n+\t\tif (it.get_l() > 1)\n+\t\t\tcontinue;\n+\t\tpaddr f = extr_IND_FISICO(e);\n+\t\tvdf[f / DIM_PAGINA].nshared--;\n+\t\tif (vdf[f / DIM_PAGINA].nshared == 0) {\n+\t\t\trilascia_frame(f);\n+\t\t}\n+\t}\n }\n //   ESAME 2023-09-13 )\n \ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex b7626da..dc591b2 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -863,9 +863,46 @@ bool crea_cow(paddr dest)\n  */\n void copia_cow(paddr src, paddr dest)\n {\n-/// @todo Realizzare la copia.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\ttab_entry* src_tab = reinterpret_cast<tab_entry*>(voidptr_cast(src));\n+\ttab_entry* dest_tab = reinterpret_cast<tab_entry*>(voidptr_cast(dest));\n+\t\n+\tfor (natl i = I_UTN_W; i < I_UTN_W + N_UTN_W; i++) {\n+\t\tif (!(src_tab[i] & BIT_P))\n+\t\t\tcontinue;\n+\t\t\n+\t\tpaddr l3 = extr_IND_FISICO(src_tab[i]);\n+\t\ttab_entry* l3_src = reinterpret_cast<tab_entry*>(voidptr_cast(l3));\n+\t\t\n+\t\tsrc_tab[i] &= ~BIT_RW;\n+\t\tdest_tab[i] = src_tab[i];\n+\t\t\n+\t\ttab_entry* l3_dest = reinterpret_cast<tab_entry*>(voidptr_cast(dest_tab[i]));\n+\t\t\n+\t\tfor (natl j = 0; j < 512; j++) {\n+\t\t\tif (!(l3_src[j] & BIT_P))\n+\t\t\t\tcontinue;\n+\t\t\t\n+\t\t\tpaddr l2 = extr_IND_FISICO(l3_src[j]);\n+\t\t\ttab_entry* l2_src = reinterpret_cast<tab_entry*>(voidptr_cast(l2));\n+\t\t\t\n+\t\t\tl3_src[j] &= ~BIT_RW;\n+\t\t\tl3_dest[j] = l3_src[j];\n+\t\t\t\n+\t\t\ttab_entry* l2_dest = reinterpret_cast<tab_entry*>(voidptr_cast(l3_dest[j]));\n+\t\t\t\n+\t\t\tfor (natl k = 0; k < 512; k++) {\n+\t\t\t\tif (!(l2_src[k] & BIT_P))\n+\t\t\t\t\tcontinue;\n+\t\t\t\t\n+\t\t\t\tpaddr l1 = extr_IND_FISICO(l2_src[k]);\n+\t\t\t\t\n+\t\t\t\tl2_src[k] &= ~BIT_RW;\n+\t\t\t\tl2_dest[k] = l2_src[k];\n+\t\t\t\t\n+\t\t\t\tvdf[l1 / DIM_PAGINA].nshared += 2;\n+\t\t\t}\n+\t\t}\n+\t}\n }\n \n // ( SOLUZIONE 2023-09-13\n@@ -900,9 +937,16 @@ bool aggiorna_cow(vaddr v)\n \t\t}\n \t\tset_IND_FISICO(e, new_frame);\n \t\te |= BIT_RW;\n-/// @todo Completare l'aggiornamento dello stato.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\t\t\n+\t\tvdf[new_frame / DIM_PAGINA].nshared = 1;\n+\t\t\n+\t\tvdf[old_frame / DIM_PAGINA].nshared--;\n+\t\tif (vdf[old_frame / DIM_PAGINA].nshared == 0) {\n+\t\t\tif (it.get_l() > 1)\n+\t\t\t\trilascia_tab(old_frame);\n+\t\t\telse\n+\t\t\t\trilascia_frame(old_frame);\n+\t\t}\n \t}\n \treturn true;\n }\n@@ -912,9 +956,18 @@ bool aggiorna_cow(vaddr v)\n  */\n void distruggi_cow()\n {\n-//// @todo Realizzare la funzione.\n-// ( SOLUZIONE 2023-09-13\n-//   SOLUZIONE 2023-09-13 )\n+\tfor (tab_iter it(esecuzione->cr3, ini_utn_w, DIM_USR_COW); it; it.next()) {\n+\t\ttab_entry e = it.get_e();\n+\t\tif (!(e & BIT_P))\n+\t\t\tcontinue;\n+\t\tif (it.get_l() > 1)\n+\t\t\tcontinue;\n+\t\tpaddr f = extr_IND_FISICO(e);\n+\t\tvdf[f / DIM_PAGINA].nshared--;\n+\t\tif (vdf[f / DIM_PAGINA].nshared == 0) {\n+\t\t\trilascia_frame(f);\n+\t\t}\n+\t}\n }\n //   ESAME 2023-09-13 )\n \n",
  "error": null
}