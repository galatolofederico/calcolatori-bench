{
  "passed": false,
  "output": [
    "TEST 1 PROC 4: OK"
  ],
  "expected": [
    "TEST 1 PROC 4: OK",
    "TEST 2 PROC 4: OK",
    "TEST 3 PROC 4: OK",
    "TEST 4 PROC 4: OK",
    "TEST 5 PROC 4: OK",
    "TEST 6 PROC 4: OK",
    "TEST 7 PROC 4: OK",
    "Premere un tasto per continuare"
  ],
  "boot_output": "\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=118b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   70f6 memsize   70f6\nINF\t-\t  . seg[2]: off   8000 vaddr           208000 size   3374 memsize   3374\nINF\t-\t  . seg[3]: off   c000 vaddr           20c000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=119000 end=11f578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=120000 end=1276c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   70f6 byte da   10c000 a   200000\nINF\t-\t- copiati   3374 byte da   114000 a   208000\nINF\t-\t- copiati    180 byte da   118000 a   20c000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205f1b\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 548 (M1) 7644 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7111 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nDBG\t5\trw_upgrade: proc=5 start\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t5\t  R8 =              35 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=              64 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2037]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nDBG\t6\trw_upgrade: proc=6 start\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t6\t  R8 =              36 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2046]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nDBG\t7\trw_downgrade: proc=7 start\nDBG\t7\trw_downgrade: proc=7 nreaders=0 writer=0\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=          20c1a0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2089]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nDBG\t8\trw_upgrade: proc=8 start\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t8\t  R8 =              38 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t8\t  R12=ffff8000000077c4 R13=               0 R14=            1980 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2046]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nDBG\t9\trw_downgrade: proc=9 start\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10\nDBG\t10\trw_downgrade: proc=10 start\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nDBG\t12\trw_upgrade: proc=12 start\nDBG\t12\trw_upgrade: proc=12 nreaders=1 writer=0\nDBG\t12\trw_upgrade: proc=12 waiting nreaders=1 writer=0\nDBG\t13\trw_upgrade: proc=13 woke up nreaders=1 writer=0\nDBG\t13\trw_upgrade: proc=13 waiting nreaders=1 writer=0\nDBG\t0\trw_upgrade: proc=0 woke up nreaders=1 writer=0\nDBG\t0\trw_upgrade: proc=0 waiting nreaders=1 writer=0\n",
  "agent_output": "Performing one time database migration, may take a few minutes...\nsqlite-migration:done\nDatabase migration complete.\n\u001b[0m\n> build \u00b7 minimax/minimax-m2.5:nitro\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGlob \"**/*\"\u001b[90m 93 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"ESAME|SOLUZIONE\"\u001b[90m 22 matches\u001b[0m\nLet me read the key sections of the source files to understand the implementation required:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=2020]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=100, offset=1010]\u001b[0m\nLet me look at the beginning of sistema.cpp to understand the structures and existing implementations:\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=80, offset=1]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"des_rw|rw_init|rw_writlock|rw_readlock|rw_upgrade|rw_downgrade\"\u001b[90m 76 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=120, offset=1870]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=1989]\u001b[0m\nLet me also look at the utente.cpp to understand what tests expect:\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=100, offset=60]\u001b[0m\nLet me also check the costanti.h file for MAX_PROC_RW and MAX_RW values:\n\u001b[0m\u2731 \u001b[0mGrep \"MAX_PROC_RW|MAX_RW\"\u001b[90m 2 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"inserimento_lista|rimuovi_dalla_lista\"\u001b[90m 9 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=90]\u001b[0m\nNow I understand the requirements. Let me implement the `rw_upgrade` and `rw_downgrade` functions:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2025,8 +2025,71 @@\n \t\tr->nreaders++;\n \t}\n }\n // ( SOLUZIONE 2024-09-11\n+\n+/// Parte C++ della primitiva rw_upgrade()\n+extern \"C\" void c_rw_upgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state != RW_READER) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): lock in lettura non posseduto\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tr->nreaders--;\n+\trp->state = RW_NONE;\n+\n+\tif (r->nreaders > 0 || r->writer) {\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\trp->state = RW_UPGRADED;\n+\t\tr->writer = esecuzione->id;\n+\t}\n+}\n+\n+/// Parte C++ della primitiva rw_downgrade()\n+extern \"C\" void c_rw_downgrade(natl rw)\n+{\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state == RW_NONE) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): lock non posseduto\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tif (rp->state == RW_UPGRADED) {\n+\t\tr->writer = 0;\n+\t\trp->state = RW_READER;\n+\t\tr->nreaders++;\n+\t} else if (rp->state == RW_WRITER) {\n+\t\tr->writer = 0;\n+\t\trp->state = RW_NONE;\n+\t} else if (rp->state == RW_READER) {\n+\t\tr->nreaders--;\n+\t\trp->state = RW_NONE;\n+\t}\n+\n+\trp->r = nullptr;\n+}\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \n /// @}\n\n\u001b[0m\nNow let me compile the code to verify it works:\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n   [make] ==> Assemblo io/io.s\n   [make] ==> Compilo  io/io.cpp\n   [make] ==> Collego  debug/1-io      [0x10000000000]\n   [make] ==> Genero   boot/1-io\n   [make] ==> Assemblo utente/utente.s\n   [make] ==> Compilo  utente/lib.cpp\n   [make] ==> Compilo  utente/utente.cpp\n   [make] ==> Collego  debug/2-utente  [0xffff800000000000]\n   [make] ==> Genero   boot/2-utente\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1 | grep -E \"^(USR|ERR|panic)\" | head -100\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6de8 memsize   6de8\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31c4 memsize   31c4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6de8 byte da   10c000 a   200000\nINF\t-\t- copiati   31c4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205c0d\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t5\t  R8 =              35 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t6\t  R8 =              36 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t7\t  R8 =              37 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2074]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t8\t  R8 =              38 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t9\t  R8 =              39 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2065]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nWRN\t10\trw_downgrade(1): lock non posseduto\nWRN\t10\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t10\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t10\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t10\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t10\t  R8 =              30 R9 =      fffffffde8 R10=               0 R11=               0\nWRN\t10\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t10\t  backtrace:\nWRN\t10\t  > c_rw_downgrade [sistema.cpp:2074]\nWRN\t10\t  > a_rw_downgrade [sistema.s:460]\nWRN\t10\t  > rw_downgrade [utente.s:176]\nWRN\t10\t  > t01p0b(unsigned long) [utente.cpp:118]\nWRN\t10\tProcesso 10 abortito\nqemu-system-x86_64: terminating on signal 15 from pid 573 (timeout)\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=50, offset=107]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=1945]\u001b[0m\nI see the bug! In `rw_downgrade`, I'm setting `rp->r = nullptr` even when downgrading (which should keep the lock). Let me fix this:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2080,15 +2080,15 @@\n \t\trp->state = RW_READER;\n \t\tr->nreaders++;\n \t} else if (rp->state == RW_WRITER) {\n \t\tr->writer = 0;\n+\t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n \t} else if (rp->state == RW_READER) {\n \t\tr->nreaders--;\n+\t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n \t}\n-\n-\trp->r = nullptr;\n }\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6de8 memsize   6de8\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31c4 memsize   31c4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6de8 byte da   10c000 a   200000\nINF\t-\t- copiati   31c4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205c0d\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t5\t  R8 =              35 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t6\t  R8 =              36 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t7\t  R8 =              37 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2074]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t8\t  R8 =              38 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t9\t  R8 =              39 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2065]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t13\tProcesso 13 terminato\nqemu-system-x86_64: terminating on signal 15 from pid 809 (timeout)\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"PSEQ|chkseq\"\u001b[90m 60 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"rw_writelock|rw_readlock\"\u001b[90m 26 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"w_writers|w_readers\"\u001b[90m 7 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"rw_\"\u001b[90m 11 matches\u001b[0m\nLet me search for any rwlock-related functions in the header files:\n\u001b[0m\u2731 \u001b[0mGrep \"sem_ini|sem_wait\"\u001b[90m 4 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=60, offset=32]\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"sem_signal\"\u001b[90m 33 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=40, offset=156]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=275]\u001b[0m\nI see the issue now. My implementation doesn't wake up waiting writers when a read lock is released. Looking at the existing code, I need to add wakeup logic in `rw_downgrade`. Let me also check if there's a pattern in the semaphore code:\n\u001b[0m\u2731 \u001b[0mGrep \"rimuovi_dalla_lista\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"rimuovi\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"rimuovi\"\u001b[90m 0 matches\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=90]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=119]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=70, offset=2028]\u001b[0m\nI need to add wakeup logic for waiting processes when locks are released. Let me update the implementation:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2082,12 +2082,30 @@\n \t} else if (rp->state == RW_WRITER) {\n \t\tr->writer = 0;\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t} else if (r->w_readers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t\tr->nreaders++;\n+\t\t}\n \t} else if (rp->state == RW_READER) {\n \t\tr->nreaders--;\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n+\t\tif (r->nreaders == 0 && r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t}\n \t}\n }\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 10s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6eec memsize   6eec\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31cc memsize   31cc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6eec byte da   10c000 a   200000\nINF\t-\t- copiati   31cc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d11\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t5\t  R8 =              35 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t6\t  R8 =              36 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2074]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t8\t  R8 =              38 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2065]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\n\u001b[0m\nI see the issue. When a waiting writer is woken up, it needs to properly acquire the lock. Let me also handle the case where multiple writers are waiting:\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2078,8 +2078,14 @@\n if (rp->state == RW_UPGRADED) {\n \tr->writer = 0;\n \trp->state = RW_READER;\n \tr->nreaders++;\n+\tif (r->w_writers) {\n+\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\tlavoro->puntatore = nullptr;\n+\t\tinspronti();\n+\t\tinserimento_lista(pronti, lavoro);\n+\t}\n } else if (rp->state == RW_WRITER) {\n \tr->writer = 0;\n \trp->r = nullptr;\n \trp->state = RW_NONE;\n\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=40, offset=1957]\u001b[0m\nI see the issue now - when a process wakes up, it needs to retry acquiring the lock. Let me add a loop to the upgrade function:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2044,17 +2044,20 @@\n \t\tc_abort_p();\n \t\treturn;\n \t}\n \n-\tr->nreaders--;\n-\trp->state = RW_NONE;\n+\twhile (true) {\n+\t\tr->nreaders--;\n+\t\trp->state = RW_NONE;\n \n-\tif (r->nreaders > 0 || r->writer) {\n-\t\tinserimento_lista(r->w_writers, esecuzione);\n-\t\tschedulatore();\n-\t} else {\n-\t\trp->state = RW_UPGRADED;\n-\t\tr->writer = esecuzione->id;\n+\t\tif (r->nreaders > 0 || r->writer) {\n+\t\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\t\tschedulatore();\n+\t\t} else {\n+\t\t\trp->state = RW_UPGRADED;\n+\t\t\tr->writer = esecuzione->id;\n+\t\t\tbreak;\n+\t\t}\n \t}\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f30 memsize   6f30\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31cc memsize   31cc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f30 byte da   10c000 a   200000\nINF\t-\t- copiati   31cc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d55\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t5\t  R8 =              35 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t6\t  R8 =              36 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2077]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t8\t  R8 =              38 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t8\t  R12=            1980 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2068]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\nINF\t13\tProcesso 13 terminato\nqemu-system-x86_64: terminating on signal 15 from pid 1583 (timeout)\n\u001b[0m\nI see the issue - when a writer is woken up, it decrements nreaders again, but nreaders is already 0 (since the reader released the lock). The writer should not decrement nreaders when it wakes up and acquires the lock. Let me fix this:\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2056,8 +2056,12 @@\n \t\t\trp->state = RW_UPGRADED;\n \t\t\tr->writer = esecuzione->id;\n \t\t\tbreak;\n \t\t}\n+\n+\t\tif (r->writer == 0 && (!r->w_writers || r->w_writers->id != esecuzione->id)) {\n+\t\t\tbreak;\n+\t\t}\n \t}\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2044,11 +2044,15 @@\n \t\tc_abort_p();\n \t\treturn;\n \t}\n \n+\tbool gia_rilasciato = false;\n \twhile (true) {\n-\t\tr->nreaders--;\n-\t\trp->state = RW_NONE;\n+\t\tif (!gia_rilasciato) {\n+\t\t\tr->nreaders--;\n+\t\t\trp->state = RW_NONE;\n+\t\t\tgia_rilasciato = true;\n+\t\t}\n \n \t\tif (r->nreaders > 0 || r->writer) {\n \t\t\tinserimento_lista(r->w_writers, esecuzione);\n \t\t\tschedulatore();\n@@ -2056,12 +2060,8 @@\n \t\t\trp->state = RW_UPGRADED;\n \t\t\tr->writer = esecuzione->id;\n \t\t\tbreak;\n \t\t}\n-\n-\t\tif (r->writer == 0 && (!r->w_writers || r->w_writers->id != esecuzione->id)) {\n-\t\t\tbreak;\n-\t\t}\n \t}\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f5c memsize   6f5c\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f5c byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d81\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t5\t  R8 =              35 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t6\t  R8 =              36 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=            7701 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2081]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t8\t  R8 =              38 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t8\t  R12=            1980 R13=               1 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2072]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"USR|ERR|panic|TEST\"\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=2030]\u001b[0m\nLet me add some debug logging to understand what's happening:\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2052,14 +2052,18 @@\n \t\t\trp->state = RW_NONE;\n \t\t\tgia_rilasciato = true;\n \t\t}\n \n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d nreaders=%d writer=%d gia_rilasciato=%d\",\n+\t\t\tesecuzione->id, r->nreaders, r->writer, gia_rilasciato);\n+\n \t\tif (r->nreaders > 0 || r->writer) {\n \t\t\tinserimento_lista(r->w_writers, esecuzione);\n \t\t\tschedulatore();\n \t\t} else {\n \t\t\trp->state = RW_UPGRADED;\n \t\t\tr->writer = esecuzione->id;\n+\t\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d acquired write lock\", esecuzione->id);\n \t\t\tbreak;\n \t\t}\n \t}\n }\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*rw_upgrade\"\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t12\trw_upgrade: proc=12 nreaders=1 writer=0 gia_rilasciato=1\nDBG\t13\trw_upgrade: proc=13 nreaders=1 writer=0 gia_rilasciato=1\nDBG\t0\trw_upgrade: proc=0 nreaders=1 writer=0 gia_rilasciato=1\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2070,15 +2070,20 @@\n \n /// Parte C++ della primitiva rw_downgrade()\n extern \"C\" void c_rw_downgrade(natl rw)\n {\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d\", esecuzione->id);\n+\n \tif (!rw_valido(rw)) {\n \t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n \t\tc_abort_p();\n \t\treturn;\n \t}\n \n \tdes_rw *r = &array_desrw[rw];\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d nreaders=%d writer=%d state=%d\",\n+\t\tesecuzione->id, r->nreaders, r->writer, rw_proc_find(r) ? rw_proc_find(r)->state : -1);\n+\n \tdes_proc_rw *rp = rw_proc_find(r);\n \n \tif (!rp || rp->state == RW_NONE) {\n \t\tflog(LOG_WARN, \"rw_downgrade(%d): lock non posseduto\", rw);\n@@ -2115,11 +2120,14 @@\n \t} else if (rp->state == RW_READER) {\n \t\tr->nreaders--;\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n+\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d after decrement nreaders=%d w_writers=%p\",\n+\t\t\tesecuzione->id, r->nreaders, r->w_writers);\n \t\tif (r->nreaders == 0 && r->w_writers) {\n \t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n \t\t\tlavoro->puntatore = nullptr;\n+\t\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d waking up proc=%d\", esecuzione->id, lavoro->id);\n \t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, lavoro);\n \t\t}\n \t}\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*rw_\" | head -50\nDBG\t7\trw_downgrade: proc=7\nDBG\t7\trw_downgrade: proc=7 nreaders=0 writer=0 state=-1\nDBG\t9\trw_downgrade: proc=9\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0 state=2\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0 state=2\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0 state=2\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0 state=2\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0 state=2\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=1 writer=0 state=2\nDBG\t10\trw_downgrade: proc=10 after decrement nreaders=0 w_writers=0x0\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0 gia_rilasciato=1\nDBG\t10\trw_upgrade: proc=10 acquired write lock\nDBG\t10\trw_downgrade: proc=10\nDBG\t10\trw_downgrade: proc=10 nreaders=0 writer=10 state=3\nDBG\t10\trw_downgrade: proc=10\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*(11|12|13).*rw_\"\nDBG\t12\trw_upgrade: proc=12 nreaders=1 writer=0 gia_rilasciato=1\nDBG\t13\trw_upgrade: proc=13 nreaders=1 writer=0 gia_rilasciato=1\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2052,20 +2052,22 @@\n \t\t\trp->state = RW_NONE;\n \t\t\tgia_rilasciato = true;\n \t\t}\n \n-\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d nreaders=%d writer=%d gia_rilasciato=%d\",\n-\t\t\tesecuzione->id, r->nreaders, r->writer, gia_rilasciato);\n-\n \t\tif (r->nreaders > 0 || r->writer) {\n \t\t\tinserimento_lista(r->w_writers, esecuzione);\n \t\t\tschedulatore();\n \t\t} else {\n \t\t\trp->state = RW_UPGRADED;\n \t\t\tr->writer = esecuzione->id;\n-\t\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d acquired write lock\", esecuzione->id);\n \t\t\tbreak;\n \t\t}\n+\n+\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n+\t\t\trp->r = nullptr;\n+\t\t\trp->state = RW_NONE;\n+\t\t\tbreak;\n+\t\t}\n \t}\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2072,20 +2072,15 @@\n \n /// Parte C++ della primitiva rw_downgrade()\n extern \"C\" void c_rw_downgrade(natl rw)\n {\n-\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d\", esecuzione->id);\n-\n \tif (!rw_valido(rw)) {\n \t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n \t\tc_abort_p();\n \t\treturn;\n \t}\n \n \tdes_rw *r = &array_desrw[rw];\n-\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d nreaders=%d writer=%d state=%d\",\n-\t\tesecuzione->id, r->nreaders, r->writer, rw_proc_find(r) ? rw_proc_find(r)->state : -1);\n-\n \tdes_proc_rw *rp = rw_proc_find(r);\n \n \tif (!rp || rp->state == RW_NONE) {\n \t\tflog(LOG_WARN, \"rw_downgrade(%d): lock non posseduto\", rw);\n@@ -2122,14 +2117,11 @@\n \t} else if (rp->state == RW_READER) {\n \t\tr->nreaders--;\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n-\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d after decrement nreaders=%d w_writers=%p\",\n-\t\t\tesecuzione->id, r->nreaders, r->w_writers);\n \t\tif (r->nreaders == 0 && r->w_writers) {\n \t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n \t\t\tlavoro->puntatore = nullptr;\n-\t\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d waking up proc=%d\", esecuzione->id, lavoro->id);\n \t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, lavoro);\n \t\t}\n \t}\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f98 memsize   6f98\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31dc memsize   31dc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f98 byte da   10c000 a   200000\nINF\t-\t- copiati   31dc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205dbd\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t5\t  R8 =              35 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t5\t  R12=              64 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t6\t  R8 =              36 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2087]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t8\t  R8 =              38 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t8\t  R12=               0 R13=               0 R14=               0 R15=            1980\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2055,19 +2055,18 @@\n \n \t\tif (r->nreaders > 0 || r->writer) {\n \t\t\tinserimento_lista(r->w_writers, esecuzione);\n \t\t\tschedulatore();\n+\t\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n+\t\t\t\trp->r = nullptr;\n+\t\t\t\trp->state = RW_NONE;\n+\t\t\t\tbreak;\n+\t\t\t}\n \t\t} else {\n \t\t\trp->state = RW_UPGRADED;\n \t\t\tr->writer = esecuzione->id;\n \t\t\tbreak;\n \t\t}\n-\n-\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n-\t\t\trp->r = nullptr;\n-\t\t\trp->state = RW_NONE;\n-\t\t\tbreak;\n-\t\t}\n \t}\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f98 memsize   6f98\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31dc memsize   31dc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f98 byte da   10c000 a   200000\nINF\t-\t- copiati   31dc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205dbd\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t5\t  R8 =              35 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t5\t  R12=              64 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t6\t  R8 =              36 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2086]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t8\t  R8 =              38 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t8\t  R12=               0 R13=               0 R14=               0 R15=            1980\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2077]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\n\u001b[0m\n\u001b[0m\u2699 \u001b[0minvalid Invalid Tool\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2060,8 +2060,13 @@\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n \t\tbreak;\n \t}\n+\tif (r->nreaders == 0 && r->writer == 0) {\n+\t\trp->state = RW_UPGRADED;\n+\t\tr->writer = esecuzione->id;\n+\t\tbreak;\n+\t}\n } else {\n \trp->state = RW_UPGRADED;\n \tr->writer = esecuzione->id;\n \tbreak;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6fd6 memsize   6fd6\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31dc memsize   31dc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6fd6 byte da   10c000 a   200000\nINF\t-\t- copiati   31dc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205dfb\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t5\t  R8 =              35 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t6\t  R8 =              36 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2091]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff78 RSP=      ffffffff70\nWRN\t8\t  R8 =              38 R9 =      fffffffdb7 R10=               0 R11=               0\nWRN\t8\t  R12=ffff8000000077c4 R13=               0 R14=               0 R15=            1980\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2082]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 3s boot 2>&1 | grep -E \"TEST [0-9]\"\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\n\u001b[0m\nLet me reconsider the priority rules. According to the spec, readers should have priority when acquiring a lock. Let me also reconsider how the wakeup should work:\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2044,34 +2044,17 @@\n \t\tc_abort_p();\n \t\treturn;\n \t}\n \n-\tbool gia_rilasciato = false;\n-\twhile (true) {\n-\t\tif (!gia_rilasciato) {\n-\t\t\tr->nreaders--;\n-\t\t\trp->state = RW_NONE;\n-\t\t\tgia_rilasciato = true;\n-\t\t}\n+\tr->nreaders--;\n+\trp->state = RW_NONE;\n \n-\t\tif (r->nreaders > 0 || r->writer) {\n-\t\t\tinserimento_lista(r->w_writers, esecuzione);\n-\t\t\tschedulatore();\n-\t\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n-\t\t\t\trp->r = nullptr;\n-\t\t\t\trp->state = RW_NONE;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t\tif (r->nreaders == 0 && r->writer == 0) {\n-\t\t\t\trp->state = RW_UPGRADED;\n-\t\t\t\tr->writer = esecuzione->id;\n-\t\t\t\tbreak;\n-\t\t\t}\n-\t\t} else {\n-\t\t\trp->state = RW_UPGRADED;\n-\t\t\tr->writer = esecuzione->id;\n-\t\t\tbreak;\n-\t\t}\n+\tif (r->nreaders > 0 || r->writer) {\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t} else {\n+\t\trp->state = RW_UPGRADED;\n+\t\tr->writer = esecuzione->id;\n \t}\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2078,29 +2078,29 @@\n if (rp->state == RW_UPGRADED) {\n \tr->writer = 0;\n \trp->state = RW_READER;\n \tr->nreaders++;\n-\tif (r->w_writers) {\n-\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\tif (r->w_readers) {\n+\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n \t\tlavoro->puntatore = nullptr;\n \t\tinspronti();\n \t\tinserimento_lista(pronti, lavoro);\n \t}\n } else if (rp->state == RW_WRITER) {\n \tr->writer = 0;\n \trp->r = nullptr;\n \trp->state = RW_NONE;\n-\tif (r->w_writers) {\n-\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\tif (r->w_readers) {\n+\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n \t\tlavoro->puntatore = nullptr;\n \t\tinspronti();\n \t\tinserimento_lista(pronti, lavoro);\n-\t} else if (r->w_readers) {\n-\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n+\t\tr->nreaders++;\n+\t} else if (r->w_writers) {\n+\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n \t\tlavoro->puntatore = nullptr;\n \t\tinspronti();\n \t\tinserimento_lista(pronti, lavoro);\n-\t\tr->nreaders++;\n \t}\n } else if (rp->state == RW_READER) {\n \tr->nreaders--;\n \trp->r = nullptr;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f24 memsize   6f24\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31cc memsize   31cc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f24 byte da   10c000 a   200000\nINF\t-\t- copiati   31cc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d49\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t5\t  R8 =              35 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t6\t  R8 =              36 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t6\t  R12=            1720 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2074]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffffa8 RSP=      ffffffffa0\nWRN\t8\t  R8 =              38 R9 =      fffffffde7 R10=               0 R11=               0\nWRN\t8\t  R12=            18e0 R13=               0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2065]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2050,8 +2050,10 @@\n \n if (r->nreaders > 0 || r->writer) {\n \tinserimento_lista(r->w_writers, esecuzione);\n \tschedulatore();\n+\trp->state = RW_UPGRADED;\n+\tr->writer = esecuzione->id;\n } else {\n \trp->state = RW_UPGRADED;\n \tr->writer = esecuzione->id;\n }\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f58 memsize   6f58\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f58 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d7d\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t5\t  R8 =              35 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t6\t  R8 =              36 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=            1720 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2076]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t8\t  R8 =              38 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t8\t  R12=            1980 R13=            18e0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2067]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=50, offset=176]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=30, offset=2028]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2050,10 +2050,15 @@\n \n if (r->nreaders > 0 || r->writer) {\n \tinserimento_lista(r->w_writers, esecuzione);\n \tschedulatore();\n-\trp->state = RW_UPGRADED;\n-\tr->writer = esecuzione->id;\n+\tif (r->writer == 0) {\n+\t\trp->state = RW_UPGRADED;\n+\t\tr->writer = esecuzione->id;\n+\t} else {\n+\t\trp->r = nullptr;\n+\t\trp->state = RW_NONE;\n+\t}\n } else {\n \trp->state = RW_UPGRADED;\n \tr->writer = esecuzione->id;\n }\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f86 memsize   6f86\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31dc memsize   31dc\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f86 byte da   10c000 a   200000\nINF\t-\t- copiati   31dc byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205dab\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t5\t  R8 =              35 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t6\t  R8 =              36 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=            1720 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2081]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff88 RSP=      ffffffff80\nWRN\t8\t  R8 =              38 R9 =      fffffffdc7 R10=               0 R11=               0\nWRN\t8\t  R12=            1980 R13=            18e0 R14=               0 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2072]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\nINF\t11\tProcesso 11 terminato\n\u001b[0m\nGiven the time spent on this complex issue, let me try a simpler approach. Let me simplify the implementation to focus on making the basic case work:\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2047,22 +2047,19 @@\n \n \tr->nreaders--;\n \trp->state = RW_NONE;\n \n-\tif (r->nreaders > 0 || r->writer) {\n+\twhile (r->nreaders > 0 || r->writer) {\n \t\tinserimento_lista(r->w_writers, esecuzione);\n \t\tschedulatore();\n-\t\tif (r->writer == 0) {\n-\t\t\trp->state = RW_UPGRADED;\n-\t\t\tr->writer = esecuzione->id;\n-\t\t} else {\n+\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n \t\t\trp->r = nullptr;\n-\t\t\trp->state = RW_NONE;\n+\t\t\treturn;\n \t\t}\n-\t} else {\n-\t\trp->state = RW_UPGRADED;\n-\t\tr->writer = esecuzione->id;\n \t}\n+\n+\trp->state = RW_UPGRADED;\n+\tr->writer = esecuzione->id;\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n extern \"C\" void c_rw_downgrade(natl rw)\n@@ -2085,29 +2082,29 @@\n \tif (rp->state == RW_UPGRADED) {\n \t\tr->writer = 0;\n \t\trp->state = RW_READER;\n \t\tr->nreaders++;\n-\t\tif (r->w_readers) {\n-\t\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n \t\t\tlavoro->puntatore = nullptr;\n \t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, lavoro);\n \t\t}\n \t} else if (rp->state == RW_WRITER) {\n \t\tr->writer = 0;\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n-\t\tif (r->w_readers) {\n-\t\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n \t\t\tlavoro->puntatore = nullptr;\n \t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, lavoro);\n-\t\t\tr->nreaders++;\n-\t\t} else if (r->w_writers) {\n-\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t} else if (r->w_readers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n \t\t\tlavoro->puntatore = nullptr;\n \t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, lavoro);\n+\t\t\tr->nreaders++;\n \t\t}\n \t} else if (rp->state == RW_READER) {\n \t\tr->nreaders--;\n \t\trp->r = nullptr;\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 15s boot 2>&1\n\u001bc\u001b[?7l\u001b[2J\u001b[0mSeaBIOS (version rel-1.16.3-0-ga6ed6b701f0a-prebuilt.qemu.org)\n\t\t\nBooting from ROM..INF\t-\tBoot loader di Calcolatori Elettronici, v1.0\nINF\t-\tMemoria totale: 32 MiB, heap: 636 KiB\nINF\t-\tArgomenti: /home/vscode//CE/lib/ce/boot.bin \nINF\t-\tIl boot loader precedente ha caricato 3 moduli:\nINF\t-\t- mod[0]: start=10c000 end=117b40 file=boot/0-sistema\nINF\t-\t  . seg[1]: off      0 vaddr           200000 size   6f76 memsize   6f76\nINF\t-\t  . seg[2]: off   7000 vaddr           207000 size   31d4 memsize   31d4\nINF\t-\t  . seg[3]: off   b000 vaddr           20b000 size    180 memsize  17d84\nINF\t-\t- mod[1]: start=118000 end=11e578 file=boot/1-io\nINF\t-\t  . seg[1]: off      0 vaddr      10000000000 size   3b29 memsize   3b29\nINF\t-\t  . seg[2]: off   4000 vaddr      10000004000 size   19bc memsize   19bc\nINF\t-\t  . seg[3]: off   6000 vaddr      10000006000 size    190 memsize    200\nINF\t-\t- mod[2]: start=11f000 end=1266c8 file=boot/2-utente\nINF\t-\t  . seg[1]: off      0 vaddr ffff800000000000 size   4984 memsize   4984\nINF\t-\t  . seg[2]: off   5000 vaddr ffff800000005000 size   1034 memsize   1034\nINF\t-\t  . seg[3]: off   7000 vaddr ffff800000007000 size    2d8 memsize    800\nINF\t-\tCopio mod[0] agli indirizzi specificati nel file ELF:\nINF\t-\t- copiati   6f76 byte da   10c000 a   200000\nINF\t-\t- copiati   31d4 byte da   113000 a   207000\nINF\t-\t- copiati    180 byte da   117000 a   20b000\nINF\t-\t- azzerati ulteriori 17c04 byte\nINF\t-\t- entry point 205d9b\nINF\t-\tCreata finestra sulla memoria centrale:  [            1000,          2000000)\nINF\t-\tCreata finestra per memory-mapped-IO:    [         2000000,        100000000)\nINF\t-\tInizializzo l'APIC\nINF\t-\tInizializzo video e tastiera\nINF\t-\tAttivo la modalita' a 64 bit e cedo il controllo a mod[0]...\nINF\t0\tNucleo di Calcolatori Elettronici, v8.3\nINF\t0\tNumero di frame: 547 (M1) 7645 (M2)\nINF\t0\tSuddivisione della memoria virtuale:\nINF\t0\t- sis/cond [               0,       8000000000)\nINF\t0\t- sis/priv [      8000000000,      10000000000)\nINF\t0\t- io /cond [     10000000000,      18000000000)\nINF\t0\t- usr/cond [ffff800000000000, ffffc00000000000)\nINF\t0\t- usr/priv [ffffc00000000000,                0)\nINF\t0\tCarico il modulo I/O\nINF\t0\t - segmento sistema read-only  mappato a [     10000000000,      10000004000)\nINF\t0\t - segmento sistema read-only  mappato a [     10000004000,      10000006000)\nINF\t0\t - segmento sistema read/write mappato a [     10000006000,      10000007000)\nINF\t0\t - heap:                                 [     10000007000,      10000107000)\nINF\t0\t - entry point: _start [io.s:17]\nINF\t0\tCarico il modulo utente\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000000000, ffff800000005000)\nINF\t0\t - segmento utente  read-only  mappato a [ffff800000005000, ffff800000007000)\nINF\t0\t - segmento utente  read/write mappato a [ffff800000007000, ffff800000008000)\nINF\t0\t - heap:                                 [ffff800000008000, ffff800000108000)\nINF\t0\t - entry point: _start [utente.s:15]\nINF\t0\tFrame liberi: 7112 (M2)\nINF\t0\tHeap del modulo sistema: aggiunto [100000, 200000)\nINF\t0\tAttivo il timer (DELAY=59659)\nINF\t0\tCreo il processo main I/O\nINF\t0\tAttendo inizializzazione modulo I/O...\nINF\t1\tHeap del modulo I/O: 100000B [0x10000007000, 0x10000107000)\nINF\t1\tInizializzo la console (kbd + vid)\nINF\t1\testern=2 entry=estern_kbd(unsigned long) [io.cpp:197](0) prio=1104 (tipo=50) liv=0 irq=1\nINF\t1\tkbd: tastiera inizializzata\nINF\t1\tvid: video inizializzato\nINF\t1\tInizializzo la gestione dell'hard disk\nINF\t1\tbm: 00:01.1\nINF\t1\testern=3 entry=estern_hd(unsigned long) [io.cpp:557](0) prio=1120 (tipo=60) liv=0 irq=14\nINF\t1\tProcesso 1 terminato\nINF\t0\tCreo il processo main utente\nINF\t0\tCedo il controllo al processo main utente...\nINF\t4\tHeap del modulo utente: 100000B [0xffff800000007800, 0xffff800000107800)\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nINF\t4\tproc=5 entry=t00p0b(unsigned long) [utente.cpp:66](0) prio=600 liv=3\nINF\t4\tproc=6 entry=t00p1b(unsigned long) [utente.cpp:73](0) prio=599 liv=3\nINF\t4\tproc=7 entry=t00p2b(unsigned long) [utente.cpp:81](0) prio=598 liv=3\nINF\t4\tproc=8 entry=t00p3b(unsigned long) [utente.cpp:88](0) prio=597 liv=3\nINF\t4\tproc=9 entry=t00p4b(unsigned long) [utente.cpp:96](0) prio=596 liv=3\nWRN\t5\trw_upgrade(100): rwlock non valido\nWRN\t5\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t5\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t5\t  RAX=               a RBX=            1640 RCX=               0 RDX=      ffffff03f8\nWRN\t5\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t5\t  R8 =              35 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t5\t  R12=               0 R13=              64 R14=               0 R15=               0\nWRN\t5\t  backtrace:\nWRN\t5\t  > c_rw_upgrade [sistema.cpp:2035]\nWRN\t5\t  > a_rw_upgrade [sistema.s:448]\nWRN\t5\t  > rw_upgrade [utente.s:169]\nWRN\t5\t  > t00p0b(unsigned long) [utente.cpp:67]\nWRN\t5\tProcesso 5 abortito\nWRN\t6\trw_upgrade(0): lock in lettura non posseduto\nWRN\t6\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t6\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t6\t  RAX=               a RBX=            1720 RCX=               0 RDX=      ffffff03f8\nWRN\t6\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t6\t  R8 =              36 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t6\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t6\t  backtrace:\nWRN\t6\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t6\t  > a_rw_upgrade [sistema.s:448]\nWRN\t6\t  > rw_upgrade [utente.s:169]\nWRN\t6\t  > t00p1b(unsigned long) [utente.cpp:75]\nWRN\t6\tProcesso 6 abortito\nWRN\t7\trw_downgrade(0): lock non posseduto\nWRN\t7\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t7\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t7\t  RAX=               a RBX=            1800 RCX=               0 RDX=      ffffff03f8\nWRN\t7\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t7\t  R8 =              37 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t7\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t7\t  backtrace:\nWRN\t7\t  > c_rw_downgrade [sistema.cpp:2078]\nWRN\t7\t  > a_rw_downgrade [sistema.s:460]\nWRN\t7\t  > rw_downgrade [utente.s:176]\nWRN\t7\t  > t00p2b(unsigned long) [utente.cpp:82]\nWRN\t7\tProcesso 7 abortito\nWRN\t8\trw_upgrade(0): lock in lettura non posseduto\nWRN\t8\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t8\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t8\t  RAX=               a RBX=            18e0 RCX=               0 RDX=      ffffff03f8\nWRN\t8\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t8\t  R8 =              38 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t8\t  R12=ffff8000000077c4 R13=               0 R14=            1980 R15=               0\nWRN\t8\t  backtrace:\nWRN\t8\t  > c_rw_upgrade [sistema.cpp:2044]\nWRN\t8\t  > a_rw_upgrade [sistema.s:448]\nWRN\t8\t  > rw_upgrade [utente.s:169]\nWRN\t8\t  > t00p3b(unsigned long) [utente.cpp:90]\nWRN\t8\tProcesso 8 abortito\nWRN\t9\trw_downgrade(1): rwlock non valido\nWRN\t9\t  RIP=c_abort_p [sistema.cpp:1220] CPL=LIV_SISTEMA\nWRN\t9\t  RFLAGS=2 [-- -- -- -- -- -- -- -- -- --, IOPL=SISTEMA]\nWRN\t9\t  RAX=               a RBX=            19c0 RCX=               0 RDX=      ffffff03f8\nWRN\t9\t  RDI=               2 RSI=             3f8 RBP=      ffffffff98 RSP=      ffffffff90\nWRN\t9\t  R8 =              39 R9 =      fffffffdd7 R10=               0 R11=               0\nWRN\t9\t  R12=               0 R13=               0 R14=               0 R15=               0\nWRN\t9\t  backtrace:\nWRN\t9\t  > c_rw_downgrade [sistema.cpp:2069]\nWRN\t9\t  > a_rw_downgrade [sistema.s:460]\nWRN\t9\t  > rw_downgrade [utente.s:176]\nWRN\t9\t  > t00p4b(unsigned long) [utente.cpp:97]\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nINF\t4\tproc=10 entry=t01p0b(unsigned long) [utente.cpp:112](1) prio=595 liv=3\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t4\tproc=11 entry=t02p0b(unsigned long) [utente.cpp:137](2) prio=594 liv=3\nINF\t4\tproc=12 entry=t02p1b(unsigned long) [utente.cpp:150](2) prio=593 liv=3\nINF\t4\tproc=13 entry=t02p2b(unsigned long) [utente.cpp:162](2) prio=592 liv=3\nINF\t10\tProcesso 10 terminato\n\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=50, offset=2030]\u001b[0m\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2029,8 +2029,10 @@\n \n /// Parte C++ della primitiva rw_upgrade()\n extern \"C\" void c_rw_upgrade(natl rw)\n {\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d start\", esecuzione->id);\n+\n \tif (!rw_valido(rw)) {\n \t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n \t\tc_abort_p();\n \t\treturn;\n@@ -2047,19 +2049,24 @@\n \n \tr->nreaders--;\n \trp->state = RW_NONE;\n \n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\n \twhile (r->nreaders > 0 || r->writer) {\n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d waiting nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n \t\tinserimento_lista(r->w_writers, esecuzione);\n \t\tschedulatore();\n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d woke up nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n \t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n \t\t\trp->r = nullptr;\n \t\t\treturn;\n \t\t}\n \t}\n \n \trp->state = RW_UPGRADED;\n \tr->writer = esecuzione->id;\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d acquired upgrade lock\", esecuzione->id);\n }\n \n /// Parte C++ della primitiva rw_downgrade()\n extern \"C\" void c_rw_downgrade(natl rw)\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*rw_upgrade\"\nDBG\t5\trw_upgrade: proc=5 start\nDBG\t6\trw_upgrade: proc=6 start\nDBG\t8\trw_upgrade: proc=8 start\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t10\trw_upgrade: proc=10 start\nDBG\t10\trw_upgrade: proc=10 nreaders=0 writer=0\nDBG\t10\trw_upgrade: proc=10 acquired upgrade lock\nDBG\t12\trw_upgrade: proc=12 start\nDBG\t12\trw_upgrade: proc=12 nreaders=1 writer=0\nDBG\t12\trw_upgrade: proc=12 waiting nreaders=1 writer=0\nDBG\t13\trw_upgrade: proc=13 woke up nreaders=1 writer=0\nDBG\t13\trw_upgrade: proc=13 waiting nreaders=1 writer=0\nDBG\t0\trw_upgrade: proc=0 woke up nreaders=1 writer=0\nDBG\t0\trw_upgrade: proc=0 waiting nreaders=1 writer=0\n\u001b[0m\n\u001b[0m\u2190 \u001b[0mEdit sistema/sistema.cpp\nIndex: /work/es2/nucleo/sistema/sistema.cpp\n===================================================================\n--- /work/es2/nucleo/sistema/sistema.cpp\n+++ /work/es2/nucleo/sistema/sistema.cpp\n@@ -2070,15 +2070,19 @@\n \n /// Parte C++ della primitiva rw_downgrade()\n extern \"C\" void c_rw_downgrade(natl rw)\n {\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d start\", esecuzione->id);\n+\n \tif (!rw_valido(rw)) {\n \t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n \t\tc_abort_p();\n \t\treturn;\n \t}\n \n \tdes_rw *r = &array_desrw[rw];\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\n \tdes_proc_rw *rp = rw_proc_find(r);\n \n \tif (!rp || rp->state == RW_NONE) {\n \t\tflog(LOG_WARN, \"rw_downgrade(%d): lock non posseduto\", rw);\n@@ -2115,11 +2119,13 @@\n \t} else if (rp->state == RW_READER) {\n \t\tr->nreaders--;\n \t\trp->r = nullptr;\n \t\trp->state = RW_NONE;\n+\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d after decrement nreaders=%d w_writers=%p\", esecuzione->id, r->nreaders, r->w_writers);\n \t\tif (r->nreaders == 0 && r->w_writers) {\n \t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n \t\t\tlavoro->puntatore = nullptr;\n+\t\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d waking proc=%d\", esecuzione->id, lavoro->id);\n \t\t\tinspronti();\n \t\t\tinserimento_lista(pronti, lavoro);\n \t\t}\n \t}\n\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && make 2>&1\n[compile] ==> Compilo  sistema/sistema.cpp\n[compile] ==> Assemblo sistema/sistema.s\n[compile] ==> Collego  debug/0-sistema [0x200000]\n[compile] ==> Genero   boot/0-sistema\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*(rw_upgrade|rw_downgrade).*(proc=1[12])\"\nDBG\t12\trw_upgrade: proc=12 start\nDBG\t12\trw_upgrade: proc=12 nreaders=1 writer=0\nDBG\t12\trw_upgrade: proc=12 waiting nreaders=1 writer=0\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*(proc=11)\"\n\u001b[0m\u2192 \u001b[0mRead utente/utente.cpp\u001b[90m [limit=30, offset=136]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 5s boot 2>&1 | grep -E \"DBG.*(proc=13)\"\nDBG\t13\trw_upgrade: proc=13 woke up nreaders=1 writer=0\nDBG\t13\trw_upgrade: proc=13 waiting nreaders=1 writer=0\n\u001b[0m\n\u001b[0m\u2731 \u001b[0mGrep \"c_sem_wait\"\u001b[90m 1 match\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=263]\u001b[0m\n\u001b[0m\u2192 \u001b[0mRead sistema/sistema.cpp\u001b[90m [limit=20, offset=283]\u001b[0m\n\u001b[0m\n\u001b[0m$ \u001b[0mcd /work/es2/nucleo && timeout 3s boot 2>&1 | grep -E \"TEST|Processo\"\nINF\t1\tProcesso 1 terminato\nDBG\t4\tTEST 0: >>>INIZIO<<<: errori vari\nWRN\t5\tProcesso 5 abortito\nWRN\t6\tProcesso 6 abortito\nWRN\t7\tProcesso 7 abortito\nWRN\t8\tProcesso 8 abortito\nWRN\t9\tProcesso 9 abortito\nDBG\t4\tTEST 0: === FINE ===\nDBG\t4\tTEST 1: >>>INIZIO<<<: caso base\nUSR\t4\tTEST 1 PROC 4: OK\nDBG\t4\tTEST 1: === FINE ===\nDBG\t4\tTEST 2: >>>INIZIO<<<: piu' lettori\nINF\t10\tProcesso 10 terminato\n\u001b[0m\n\u001b[93m\u001b[1m! \u001b[0m maximum turns of 100 reached, stopping session\n",
  "duration_seconds": 1023.84,
  "turns": 100,
  "max_turns": 100,
  "diff": "diff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 44b9249..4da5013 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -2026,6 +2026,110 @@ extern \"C\" void c_rw_readlock(natl rw)\n \t}\n }\n // ( SOLUZIONE 2024-09-11\n+\n+/// Parte C++ della primitiva rw_upgrade()\n+extern \"C\" void c_rw_upgrade(natl rw)\n+{\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d start\", esecuzione->id);\n+\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state != RW_READER) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): lock in lettura non posseduto\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tr->nreaders--;\n+\trp->state = RW_NONE;\n+\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\n+\twhile (r->nreaders > 0 || r->writer) {\n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d waiting nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d woke up nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n+\t\t\trp->r = nullptr;\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\trp->state = RW_UPGRADED;\n+\tr->writer = esecuzione->id;\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d acquired upgrade lock\", esecuzione->id);\n+}\n+\n+/// Parte C++ della primitiva rw_downgrade()\n+extern \"C\" void c_rw_downgrade(natl rw)\n+{\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d start\", esecuzione->id);\n+\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state == RW_NONE) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): lock non posseduto\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tif (rp->state == RW_UPGRADED) {\n+\t\tr->writer = 0;\n+\t\trp->state = RW_READER;\n+\t\tr->nreaders++;\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t}\n+\t} else if (rp->state == RW_WRITER) {\n+\t\tr->writer = 0;\n+\t\trp->r = nullptr;\n+\t\trp->state = RW_NONE;\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t} else if (r->w_readers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t\tr->nreaders++;\n+\t\t}\n+\t} else if (rp->state == RW_READER) {\n+\t\tr->nreaders--;\n+\t\trp->r = nullptr;\n+\t\trp->state = RW_NONE;\n+\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d after decrement nreaders=%d w_writers=%p\", esecuzione->id, r->nreaders, r->w_writers);\n+\t\tif (r->nreaders == 0 && r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d waking proc=%d\", esecuzione->id, lavoro->id);\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t}\n+\t}\n+}\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \ndiff --git a/sistema/sistema.cpp b/sistema/sistema.cpp\nindex 44b9249..4da5013 100644\n--- a/sistema/sistema.cpp\n+++ b/sistema/sistema.cpp\n@@ -2026,6 +2026,110 @@ extern \"C\" void c_rw_readlock(natl rw)\n \t}\n }\n // ( SOLUZIONE 2024-09-11\n+\n+/// Parte C++ della primitiva rw_upgrade()\n+extern \"C\" void c_rw_upgrade(natl rw)\n+{\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d start\", esecuzione->id);\n+\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state != RW_READER) {\n+\t\tflog(LOG_WARN, \"rw_upgrade(%d): lock in lettura non posseduto\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tr->nreaders--;\n+\trp->state = RW_NONE;\n+\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\n+\twhile (r->nreaders > 0 || r->writer) {\n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d waiting nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\t\tinserimento_lista(r->w_writers, esecuzione);\n+\t\tschedulatore();\n+\t\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d woke up nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\t\tif (r->writer != 0 && r->writer != esecuzione->id) {\n+\t\t\trp->r = nullptr;\n+\t\t\treturn;\n+\t\t}\n+\t}\n+\n+\trp->state = RW_UPGRADED;\n+\tr->writer = esecuzione->id;\n+\tflog(LOG_DEBUG, \"rw_upgrade: proc=%d acquired upgrade lock\", esecuzione->id);\n+}\n+\n+/// Parte C++ della primitiva rw_downgrade()\n+extern \"C\" void c_rw_downgrade(natl rw)\n+{\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d start\", esecuzione->id);\n+\n+\tif (!rw_valido(rw)) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): rwlock non valido\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tdes_rw *r = &array_desrw[rw];\n+\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d nreaders=%d writer=%d\", esecuzione->id, r->nreaders, r->writer);\n+\n+\tdes_proc_rw *rp = rw_proc_find(r);\n+\n+\tif (!rp || rp->state == RW_NONE) {\n+\t\tflog(LOG_WARN, \"rw_downgrade(%d): lock non posseduto\", rw);\n+\t\tc_abort_p();\n+\t\treturn;\n+\t}\n+\n+\tif (rp->state == RW_UPGRADED) {\n+\t\tr->writer = 0;\n+\t\trp->state = RW_READER;\n+\t\tr->nreaders++;\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t}\n+\t} else if (rp->state == RW_WRITER) {\n+\t\tr->writer = 0;\n+\t\trp->r = nullptr;\n+\t\trp->state = RW_NONE;\n+\t\tif (r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t} else if (r->w_readers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_readers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t\tr->nreaders++;\n+\t\t}\n+\t} else if (rp->state == RW_READER) {\n+\t\tr->nreaders--;\n+\t\trp->r = nullptr;\n+\t\trp->state = RW_NONE;\n+\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d after decrement nreaders=%d w_writers=%p\", esecuzione->id, r->nreaders, r->w_writers);\n+\t\tif (r->nreaders == 0 && r->w_writers) {\n+\t\t\tdes_proc* lavoro = rimozione_lista(r->w_writers);\n+\t\t\tlavoro->puntatore = nullptr;\n+\t\t\tflog(LOG_DEBUG, \"rw_downgrade: proc=%d waking proc=%d\", esecuzione->id, lavoro->id);\n+\t\t\tinspronti();\n+\t\t\tinserimento_lista(pronti, lavoro);\n+\t\t}\n+\t}\n+}\n //   SOLUZIONE 2024-09-11 )\n //   ESAME 2024-09-11 )\n \n",
  "error": null
}